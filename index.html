<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4Metas Mini App</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src='//whephiwums.com/sdk.js' data-zone='9180370' data-sdk='show_9180370'></script>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <header>
        <div class="back-arrow">X</div>
        <h1>4Metas</h1>
        <div class="menu-dots">â‹®</div>
    </header>

    <div class="main-content">
        <section class="user-stats">
            </section>

        <section id="earn" class="section earn-section active">
             </section>

        <section id="wallet" class="section wallet-section">
             </section>

        <section id="game" class="section game-section">
             </section>

        <section id="invite" class="section invite-section">
             </section>

        <section id="chest" class="section chest-section">
             </section>

        <section id="top" class="section top-section">
            </section>
    </div>

    <nav class="bottom-nav">
         </nav>

    <div id="debugConsole"></div>
    <button id="toggleDebugButton"> Debug
    </button>

    <script src="js/config.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/firebaseService.js"></script>
    <script src="js/telegramService.js"></script>
     <script src="js/walletService.js"></script>
    <script src="js/adService.js"></script>
    <script src="js/uiUpdater.js"></script>
    <script src="js/sections/earn.js"></script>
    <script src="js/sections/invite.js"></script>
    <script src="js/sections/chest.js"></script>
    <script src="js/sections/top.js"></script>
    <script src="js/navigation.js"></script>
    <script src="js/main.js"></script> </body>
</html>



/* Updated body structure */
body {
    background: linear-gradient(to bottom, #330033, #000000);
    color: white;
    /* ... (all other CSS rules) ... */
}

/* Debug Console Style */
 #debugConsole {
     /* ... */
 }
 #toggleDebugButton {
     /* ... */
 }



// js/main.js

// --- Global Variables ---
// Firebase variables (initialized in firebaseService.js)
let app = null, db = null, auth = null, storage = null, analytics = null;
let firebaseInitialized = false;
// Telegram user info (initialized in telegramService.js)
let telegramUser = null;
// TON Connect UI instance (initialized in walletService.js)
let tonConnectUI = null;
// User data cache (initialized/updated in uiUpdater.js)
let currentUserData = null;
// Chest state (initialized/updated in chest.js) - Keep it here or in chest.js? Decision: Keep in chest.js for now.
// let currentChestIndex = 0;


// --- Main Initialization Function ---
async function initApp() {
    debugLog("--- App Initialization Sequence Start ---");

    // 1. Initialize Telegram Interface & Get User
    initializeTelegram(); // From telegramService.js
    // Update profile pic based on telegramUser (can be done here or in updateUserStatsUI)
    updateUserStatsUI(); // Initial update with default/test user potentially

    // 2. Initialize Firebase
    const firebaseSuccess = await initializeFirebase(); // From firebaseService.js
    if (!firebaseSuccess) {
        debugLog("App Init Failed: Firebase could not be initialized.");
        alert("Critical Error: Could not connect to backend services. Please try restarting.");
        return; // Stop initialization
    }

    // 3. Initialize User Data in Firestore (Create if new, update login)
    // ensureFirebaseReady calls initializeUserData from uiUpdater.js
    await ensureFirebaseReady(initializeUserData, 'initializeUserData');
    // At this point, currentUserData should be populated by the fetch in initializeUserData

    // 4. Update Stats Bar with actual user data
    await updateUserStatsUI(); // From uiUpdater.js

    // 5. Handle Incoming Referrals (Check start_param)
    await ensureFirebaseReady(handleReferral, 'handleReferral'); // From invite.js

    // 6. Initialize TON Connect & Wallet System
    // ensureFirebaseReady not strictly needed here as initWalletSystem handles TON Connect init internally
    await initWalletSystem(); // From walletService.js (initializes TON Connect)

    // 7. Initialize Invite Section Listeners (Claim, Invite, Copy buttons)
    initInviteSectionListeners(); // From invite.js

    // 8. Render Dynamic Components (Chests)
    // Ensure user data (VIP, gems) is available before rendering chests that depend on it
    await ensureFirebaseReady(async () => {
        if (!window.currentUserData) await fetchAndUpdateUserData(); // Make sure data is loaded
        renderChests(); // From chest.js (sets up listeners internally now)
    }, 'renderChests');

    // 9. Setup Main Navigation (Sets default section and loads its data)
    setupNavigation(); // From navigation.js

    // 10. Initialize Automatic Ads
    initializeAutomaticAds(); // From adService.js

    // 11. Setup Global Event Listeners (delegation)
    setupGlobalEventListeners();

    debugLog("--- App Initialization Sequence Finished ---");
}

// --- Global Event Listeners ---
function setupGlobalEventListeners() {
    // Main click listener using event delegation
    document.body.addEventListener('click', (event) => {
        // Quest Button Clicks
        const questButton = event.target.closest('.quest-item .quest-reward button');
        if (questButton && !questButton.disabled) {
            handleQuestClick(questButton); // From earn.js
            return; // Prevent other handlers if this matched
        }

        // Debug Toggle Button
        const toggleButton = event.target.closest('#toggleDebugButton');
        if (toggleButton) {
            const consoleDiv = document.getElementById('debugConsole');
            if (consoleDiv) {
                consoleDiv.style.display = consoleDiv.style.display === 'none' ? 'block' : 'none';
            }
            return;
        }

        // Wallet Warning Button Click (Example)
        const warningButton = event.target.closest('.balance-card .warning-button');
        if (warningButton) {
             const card = warningButton.closest('.balance-card');
             const currency = card.classList.contains('usdt-card') ? 'USDT' : 'TON';
             alert(`Information about ${currency} balance or withdrawal process.`); // Replace with actual info/modal
             debugLog(`Warning button clicked for ${currency}`);
             return;
        }

        // Add other delegated listeners here if needed
        // e.g., Game item click
         const gameItem = event.target.closest('.game-item');
         if (gameItem) {
             const gameName = gameItem.querySelector('p')?.textContent || 'Unknown Game';
             alert(`Starting ${gameName}... (Implementation needed)`);
             debugLog(`Game item clicked: ${gameName}`);
             // Add logic to launch game or navigate
             return;
         }


    });

    debugLog("Global event listeners setup.");
}


// --- DOMContentLoaded ---
document.addEventListener('DOMContentLoaded', () => {
    console.log('[DEBUG] DOMContentLoaded event fired.');
    debugLog("DOMContentLoaded event fired. Starting App Initialization.");
    // Set initial state for debug console visibility
    const consoleDiv = document.getElementById('debugConsole');
    if (consoleDiv) consoleDiv.style.display = 'none';

    initApp(); // Start the main application logic
});


// js/sections/chest.js

// Global state specific to chests (if not managed in main.js)
let currentChestIndex = 0;
const chests = CHESTS_DATA; // Use constant from config.js

function renderChests() {
    debugLog("[CHEST] Rendering chests...");
    const container = document.getElementById('chestContainer');
    const slider = document.querySelector('.chest-slider'); // Get slider element
    if (!container || !slider) {
        debugLog("[CHEST ERROR] Chest container or slider not found.");
        return;
     }

     // Hide slider until chests are rendered to prevent layout shift
     slider.style.visibility = 'hidden';

    container.innerHTML = chests.map((chest, index) => `
        <div class="chest-item" data-index="${index}">
            <div class="chest-title">
                <h2>${chest.name}</h2>
                <span>${chest.next ? `Next: ${chest.next}` : 'Max Level'}</span>
            </div>
            <div class="chest-image">
                <img src="${chest.image}" alt="${chest.name}" onerror="this.src='assets/icons/chest_placeholder.png'">
            </div>
             <div class="chest-cost-display" style="display: flex; justify-content: center; align-items: center; gap: 5px; margin-top: 10px;"></div>
             <div class="chest-vip-display" style="display: none; color: #ffcc00; margin-top: 5px; font-size: 14px; text-align: center;"></div>
             <div class="chest-not-enough-display" style="display: none; color: #ffcc00; margin-top: 5px; font-size: 14px; text-align: center; align-items: center; justify-content: center; gap: 3px;">
                 <img src="assets/icons/gem.png" alt="Gem" style="width: 16px; height: 16px; vertical-align: middle;">
                 <span>NOT ENOUGH</span>
             </div>
        </div>
    `).join('');

    // Show slider after rendering
    slider.style.visibility = 'visible';

    debugLog(`[CHEST] Rendered ${chests.length} chests.`);
    setupChestListeners(); // Add listeners for arrows and open button
    updateChestUI(); // Initial UI update for the first chest
}

function setupChestListeners() {
     const leftArrow = document.querySelector('.chest-slider .nav-arrow.left');
     const rightArrow = document.querySelector('.chest-slider .nav-arrow.right');
     const openButton = document.querySelector('.chest-section .open-chest-button');

     if (leftArrow) {
         leftArrow.onclick = () => prevChest(); // Use arrow function to call
     }
     if (rightArrow) {
         rightArrow.onclick = () => nextChest(); // Use arrow function to call
     }
     if (openButton) {
         openButton.onclick = () => openChest(); // Use arrow function to call
     }
}


function updateChestUI() {
    // Ensure chests array is populated and index is valid
    if (!chests || chests.length === 0) {
        debugLog("[CHEST UI ERROR] Chest data not loaded.");
        return;
    }
    if (currentChestIndex < 0 || currentChestIndex >= chests.length) {
        console.error(`[CHEST UI ERROR] Invalid chest index: ${currentChestIndex}`);
        debugLog(`[CHEST UI ERROR] Invalid chest index: ${currentChestIndex}. Resetting to 0.`);
        currentChestIndex = 0; // Reset to first chest
    }

    const chest = chests[currentChestIndex];
     debugLog(`[CHEST] Updating UI for Chest index: ${currentChestIndex} (${chest.name})`);

    const container = document.getElementById('chestContainer');
    // Find the specific item being displayed + the general controls
    const currentChestItem = document.querySelector(`#chestContainer .chest-item[data-index="${currentChestIndex}"]`);
    const costDisplay = currentChestItem?.querySelector(`.chest-cost-display`); // Find within the specific item
    const vipDisplay = currentChestItem?.querySelector(`.chest-vip-display`);
    const notEnoughDisplay = currentChestItem?.querySelector(`.chest-not-enough-display`);
    const openButton = document.querySelector('.chest-section .open-chest-button'); // Main button outside slider
    const leftArrow = document.querySelector('.chest-slider .nav-arrow.left');
    const rightArrow = document.querySelector('.chest-slider .nav-arrow.right');
    const globalCostDisplay = document.getElementById('chestCost'); // The cost display below slider (if still used)


     if (!container || !currentChestItem || !costDisplay || !vipDisplay || !notEnoughDisplay || !openButton || !leftArrow || !rightArrow) {
        debugLog("[CHEST UI ERROR] One or more chest UI elements not found.");
        return;
     }

    // Update Slider Position Smoothly
    container.style.transform = `translateX(-${currentChestIndex * 100}%)`;

    // --- Update Cost/VIP/Button State ---
     costDisplay.style.display = 'none'; // Hide individual item displays initially
     vipDisplay.style.display = 'none';
     notEnoughDisplay.style.display = 'none';
     openButton.disabled = true; // Disable button by default until checks pass
     openButton.textContent = 'Open Chest'; // Default text

     // Use cached user data for checks
     // Needs global currentUserData
     const userData = window.currentUserData;
     const userVipLevel = userData?.vipLevel ?? -1; // Use ?? for null/undefined check, -1 if no data
     const userGems = userData?.gems ?? -1;

      // Ensure user data is loaded before proceeding
      if (userVipLevel === -1 || userGems === -1) {
          debugLog("[CHEST UI WARN] User data not available for chest checks. Disabling open button.");
          openButton.textContent = 'Loading...';
          // Hide cost/vip/not enough displays for the item
          costDisplay.style.display = 'none';
          vipDisplay.style.display = 'none';
          notEnoughDisplay.style.display = 'none';
           // Also update the global cost display if used
           if (globalCostDisplay) {
                globalCostDisplay.innerHTML = `<img src="assets/icons/gem.png" alt="Gem"> <span>...</span>`;
           }
      } else {
           debugLog(`[CHEST CHECK] User VIP: ${userVipLevel}, User Gems: ${userGems}, Chest: ${chest.name} (Needs VIP ${chest.vip}, Cost ${chest.gemCost})`);

          // Check VIP Level FIRST
          if (chest.vip > userVipLevel) {
              vipDisplay.textContent = `NEED VIP ${chest.vip}`;
              vipDisplay.style.display = 'block'; // Show VIP requirement in the item
              openButton.disabled = true;
              openButton.textContent = `VIP ${chest.vip} Required`;
              debugLog(`[CHEST] VIP ${chest.vip} required, user has ${userVipLevel}. Button disabled.`);
              // Hide cost and not enough displays
              costDisplay.style.display = 'none';
              notEnoughDisplay.style.display = 'none';
               // Also update the global cost display if used
               if (globalCostDisplay) {
                    globalCostDisplay.innerHTML = `<img src="assets/icons/gem.png" alt="Gem"> <span>${chest.gemCost.toLocaleString()}</span> (VIP ${chest.vip} Req.)`;
               }
          } else {
               // VIP Met, now check Gems
               costDisplay.innerHTML = `<img src="assets/icons/gem.png" alt="Gem" style="width: 20px; height: 20px; vertical-align: middle;"> <span>${chest.gemCost.toLocaleString()}</span>`;
               costDisplay.style.display = 'flex'; // Show cost in the item

               // Also update the global cost display if used
               if (globalCostDisplay) {
                    globalCostDisplay.innerHTML = `<img src="assets/icons/gem.png" alt="Gem"> <span>${chest.gemCost.toLocaleString()}</span>`;
               }


               if (userGems < chest.gemCost) {
                    notEnoughDisplay.style.display = 'flex'; // Show "NOT ENOUGH" in the item
                    openButton.disabled = true;
                    openButton.textContent = 'Open Chest'; // Keep text, but disabled
                    debugLog(`[CHEST] Insufficient gems. Need ${chest.gemCost}, user has ${userGems}. Button disabled.`);
               } else {
                   // VIP and Gems Met
                   openButton.disabled = false; // Enable the button!
                   openButton.textContent = 'Open Chest';
                   debugLog(`[CHEST] User meets VIP and Gem requirements. Button enabled.`);
               }
               // Ensure VIP display is hidden if requirements met
               vipDisplay.style.display = 'none';
          }
     }

    // Update Navigation Arrows Visibility
    leftArrow.style.display = currentChestIndex === 0 ? 'none' : 'block';
    rightArrow.style.display = currentChestIndex === chests.length - 1 ? 'none' : 'block';

     // Update Possible Rewards section (if it needs to change per chest type)
     updatePossibleRewardsUI(chest);
}

function updatePossibleRewardsUI(chest) {
    // Example: If rewards change based on chest, update the UI here.
    // For now, it seems static in the HTML, so this function might be simple.
    const rewardsContainer = document.querySelector('.chest-section .rewards');
    if (rewardsContainer) {
        // Modify content if needed, e.g., highlight likely rewards for 'chest.name'
        // Example: Add a class to highlight rewards based on chest type
        rewardsContainer.querySelectorAll('.reward-item').forEach(item => item.classList.remove('highlight'));
        if (chest.name === "Gold Chest") { // Example condition
            rewardsContainer.querySelector('.reward-item.usdt')?.classList.add('highlight');
        }
    }
     // Update VIP requirement text if the separate element exists
     const vipRequirementEl = document.getElementById('chestVipRequirement');
     if (vipRequirementEl) {
         if (chest.vip > 0) {
             vipRequirementEl.textContent = `NEED VIP ${chest.vip}`;
             // Show/hide based on whether the *currently viewed* chest needs VIP > 0
             // This element seems redundant if the logic is handled by the button state + item display
             // vipRequirementEl.style.display = 'block';
             vipRequirementEl.style.display = 'none'; // Prefer showing in item/button
         } else {
             vipRequirementEl.style.display = 'none';
         }
     }
}


function nextChest() {
    if (currentChestIndex < chests.length - 1) {
        currentChestIndex++;
        debugLog(`[CHEST] Next button clicked. New index: ${currentChestIndex}`);
        updateChestUI();
    }
}

function prevChest() {
    if (currentChestIndex > 0) {
        currentChestIndex--;
        debugLog(`[CHEST] Previous button clicked. New index: ${currentChestIndex}`);
        updateChestUI();
    }
}

async function openChest() {
     // Ensure chests array is populated and index is valid
     if (!chests || chests.length === 0 || currentChestIndex < 0 || currentChestIndex >= chests.length) {
         alert("Error: Chest data not loaded or invalid chest selected.");
         debugLog("[CHEST ACTION ERROR] Invalid chest state for opening.");
         return;
     }
     const chest = chests[currentChestIndex];
     debugLog(`[CHEST ACTION] Attempting to open chest: ${chest.name}`);

     const openButton = document.querySelector('.chest-section .open-chest-button');
     if (!openButton || openButton.disabled) {
         debugLog("[CHEST ACTION WARN] Open button not found or disabled.");
         return; // Don't proceed if button is disabled
     }
     openButton.disabled = true; openButton.textContent = 'Opening...';

     // Needs globals telegramUser, db, firebase, analytics
     if (!window.telegramUser || !window.telegramUser.id || !firebaseInitialized || !db || !firebase) {
        alert("User or Database not ready. Please reload.");
        openButton.disabled = false; // Re-enable button
        updateChestUI(); // Refresh UI state
        return;
     }

     const userDocRef = db.collection('userData').doc(window.telegramUser.id.toString());
     const rankingDocRef = db.collection('users').doc(window.telegramUser.id.toString());

     try {
          // --- Use a Transaction for Opening ---
          const rewards = await db.runTransaction(async (transaction) => {
              // Fetch latest data *within* the transaction for check
              const userDoc = await transaction.get(userDocRef);
              if (!userDoc.exists) throw new Error("User data not found to open chest.");
              const userData = userDoc.data();

             const currentGems = userData.gems || 0;
             const userVipLevel = userData.vipLevel || 0;

             debugLog(`[CHEST ACTION CHECK - TX] Checking requirements: Need VIP ${chest.vip} (Have ${userVipLevel}), Need Gems ${chest.gemCost} (Have ${currentGems})`);

             if (chest.vip > userVipLevel) throw new Error(`VIP Level ${chest.vip} required.`);
             if (currentGems < chest.gemCost) throw new Error(`Insufficient gems. Need ${chest.gemCost.toLocaleString()}, have ${currentGems.toLocaleString()}.`);

             // Simulate Reward Calculation (can be made more sophisticated)
             const calculatedRewards = {
                 usdt: parseFloat((Math.random() * (chest.gemCost / 4000) + (chest.gemCost / 10000)).toFixed(4)),
                 landPiece: Math.random() < 0.1 ? 1 : 0, // 10% chance for land piece
                 foxMedal: Math.floor(Math.random() * (currentChestIndex + 1)) + (chest.vip > 0 ? chest.vip : 1) // Example: More medals for higher chests/VIP
             };
             // Ensure rewards are non-negative
             calculatedRewards.usdt = Math.max(0, calculatedRewards.usdt);
             calculatedRewards.landPiece = Math.max(0, calculatedRewards.landPiece);
             calculatedRewards.foxMedal = Math.max(0, calculatedRewards.foxMedal);

             debugLog("[CHEST ACTION - TX] Calculated rewards:", calculatedRewards);

             // Prepare Firestore updates within the transaction
             const updates = {
                 gems: firebase.firestore.FieldValue.increment(-chest.gemCost),
                 usdt: firebase.firestore.FieldValue.increment(calculatedRewards.usdt),
                 landPieces: firebase.firestore.FieldValue.increment(calculatedRewards.landPiece),
                 foxMedals: firebase.firestore.FieldValue.increment(calculatedRewards.foxMedal)
             };
             transaction.update(userDocRef, updates);

             // Update ranking document if medals were awarded
             if (calculatedRewards.foxMedal > 0) {
                  // Use set with merge to ensure document exists or is updated atomically within the transaction
                  // Note: Reading the rankingDoc within the transaction might be needed if increments depend on previous value
                  transaction.set(rankingDocRef, {
                      foxMedals: firebase.firestore.FieldValue.increment(calculatedRewards.foxMedal)
                  }, { merge: true });
             }
             debugLog(`[CHEST ACTION - TX] Firestore updates prepared.`);
             return calculatedRewards; // Return rewards from transaction
          });
          // --- Transaction End ---

          debugLog(`[CHEST ACTION] Transaction successful. Chest opened. Rewards:`, rewards);
          if (window.analytics) window.analytics.logEvent('chest_opened', { userId: window.telegramUser.id, chestName: chest.name, cost: chest.gemCost, rewards });

          // Show Rewards Alert
          let rewardString = `Opened ${chest.name}! Rewards:\n`;
          if (rewards.usdt > 0) rewardString += `- ${rewards.usdt.toFixed(4)} USDT\n`;
          if (rewards.landPiece > 0) rewardString += `- ${rewards.landPiece} Land Piece\n`;
          if (rewards.foxMedal > 0) rewardString += `- ${rewards.foxMedal} Fox Medal\n`;
          if (rewards.usdt <= 0 && rewards.landPiece <= 0 && rewards.foxMedal <= 0) {
             rewardString += "- Nothing this time!"; // Handle case where all rewards are 0
          }
          alert(rewardString);

          // Update UI AFTER successful transaction
          await window.fetchAndUpdateUserData(); // Refresh cache with new balances
          await window.updateUserStatsUI(); // Update header stats
          updateChestUI(); // Re-check requirements/costs for the current chest & update button state

     } catch (error) {
         console.error("Error opening chest:", error);
         debugLog(`[CHEST ERROR] ${error.message}`);
         alert(`Failed to open chest: ${error.message}`);
         // Ensure button is re-enabled and UI reflects potential unchanged state
         openButton.disabled = false; // Re-enable after error
         updateChestUI(); // Crucial to reset button state based on actual data after failure

     }
     // No finally needed, button state handled by updateChestUI in success/error paths
 }


// js/sections/earn.js

async function updateEarnSectionUI() {
    debugLog("[QUEST DEBUG] Starting Earn section UI update...");
    const dailyQuestList = document.getElementById('daily-quest-list');
    const basicQuestList = document.getElementById('basic-quest-list');
    const dailyQuestCountEl = document.getElementById('daily-quest-count');
    const basicQuestCountEl = document.getElementById('basic-quest-count');

    if (!dailyQuestList || !basicQuestList || !dailyQuestCountEl || !basicQuestCountEl) {
        console.error("[QUEST ERROR] Required DOM elements for quests not found!");
        debugLog("[QUEST ERROR] Quest list or count elements missing from DOM.");
        return;
    }

    // Set initial loading state
    dailyQuestList.innerHTML = `<li class="loading"><p>Loading daily quests...</p></li>`;
    basicQuestList.innerHTML = `<li class="loading"><p>Loading basic quests...</p></li>`;
    dailyQuestCountEl.textContent = '-';
    basicQuestCountEl.textContent = '-';

    try {
        if (!firebaseInitialized || !db) { // Use globals from firebaseService.js
           throw new Error("Firestore not initialized for updating Earn section.");
        }
        // Use cached or fetch fresh user data
        let userData = window.currentUserData || await window.fetchAndUpdateUserData(); // Use globals from uiUpdater.js

        if (!userData) {
             throw new Error("User data not available for quest checks.");
        }
        // Ensure sub-objects exist
        userData.adProgress = userData.adProgress || {};
        userData.claimedQuests = userData.claimedQuests || [];
        debugLog("[QUEST DEBUG] User data loaded for quest checks.");


        // --- Fetch Daily Quests ---
        debugLog("[QUEST DEBUG] Fetching daily quests...");
        // Ensure Firestore instance 'db' is available
        const dailyQuestsSnapshot = await db.collection('quests').doc('daily').get({ source: 'server' });
        const dailyQuestsRaw = dailyQuestsSnapshot.exists ? dailyQuestsSnapshot.data() : {};
        const dailyQuests = dailyQuestsRaw.tasks || [];

        dailyQuestCountEl.textContent = dailyQuests.length;
        if (dailyQuests.length === 0) {
            dailyQuestList.innerHTML = `<li class="no-quests"><p>No daily quests available today.</p></li>`;
        } else {
            dailyQuestList.innerHTML = dailyQuests.map(quest => {
                // Validate quest object structure
                if (!quest || !quest.id || !quest.title || quest.reward === undefined) {
                     console.warn("Skipping invalid daily quest object:", quest);
                     return '';
                }
                const isClaimed = userData.claimedQuests.includes(quest.id);
                const buttonText = isClaimed ? 'Claimed' : (quest.action || 'GO');
                // Daily quests are typically non-repeatable link/action based, not ads
                const buttonClass = isClaimed ? 'claimed-button' : 'go-button';
                const buttonDisabled = isClaimed;
                const reward = Number(quest.reward) || 0;

                return `
                    <li class="quest-item" data-quest-id="${quest.id}" data-quest-type="daily">
                        <img src="${quest.icon || 'assets/icons/quest_placeholder.png'}" alt="${quest.title}" onerror="this.src='assets/icons/quest_placeholder.png'">
                        <span>${quest.title}</span>
                        <div class="quest-reward">
                            <img src="assets/icons/gem.png" alt="Gem">
                            <span>+${reward.toLocaleString()}</span>
                            <button class="${buttonClass}"
                                    data-quest-link="${quest.link || ''}"
                                    data-quest-reward="${reward}"
                                    ${buttonDisabled ? 'disabled' : ''}>
                                ${buttonText}
                            </button>
                        </div>
                    </li>
                `;
            }).join('');
        }
        debugLog("[QUEST DEBUG] Daily quests rendered.");


        // --- Fetch Basic Quests ---
        debugLog("[QUEST DEBUG] Fetching basic quests...");
        const basicQuestsSnapshot = await db.collection('quests').doc('basic').get({ source: 'server' });
        const basicQuestsRaw = basicQuestsSnapshot.exists ? basicQuestsSnapshot.data() : {};
        const basicQuests = basicQuestsRaw.tasks || [];

         // Ensure adProgress structure is initialized for all ad quests if not present
         let adProgressUpdateNeeded = false;
         const adProgressUpdate = {};
         basicQuests.forEach(quest => {
            // Ensure quest and quest.id are valid before checking type
            if (quest && quest.id && quest.type === 'ads' && !userData.adProgress[quest.id]) {
                userData.adProgress[quest.id] = { watched: 0, claimed: false, lastClaimed: null };
                adProgressUpdate[`adProgress.${quest.id}`] = userData.adProgress[quest.id];
                adProgressUpdateNeeded = true;
                debugLog(`[QUEST DEBUG] Initializing adProgress for new quest: ${quest.id}`);
            }
         });
         if (adProgressUpdateNeeded && window.telegramUser?.id) { // Check user ID exists
            await db.collection('userData').doc(window.telegramUser.id.toString()).update(adProgressUpdate);
            debugLog("[QUEST DEBUG] Updated user data with initial adProgress structures.");
            // Re-fetch user data or merge update locally if needed immediately
            userData = await window.fetchAndUpdateUserData(); // Refresh data after update
            if (!userData) throw new Error("User data unavailable after adProgress init.");
            userData.adProgress = userData.adProgress || {}; // Ensure it exists after refetch
            userData.claimedQuests = userData.claimedQuests || [];
         }


        basicQuestCountEl.textContent = basicQuests.length;
        if (basicQuests.length === 0) {
            basicQuestList.innerHTML = `<li class="no-quests"><p>No basic quests available right now.</p></li>`;
        } else {
            const currentTime = new Date(); // Get current time once for cooldown checks
            const cooldownPeriod = AD_QUEST_COOLDOWN_MS; // Use constant from config.js

             if (userData?.adProgress) {
                 debugLog("[QUEST DEBUG] adProgress data used for rendering basic quests:", JSON.stringify(userData.adProgress));
             }

            basicQuestList.innerHTML = basicQuests.map(quest => {
                // Validate quest object structure
                if (!quest || !quest.id || !quest.title || quest.reward === undefined) {
                     console.warn("Skipping invalid basic quest object:", quest);
                     return '';
                }

                const questId = quest.id;
                const questType = quest.type || 'default';
                const questTitle = quest.title;
                const questIcon = quest.icon || 'assets/icons/quest_placeholder.png';
                const questReward = Number(quest.reward) || 0;
                const questAction = quest.action || 'GO';
                const questLink = quest.link || '';
                const adLimit = questType === 'ads' ? Math.max(1, Number(quest.adLimit) || 1) : 0;
                const adType = quest.adType || 'rewarded_interstitial'; // Default if not specified

                debugLog(`[QUEST DEBUG] Processing Basic Quest: ${questTitle}`, {
                    id: questId, type: questType, rawAdLimit: quest.adLimit, calculatedAdLimit: adLimit, reward: questReward, adType: adType
                });

                let buttonText = questAction;
                let buttonClass = 'go-button';
                let buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);'; // Default GO style
                let buttonDisabled = false;
                let progressText = '';

                if (questType === 'ads') {
                    const adProgress = userData.adProgress[questId] || { watched: 0, claimed: false, lastClaimed: null };
                    progressText = `<span class="progress">${adProgress.watched}/${adLimit}</span>`;
                    const isCompleted = adProgress.watched >= adLimit;
                    let isClaimed = adProgress.claimed; // Use let to allow modification after cooldown reset
                    const lastClaimedTime = adProgress.lastClaimed ? new Date(adProgress.lastClaimed) : null;
                    const timeSinceLastClaim = lastClaimedTime ? currentTime - lastClaimedTime : Infinity;
                    let isCooldownOver = timeSinceLastClaim >= cooldownPeriod;

                    // Cooldown Reset Logic (handle potential errors during reset)
                    if (isClaimed && isCooldownOver) {
                        debugLog(`[QUEST DEBUG] Cooldown over for ad quest ${questId}. Resetting progress.`);
                        try {
                             // Asynchronously update Firestore
                             await db.collection('userData').doc(window.telegramUser.id.toString()).update({
                                 [`adProgress.${questId}`]: { watched: 0, claimed: false, lastClaimed: null }
                             });
                            // Update local state immediately for correct button rendering THIS RENDER CYCLE
                            adProgress.watched = 0;
                            adProgress.claimed = false; // Update local state
                            isClaimed = false; // Update variable used for button logic
                            adProgress.lastClaimed = null;
                            debugLog(`[QUEST DEBUG] Firestore updated asynchronously for ${questId} reset.`);
                             // Update the main userData cache
                             if(window.currentUserData?.adProgress?.[questId]) {
                                 window.currentUserData.adProgress[questId] = { watched: 0, claimed: false, lastClaimed: null };
                             }
                        } catch (resetError) {
                             console.error(`[QUEST ERROR] Failed Firestore reset for ${questId}:`, resetError);
                             debugLog(`[QUEST ERROR] Failed Firestore reset for ${questId}: ${resetError.message}`);
                             // Don't reset local state if DB update failed, keep showing cooldown timer
                             isCooldownOver = false; // Pretend cooldown isn't over for UI consistency
                        }
                    }

                    // Button State Logic (using potentially reset adProgress/isClaimed)
                    if (isClaimed && !isCooldownOver && lastClaimedTime) { // Added lastClaimedTime check
                        const timeLeftMillis = cooldownPeriod - timeSinceLastClaim;
                         const timeLeftMinutes = Math.max(1, Math.ceil(timeLeftMillis / 60000)); // Show at least 1m
                         buttonText = `Wait ${timeLeftMinutes}m`;
                         buttonClass = 'claimed-button';
                         buttonStyle = 'background: #ccc; cursor: default;';
                         buttonDisabled = true;
                    } else if (isCompleted && !isClaimed) {
                        buttonText = 'Claim';
                        buttonClass = 'claim-button active'; // Ensure 'active' class is present for styling
                        buttonStyle = 'background: linear-gradient(to right, #00ff00, #66ff66);'; // Claim style
                        buttonDisabled = false;
                    } else if (isCompleted && isClaimed) { // Already completed and claimed, waiting for cooldown
                         buttonText = 'Claimed'; // Or show cooldown timer again if needed
                         buttonClass = 'claimed-button';
                         buttonStyle = 'background: #ccc; cursor: default;';
                         buttonDisabled = true;
                    }
                     else { // Not completed
                        buttonText = questAction; // 'Watch Ad' or 'GO'
                        buttonClass = 'go-button';
                        buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);'; // Go style
                        buttonDisabled = false;
                    }
                } else { // Default quest type (e.g., visit link, join channel)
                    const isClaimed = userData.claimedQuests.includes(questId);
                    if (isClaimed) {
                        buttonText = 'Claimed';
                        buttonClass = 'claimed-button';
                        buttonStyle = 'background: #ccc; cursor: default;';
                        buttonDisabled = true;
                    } else {
                         buttonText = questAction; // 'GO', 'Join', etc.
                         buttonClass = 'go-button';
                         buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);'; // Go style
                         buttonDisabled = false;
                    }
                }

                return `
                    <li class="quest-item" data-quest-id="${questId}" data-quest-type="${questType}" data-ad-limit="${adLimit}" data-ad-type="${adType}">
                        <img src="${questIcon}" alt="${questTitle}" onerror="this.src='assets/icons/quest_placeholder.png'">
                        <span>${questTitle}</span>
                        <div class="quest-reward">
                            <img src="assets/icons/gem.png" alt="Gem">
                            <span>+${questReward.toLocaleString()}</span>
                            ${progressText}
                            <button class="${buttonClass}"
                                    data-quest-link="${questLink}"
                                    data-quest-reward="${questReward}"
                                    style="${buttonStyle}"
                                    ${buttonDisabled ? 'disabled' : ''}>
                                ${buttonText}
                            </button>
                        </div>
                    </li>
                `;
            }).join('');
        }
        debugLog("[QUEST DEBUG] Basic quests rendered.");

    } catch (error) {
        console.error("[QUEST ERROR] Failed to update Earn section UI:", error);
        debugLog(`[QUEST ERROR] Failed to update Earn section UI: ${error.message}\n${error.stack}`);
        // Display error messages in the UI
        dailyQuestList.innerHTML = `<li class="error"><p>Failed to load daily quests. Please try again later.</p></li>`;
        basicQuestList.innerHTML = `<li class="error"><p>Failed to load basic quests. Please try again later.</p></li>`;
        dailyQuestCountEl.textContent = 'ERR';
        basicQuestCountEl.textContent = 'ERR';
    }
}


// --- Quest Interaction Logic ---
async function handleQuestClick(button) {
    const taskItem = button.closest('.quest-item');
    if (!taskItem) return;

    const questId = taskItem.dataset.questId;
    const questType = taskItem.dataset.questType;
    const reward = parseInt(button.dataset.questReward || '0');
    const link = button.dataset.questLink || '';
    const adLimit = parseInt(taskItem.dataset.adLimit || '0');
    const adType = taskItem.dataset.adType || 'rewarded_interstitial';

    debugLog(`[QUEST ACTION] Button clicked for quest: ${questId}`, { type: questType, reward, link: link || 'N/A', adLimit, adType });

    if (!firebaseInitialized || !db || !window.telegramUser || !window.telegramUser.id) {
        alert("Initialization error or user not identified. Please reload.");
        debugLog("[QUEST ACTION ERROR] Firestore or User not ready.");
        return;
     }

    const userDocRef = db.collection('userData').doc(window.telegramUser.id.toString());
    // --- IMPORTANT: Fetch latest user data *before* processing the click ---
    let userData = await window.fetchAndUpdateUserData(); // Use window prefix
    if (!userData) {
        alert("Could not load your data. Please try again.");
        debugLog("[QUEST ACTION ERROR] Failed to fetch user data before action.");
        return;
    }
    // Ensure sub-objects exist after fetching
    userData.adProgress = userData.adProgress || {};
    userData.claimedQuests = userData.claimedQuests || [];


    // --- Handle CLAIM button clicks (specifically for completed ad quests) ---
    if (button.classList.contains('claim-button') && questType === 'ads') {
        debugLog(`[QUEST ACTION] Handling CLAIM for ad quest: ${questId}`);
        const adProgress = userData.adProgress[questId] || { watched: 0, claimed: false, lastClaimed: null };

        if (adProgress.watched < adLimit) {
            debugLog(`[QUEST ACTION WARN] Claim clicked but not enough ads watched for ${questId} (${adProgress.watched}/${adLimit})`);
            alert("Please watch the required number of ads first.");
            return; // Should not happen if UI is correct, but safety check
        }
        if (adProgress.claimed) {
            debugLog(`[QUEST ACTION WARN] Claim clicked but already claimed for ${questId}`);
            // UI should prevent this, but log it.
            return;
        }

        button.disabled = true; button.textContent = 'Claiming...';
        try {
            const currentTimeISO = new Date().toISOString();
            await userDocRef.update({
                gems: firebase.firestore.FieldValue.increment(reward), // Use firebase global
                [`adProgress.${questId}`]: { // Update the specific ad progress object
                    watched: adProgress.watched, // Keep watched count
                    claimed: true,
                    lastClaimed: currentTimeISO // Record claim time for cooldown
                 }
            });
            debugLog(`[QUEST ACTION] Ad quest ${questId} claimed successfully. Awarded ${reward} gems.`);
            if (window.analytics) window.analytics.logEvent('ads_quest_claimed', { userId: window.telegramUser.id, questId, reward }); // Use analytics global

            alert(`Reward claimed! You earned ${reward.toLocaleString()} gems.`);

             // Fetch latest data AFTER successful claim
             await window.fetchAndUpdateUserData();
            // Update UI elements
            await window.updateUserStatsUI(); // Use window prefix
            await updateEarnSectionUI(); // Update quest list specifically

        } catch (error) {
             console.error("[QUEST ERROR] Error claiming ad reward:", error);
             debugLog(`[QUEST ERROR] Error claiming ad reward for ${questId}: ${error.message}`);
             alert("Failed to claim reward. Please try again.");
             // Re-enable button ONLY if the error occurred, UI update will handle correct state on success
             button.disabled = false; button.textContent = 'Claim';
        }
    }
    // --- Handle GO button clicks ---
    else if (button.classList.contains('go-button')) {
        debugLog(`[QUEST ACTION] Handling GO for quest: ${questId}`);

        // --- GO for Ad Quests (Manual Trigger) ---
        if (questType === 'ads') {
            const adProgress = userData.adProgress[questId] || { watched: 0, claimed: false, lastClaimed: null };
            if (adProgress.watched >= adLimit) {
                debugLog(`[QUEST ACTION] Ad quest ${questId} already completed (${adProgress.watched}/${adLimit}). Ignoring GO click.`);
                alert("You have already watched the required ads. Click 'Claim' if available.");
                return;
             }
            if (adProgress.claimed) {
                 // If claimed, check cooldown (though button should be disabled by UI update)
                 const lastClaimedTime = adProgress.lastClaimed ? new Date(adProgress.lastClaimed) : null;
                 const timeSinceLastClaim = lastClaimedTime ? (new Date() - lastClaimedTime) : Infinity;
                 if (timeSinceLastClaim < AD_QUEST_COOLDOWN_MS) {
                     const timeLeftMinutes = Math.max(1, Math.ceil((AD_QUEST_COOLDOWN_MS - timeSinceLastClaim) / 60000));
                    alert(`Quest is on cooldown. Please wait ${timeLeftMinutes}m.`);
                    debugLog(`[QUEST ACTION] Ad quest ${questId} on cooldown. Ignoring GO click.`);
                    return;
                 } else {
                    // Cooldown finished, but somehow button didn't reset? Log warning.
                     debugLog(`[QUEST ACTION WARN] Cooldown finished for ${questId}, but GO button was clicked. UI might be out of sync.`);
                     // Proceed to show ad as if reset occurred
                 }
            }

            // Check if the adType is 'inApp' - handled automatically, reject manual trigger
            if (adType === 'inApp') {
                debugLog("[QUEST ACTION] Manual trigger attempted for 'inApp' ad type. This type is automatic.");
                alert("This ad reward is handled automatically as you use the app.");
                return; // Prevent manual trigger
            }

            debugLog(`[QUEST ACTION] Attempting to show ad (${adType}) for quest: ${questId}`);
            button.disabled = true; button.textContent = 'Loading Ad...';

            try {
                await window.showAd(adType); // Use adService function (window prefix)
                debugLog(`[QUEST ACTION] Ad shown successfully (or closed/skipped) for quest: ${questId}`);

                // --- IMPORTANT: Re-fetch user data *after* ad interaction, *before* update ---
                const userDataAfterAd = await window.fetchAndUpdateUserData(); // Use window prefix
                if (!userDataAfterAd) throw new Error("User data disappeared after ad.");

                // Use the LATEST known progress before applying the increment
                const currentAdProgress = userDataAfterAd.adProgress?.[questId] || { watched: 0, claimed: false, lastClaimed: null };
                const newWatchedCount = currentAdProgress.watched + 1;

                // --- Update Firestore ---
                await userDocRef.update({
                    [`adProgress.${questId}.watched`]: firebase.firestore.FieldValue.increment(1) // More atomic update for watched count
                    // Only update watched count here. Claim status/time handled by CLAIM action.
                });
                debugLog(`[QUEST ACTION] Ad progress updated in Firestore for ${questId}: ${newWatchedCount}/${adLimit}`);

                 // *** Refresh the local cache AFTER the successful update ***
                 await window.fetchAndUpdateUserData(); // Use window prefix
                 debugLog(`[QUEST ACTION] Refreshed local user data cache after Firestore update.`);

                if (window.analytics) window.analytics.logEvent('ads_quest_watch', { userId: window.telegramUser.id, questId, adType }); // Use analytics global

                // Show alert based on the new count
                if (newWatchedCount >= adLimit) {
                    alert(`Ad watched! (${newWatchedCount}/${adLimit}) You can now claim your reward.`);
                } else {
                    alert(`Ad watched! Progress: ${newWatchedCount}/${adLimit}`);
                }

                // --- Update UI (Now uses the refreshed cache) ---
                await updateEarnSectionUI(); // Refresh quest list

            } catch (error) {
                console.error("[QUEST ERROR] Failed to show ad or update progress:", error);
                debugLog(`[QUEST ERROR] Failed showing ad/updating progress for ${questId}: ${error.message}`);
                 // Check if the error message indicates ad not available vs user closed early
                 if (error.message.includes("closed early")) {
                     alert("Ad skipped or closed early. Progress not updated.");
                 } else {
                    alert(`Failed to show ad: ${error.message || 'Unknown error'}. Please try again.`); // Show specific error if possible
                 }
                 // Refresh UI to reset button state regardless of error type
                await updateEarnSectionUI();
            }
             // No finally needed as updateEarnSectionUI is called in both try and catch paths after ad attempt
        }
        // --- GO for Daily/Default Link Quests ---
        else { // questType is 'daily' or 'default'
            if (userData.claimedQuests.includes(questId)) {
                debugLog(`[QUEST ACTION WARN] GO clicked but default quest ${questId} already claimed.`);
                 // UI should prevent this
                return;
             }
            if (!link) {
                alert("No link associated with this quest.");
                debugLog(`[QUEST ACTION WARN] GO clicked for ${questId} but no link found.`);
                return;
             }

            debugLog(`[QUEST ACTION] Processing link/action for quest ${questId}: ${link}`);
            button.disabled = true; button.textContent = 'Processing...';
            try {
                await userDocRef.update({
                    gems: firebase.firestore.FieldValue.increment(reward), // Use firebase global
                    claimedQuests: firebase.firestore.FieldValue.arrayUnion(questId) // Use firebase global
                });
                debugLog(`[QUEST ACTION] Default/Daily quest ${questId} marked complete. Awarded ${reward} gems.`);
                if (window.analytics) window.analytics.logEvent('quest_completed', { userId: window.telegramUser.id, questId, reward }); // Use analytics global

                 // Open the link AFTER successfully updating the database
                 openTelegramLink(link); // Use telegramService function

                alert(`Quest completed! You earned ${reward.toLocaleString()} gems.`);

                // Refresh data and UI
                await window.fetchAndUpdateUserData(); // Use window prefix
                await window.updateUserStatsUI(); // Use window prefix
                await updateEarnSectionUI(); // Update quest list

            } catch (error) {
                console.error("[QUEST ERROR] Error completing default/daily quest:", error);
                debugLog(`[QUEST ERROR] Error completing quest ${questId}: ${error.message}`);
                alert("Failed to complete quest. Please try again.");
                // Re-enable button only on failure
                button.disabled = false; button.textContent = questAction; // Reset to original action text
            }
        }
    }
    // Ignore clicks on 'Claimed' or disabled/waiting buttons silently
    else if (button.classList.contains('claimed-button') || button.disabled) {
        debugLog(`[QUEST ACTION] Click ignored on disabled/claimed button for quest: ${questId}`);
    }
}



// js/sections/invite.js

function generateReferralLink() {
    debugLog("Generating referral link...");
    // Needs global telegramUser
    if (!window.telegramUser || !window.telegramUser.id) {
         debugLog("Referral link generation skipped: No user ID.");
         return null; // Return null if no link generated
    }
    // Use constant from config.js
    const referralLink = `https://t.me/${REFERRAL_BOT_USERNAME}?start=ref_${window.telegramUser.id}`;
    debugLog("Referral link generated:", referralLink);
    return referralLink;
}

async function handleReferral() {
     debugLog("Checking for referral parameter...");
    // Needs globals telegramUser, firebaseInitialized, db
     if (!window.telegramUser || !window.telegramUser.id || !firebaseInitialized || !db) {
        debugLog("Referral check skipped: Conditions not met.");
        return;
     }

     const startParam = getTelegramStartParam(); // Use telegramService function

     if (startParam && startParam.startsWith('ref_')) {
         const referrerId = startParam.split('_')[1];
         const currentUserId = window.telegramUser.id.toString();
         debugLog(`Referral parameter found: ref_${referrerId}`);

         if (!referrerId || referrerId === currentUserId) {
            debugLog("Referral check skipped: Invalid or self-referral ID.");
            return;
         }

         const currentUserRef = db.collection('userData').doc(currentUserId);
         const referrerRef = db.collection('userData').doc(referrerId);

         try {
              // Use a transaction to ensure atomicity when updating both users
              await db.runTransaction(async (transaction) => {
                  const userDoc = await transaction.get(currentUserRef);
                   if (!userDoc.exists) {
                       // This should ideally not happen if initializeUserData runs first,
                       // but handle defensively. Wait for user data to be created.
                       throw new Error("Current user data not found yet. Cannot process referral.");
                   }
                  const userData = userDoc.data();

                  // Check if already referred
                  if (userData.isReferred) {
                      debugLog(`User ${currentUserId} already referred by ${userData.referredBy || 'someone'}. Skipping.`);
                      return; // Exit transaction without changes
                  }

                  debugLog(`Processing referral: User ${currentUserId} referred by ${referrerId}`);
                   // Mark current user as referred
                   transaction.update(currentUserRef, { isReferred: true, referredBy: referrerId });

                   // Check if referrer exists before trying to update
                  const referrerDoc = await transaction.get(referrerRef);
                   if (referrerDoc.exists) {
                        const referralCreditAmount = REFERRAL_CREDIT_AMOUNT; // Use constant from config.js

                        const newRecord = {
                            userId: currentUserId,
                            username: window.telegramUser.username || window.telegramUser.first_name || `User_${currentUserId.slice(-4)}`,
                            joinTime: new Date().toISOString(), // Use ISO string for consistency
                            creditAwarded: referralCreditAmount,
                        };

                        // Update referrer's data
                        transaction.update(referrerRef, {
                            referrals: firebase.firestore.FieldValue.increment(1), // Use firebase global
                            referralCredits: firebase.firestore.FieldValue.increment(referralCreditAmount),
                            inviteRecords: firebase.firestore.FieldValue.arrayUnion(newRecord)
                        });
                        debugLog(`Referrer ${referrerId} data prepared for update: +1 referral, +${referralCreditAmount} credits.`);
                   } else {
                       debugLog(`Referral handling warning: Referrer ${referrerId} document not found. Cannot award credits.`);
                       // Continue transaction to mark the current user as referred anyway
                   }
              });

             debugLog("Referral transaction completed successfully.");
             if (window.analytics) window.analytics.logEvent('referral_success', { userId: currentUserId, referrerId }); // Use analytics global
             // Refresh user data after successful referral processing
             await window.fetchAndUpdateUserData(); // Use window prefix

         } catch (error) {
             console.error("Error processing referral transaction:", error);
             debugLog(`Error processing referral: ${error.message}`);
             // Don't alert the user unless critical, log the error.
         }
     } else {
         debugLog("No referral parameter found or not in 'ref_' format.");
     }
 }

async function updateInviteSectionUI() {
    debugLog("Updating Invite section UI...");
     const myInviteEl = document.getElementById('my-invite');
     const totalCreditTextEl = document.getElementById('total-credit-text'); // Element containing the text part
     const totalCreditInfoEl = document.querySelector('.total-credit .credit-info'); // Parent div for structure check
     const inviteRecordTitleEl = document.getElementById('invite-record-title');
     const recordListContainer = document.getElementById('invite-record-list');
     const invitePlaceholder = document.getElementById('invite-record-placeholder');
     const claimRecordListContainer = document.getElementById('claim-record-list');
     const claimPlaceholder = document.getElementById('claim-record-placeholder');
     const claimButton = document.querySelector('.invite-section .claim-button'); // Get claim button

     // Basic element checks
     if (!myInviteEl || !totalCreditTextEl || !totalCreditInfoEl || !inviteRecordTitleEl || !recordListContainer || !invitePlaceholder || !claimRecordListContainer || !claimPlaceholder || !claimButton) {
        console.error("[INVITE UI ERROR] Required DOM elements for invite section not found!");
        debugLog("[INVITE UI ERROR] Invite section elements missing from DOM.");
        return;
     }

     // Set loading state
     myInviteEl.textContent = `My Invite: ...`;
     // Use textContent for the span, keep structure
     totalCreditTextEl.textContent = `Total Credit ! : ...`;
     totalCreditInfoEl.querySelector('small').innerHTML = `Loading...`; // Clear rate display
     inviteRecordTitleEl.textContent = `Invite Record (...)`;
     recordListContainer.innerHTML = ''; // Clear previous list
     invitePlaceholder.style.display = 'block';
     invitePlaceholder.querySelector('p').textContent = 'Loading invites...';
     claimRecordListContainer.innerHTML = ''; // Clear previous list
     claimPlaceholder.style.display = 'block';
     claimPlaceholder.querySelector('p').textContent = 'Loading claim history...';
     claimButton.disabled = true; // Disable claim button while loading


     // Use cached or fetch fresh user data
     // Needs globals currentUserData, fetchAndUpdateUserData
     const data = window.currentUserData || await window.fetchAndUpdateUserData();

     if (!data) {
         debugLog("Invite UI update: User data not found.");
         // Show appropriate message
         myInviteEl.textContent = `My Invite: 0`;
         totalCreditTextEl.textContent = `Total Credit ! : 0`;
         totalCreditInfoEl.querySelector('small').innerHTML = `${CREDIT_CONVERSION_RATE.toLocaleString()} C = 1 <img src="assets/icons/usdt.png" alt="USDT">`; // Show rate
         inviteRecordTitleEl.textContent = `Invite Record (0)`;
         invitePlaceholder.style.display = 'block';
         invitePlaceholder.querySelector('p').textContent = 'No invites yet';
         claimPlaceholder.style.display = 'block';
         claimPlaceholder.querySelector('p').textContent = 'No claim records yet';
         claimButton.disabled = true; // Still disabled if no data
         return;
     }

     const referrals = data.referrals || 0;
     const totalCredit = data.referralCredits || 0;
     const inviteRecords = data.inviteRecords || [];
     const claimHistory = data.claimHistory || [];

     // Update stats
     myInviteEl.textContent = `My Invite: ${referrals}`;
     totalCreditTextEl.textContent = `Total Credit ! : ${totalCredit.toLocaleString()}`;
     // Update conversion rate display
     totalCreditInfoEl.querySelector('small').innerHTML = `${CREDIT_CONVERSION_RATE.toLocaleString()} C = 1 <img src="assets/icons/usdt.png" alt="USDT">`;


     inviteRecordTitleEl.textContent = `Invite Record (${referrals})`;

     // Populate Invite Records
     if (inviteRecords.length === 0) {
         recordListContainer.innerHTML = ''; // Ensure it's empty
         invitePlaceholder.style.display = 'block';
         invitePlaceholder.querySelector('p').textContent = 'No invites yet';
     } else {
         invitePlaceholder.style.display = 'none';
         recordListContainer.innerHTML = inviteRecords
             // Sort by date (descending) - ensure joinTime is valid Date parsable string (ISO format recommended)
             .sort((a, b) => new Date(b.joinTime || 0) - new Date(a.joinTime || 0))
             .map(record => {
                 const joinTime = formatTimestamp(record.joinTime); // Use utility
                 const username = record.username || 'Unknown User';
                 // Basic avatar placeholder generation
                 const avatarLetter = (username === 'Unknown User' ? '?' : username[0]).toUpperCase();
                 const avatarUrl = `https://via.placeholder.com/40/808080/FFFFFF?text=${avatarLetter}`;

                 return `
                 <div class="record-item">
                     <img src="${avatarUrl}" alt="${username}">
                     <div class="user-info">
                         <span>${username}</span>
                         <small>${joinTime}</small>
                     </div>
                     <span class="credit">+${record.creditAwarded || 0} C</span> </div>
             `;
             }).join('');
     }

     // Populate Claim Records
     if (claimHistory.length === 0) {
         claimRecordListContainer.innerHTML = ''; // Ensure it's empty
         claimPlaceholder.style.display = 'block';
         claimPlaceholder.querySelector('p').textContent = 'No claim records yet';
     } else {
         claimPlaceholder.style.display = 'none';
         claimRecordListContainer.innerHTML = claimHistory
             // Sort by date (descending) - ensure claimTime is valid
             .sort((a, b) => new Date(b.claimTime || 0) - new Date(a.claimTime || 0))
             .map(record => {
                const claimTime = formatTimestamp(record.claimTime); // Use utility
                 return `
                 <div class="record-item">
                     <img src="assets/icons/usdt.png" alt="USDT Claim" style="border-radius: 0;">
                     <div class="user-info">
                         <span>Claimed ${record.usdtAmount?.toFixed(4) || '?'} USDT</span>
                         <small>${claimTime}</small>
                     </div>
                     <span class="credit" style="background: #00cc00;">-${record.creditsSpent?.toLocaleString() || '?'} C</span>
                 </div>
             `;
             }).join('');
     }

     // Enable/Disable Claim Button based on available credits
     claimButton.disabled = totalCredit < MINIMUM_CREDIT_CLAIM; // Use constant

     debugLog("Invite section UI updated successfully.");

 }

 // --- Event Listener Setup for Invite Section (called from main.js) ---
 function initInviteSectionListeners() {
     const inviteButton = document.querySelector('.invite-friend');
     const copyButton = document.querySelector('.copy-link');
     const claimButton = document.querySelector('.invite-section .claim-button');

     if (inviteButton) {
         inviteButton.addEventListener('click', () => {
             const link = generateReferralLink(); // Generate fresh link
             if (link) {
                openTelegramLink(link); // Use telegramService function
                debugLog("Opened Telegram invite link.");
                if (window.analytics) window.analytics.logEvent('invite_friend_share', { userId: window.telegramUser?.id, method: 'telegram' });
             } else {
                 alert("Could not generate referral link.");
             }
         });
     }

     if (copyButton) {
         copyButton.addEventListener('click', () => {
             const link = generateReferralLink(); // Generate fresh link
             if (link && navigator.clipboard) {
                 navigator.clipboard.writeText(link)
                     .then(() => {
                         alert("Referral link copied!");
                         debugLog("Referral link copied to clipboard.");
                         if (window.analytics) window.analytics.logEvent('invite_friend_share', { userId: window.telegramUser?.id, method: 'copy' });
                     })
                     .catch(err => {
                         console.error("Failed to copy link:", err);
                         alert("Failed to copy link. Please try again.");
                     });
             } else if (link) {
                  alert("Clipboard access not available. Please copy the link manually."); // Fallback for older browsers/http
             }
              else {
                 alert("Could not generate referral link.");
             }
         });
     }

     if (claimButton) {
         claimButton.addEventListener('click', handleClaimCredits); // Assign handler
     }
 }

 // --- Claim Credits Logic ---
 async function handleClaimCredits() {
     debugLog("[CREDIT CLAIM] Claim button clicked.");
     // Needs globals telegramUser, db, firebase, analytics
     if (!window.telegramUser || !window.telegramUser.id || !db || !firebase) {
        alert("Initialization error. Please reload.");
        return;
     }

     const claimButton = document.querySelector('.invite-section .claim-button');
     if (!claimButton || claimButton.disabled) return; // Exit if button doesn't exist or is disabled

     claimButton.disabled = true; claimButton.textContent = 'Checking...';

     const userDocRef = db.collection('userData').doc(window.telegramUser.id.toString());
     try {
         // --- Use a Transaction for Claiming ---
         const usdtToClaim = await db.runTransaction(async (transaction) => {
             const userDoc = await transaction.get(userDocRef);
             if (!userDoc.exists) throw new Error("User data not found for claim.");

             const data = userDoc.data();
             const currentCredits = data.referralCredits || 0;
             const conversionRate = CREDIT_CONVERSION_RATE; // Use constants from config.js
             const minimumClaim = MINIMUM_CREDIT_CLAIM;

             debugLog(`[CREDIT CLAIM] Current credits: ${currentCredits}`);
             if (currentCredits < minimumClaim) {
                 throw new Error(`Insufficient credits. Need ${minimumClaim.toLocaleString()}, have ${currentCredits.toLocaleString()}.`);
             }

             const calculatedUsdtToClaim = Math.floor(currentCredits / conversionRate);
             const creditsToSpend = calculatedUsdtToClaim * conversionRate;

             debugLog(`[CREDIT CLAIM] Attempting to claim ${calculatedUsdtToClaim} USDT for ${creditsToSpend} credits.`);
             claimButton.textContent = 'Claiming...'; // Update button text

             const claimRecord = {
                 claimTime: new Date().toISOString(), // Use ISO string
                 usdtAmount: calculatedUsdtToClaim,
                 creditsSpent: creditsToSpend,
                 rate: conversionRate
             };

             // Prepare updates for the transaction
             transaction.update(userDocRef, {
                 usdt: firebase.firestore.FieldValue.increment(calculatedUsdtToClaim),
                 referralCredits: firebase.firestore.FieldValue.increment(-creditsToSpend),
                 claimHistory: firebase.firestore.FieldValue.arrayUnion(claimRecord)
             });

             return calculatedUsdtToClaim; // Return the amount claimed for logging/alert
         });
         // --- Transaction End ---

         debugLog(`[CREDIT CLAIM] Successfully claimed ${usdtToClaim} USDT.`);
         if (window.analytics) window.analytics.logEvent('credit_claim', { userId: window.telegramUser.id, usdt: usdtToClaim });
         alert(`Successfully claimed ${usdtToClaim.toFixed(4)} USDT!`);

         // Update UI immediately after successful transaction
         await window.fetchAndUpdateUserData(); // Refresh cache
         await window.updateUserStatsUI();
         await updateInviteSectionUI(); // Update invite section specific elements

     } catch (error) {
         console.error("[CREDIT CLAIM ERROR] Error claiming credits:", error);
         debugLog(`[CREDIT CLAIM ERROR] ${error.message}`);
         alert(`Failed to claim credits: ${error.message}`); // Show specific error to user
         // Re-enable button and update UI on failure
         await updateInviteSectionUI(); // Ensure UI reflects correct state after error
     }
     // No finally needed, UI update handles button state
 }


// js/sections/top.js

async function updateTopSectionUI() {
     debugLog("Updating Top section UI (Ranking)...");
    const rankingList = document.getElementById('ranking-list');
     if (!rankingList) {
        debugLog("[RANKING UI ERROR] Ranking list element not found.");
        return;
    }
     rankingList.innerHTML = `<li class="loading"><p>Loading rankings...</p></li>`;

     // Needs globals firebaseInitialized, db
     if (!firebaseInitialized || !db) {
        rankingList.innerHTML = `<li class="error"><p>Database connection not ready.</p></li>`;
        return;
     }

     try {
         const rankingsSnapshot = await db.collection('users') // Ensure this collection name is correct
             .orderBy('foxMedals', 'desc')
             .limit(30) // Fetch top 30
             .get();

         const rankings = [];
         rankingsSnapshot.forEach(doc => {
             const data = doc.data();
             // Basic validation of data
             if (data && data.foxMedals !== undefined) {
                 rankings.push({
                     id: doc.id,
                     username: data.username || 'Anonymous',
                     foxMedals: data.foxMedals || 0,
                     photoUrl: data.photoUrl || 'assets/icons/user-avatar.png'
                 });
             } else {
                 console.warn("Skipping invalid ranking entry:", doc.id, data);
             }
         });
         debugLog(`Workspaceed ${rankings.length} valid ranking entries.`);

         if (rankings.length === 0) {
             rankingList.innerHTML = `<li class="no-rankings"><p>The ranking is empty right now.</p></li>`;
         } else {
             rankingList.innerHTML = rankings.map((user, index) => {
                 const rank = index + 1;
                 const avatarUrl = user.photoUrl || 'assets/icons/user-avatar.png';
                 // Simple medal display logic
                 let rankDisplay = `${rank}.`;
                 if (rank === 1) rankDisplay = 'ðŸ¥‡';
                 else if (rank === 2) rankDisplay = 'ðŸ¥ˆ';
                 else if (rank === 3) rankDisplay = 'ðŸ¥‰';

                 return `
                 <li class="ranking-item" data-user-id="${user.id}">
                     <span class="rank-number" style="margin-right: 10px; font-weight: bold; width: 30px; text-align: center;">${rankDisplay}</span>
                     <img src="${avatarUrl}" alt="${user.username}" onerror="this.src='assets/icons/user-avatar.png'">
                     <span class="rank-username" style="flex-grow: 1; margin-left: 5px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${user.username}</span>
                     <div class="medal-count">
                         <span>${user.foxMedals.toLocaleString()}</span>
                         <img src="assets/icons/fox-medal.png" alt="Fox Medal">
                     </div>
                 </li>
             `;
             }).join('');
         }
         debugLog("Top section UI updated successfully.");
     } catch (error) {
         console.error("Error updating top section UI:", error);
         debugLog(`Error updating ranking UI: ${error.message}`);
         rankingList.innerHTML = `<li class="error"><p>Failed to load rankings. Please try again.</p></li>`;
     }
 }


// js/adService.js

const AD_SDK_FUNCTION_NAME = 'show_9180370'; // Make configurable if needed

// Function to show ads (Rewarded Interstitial, Pop, etc.)
function showAd(adType = 'rewarded_interstitial') {
    debugLog(`[AD] Attempting to show ad of type: ${adType} via manual trigger.`);
    return new Promise((resolve, reject) => {

        // Reject manual 'inApp' triggers - these are initialized separately
        if (adType === 'inApp') {
            const errorMsg = "In-App ads are shown automatically, not via manual quest trigger.";
            debugLog(`[AD WARN] ${errorMsg}`);
            return reject(new Error(errorMsg));
        }

        const maxWaitTime = 30000; // 30 seconds timeout

        // Check if SDK function exists
        if (typeof window[AD_SDK_FUNCTION_NAME] !== 'function') {
            const errorMsg = `Monetag SDK function '${AD_SDK_FUNCTION_NAME}' not found.`;
            console.warn(`[AD WARN] ${errorMsg} Simulating ad success after delay.`);
            debugLog(`[AD WARN] ${errorMsg} Simulating success.`);
            setTimeout(() => {
                debugLog("[AD] Simulated ad finished.");
                resolve(); // Simulate success for development/testing
            }, 3000);
            // For production, you might want to reject instead:
            // reject(new Error(errorMsg));
            return;
        }

        let adPromise = null;
        let adTriggered = false;
        let requiresPromiseHandling = false; // Does the SDK call return a promise?

        // Cleanup function
        const cleanup = (timeoutHandle, success, error = null) => {
            clearTimeout(timeoutHandle);
            if (success) {
                resolve();
            } else {
                const defaultError = new Error(`Ad failed, timed out, or was closed early (${adType})`);
                reject(error || defaultError);
            }
        };

        // Timeout Logic
        const timeoutId = setTimeout(() => {
            console.warn(`[AD WARN] Ad timed out after ${maxWaitTime / 1000}s (${adType}). Rejecting.`);
            debugLog(`[AD WARN] Ad timed out: ${adType}`);
            cleanup(timeoutId, false, new Error(`Ad timed out (${adType})`));
        }, maxWaitTime);

        try {
            debugLog(`[AD] Calling Monetag SDK (${AD_SDK_FUNCTION_NAME}) for ad type: ${adType}`);

            // Trigger Ad Based on Type
            if (adType === 'rewarded_popup') {
                adPromise = window[AD_SDK_FUNCTION_NAME]('pop'); // Example for popup
                adTriggered = true;
                requiresPromiseHandling = true; // Assume pop returns a promise
            } else if (adType === 'rewarded_interstitial') {
                adPromise = window[AD_SDK_FUNCTION_NAME](); // Default call might be interstitial
                adTriggered = true;
                requiresPromiseHandling = true; // Assume default returns a promise
            }
            // Add other adType mappings if needed based on Monetag SDK docs
            else {
                console.warn(`[AD WARN] Unsupported or unknown adType: ${adType} for manual trigger. Falling back to standard interstitial.`);
                 adPromise = window[AD_SDK_FUNCTION_NAME](); // Fallback
                 adTriggered = true;
                 requiresPromiseHandling = true;
            }

            // Handle Promise (if applicable)
            if (requiresPromiseHandling && adPromise && typeof adPromise.then === 'function') {
                debugLog(`[AD] SDK returned a Promise for type ${adType}. Waiting for resolution...`);
                adPromise.then(() => {
                    debugLog(`[AD] SDK Promise resolved successfully for type: ${adType}. Ad likely watched/closed.`);
                    cleanup(timeoutId, true); // Resolve the outer promise on success
                }).catch(e => {
                    const errorMsg = e?.message || e || 'Unknown SDK error';
                    console.error(`[AD ERROR] SDK Promise rejected for type ${adType}:`, errorMsg);
                    debugLog(`[AD ERROR] SDK Promise rejected for ${adType}: ${errorMsg}`);
                    cleanup(timeoutId, false, new Error(`Ad failed or was closed early (${adType}): ${errorMsg}`)); // Reject the outer promise on failure
                });
            } else if (adTriggered && requiresPromiseHandling) {
                 // Safety net if adPromise wasn't a promise but was expected to be
                 console.warn(`[AD WARN] SDK call for ${adType} was triggered but did not return a standard promise. Relying on timeout/callbacks if any.`);
                 // If the SDK uses callbacks instead, that logic needs to be integrated here.
                 // For now, we rely on the timeout as the primary completion mechanism if no promise.
            } else if (!adTriggered) {
                // Should not happen if adType mapping is correct
                cleanup(timeoutId, false, new Error(`Could not trigger ad for type ${adType}`));
            }

        } catch (error) {
            // Catch immediate errors from calling the SDK function itself
            console.error("[AD ERROR] Failed to trigger Monetag ad:", error);
            debugLog(`[AD ERROR] Failed to trigger ad ${adType}: ${error.message}`);
            cleanup(timeoutId, false, error); // Reject the outer promise if the call fails immediately
        }
    });
}

// Function to initialize automatic In-App ads
function initializeAutomaticAds() {
    try {
        if (typeof window[AD_SDK_FUNCTION_NAME] === 'function') {
            // Define the settings for automatic display (adjust as needed)
            const autoInAppSettings = {
                frequency: 2,      // Max 2 ads per session defined by capping
                capping: 0.016,    // Session duration = 0.016 hours (~1 minute)
                interval: 30,     // Minimum 30 seconds between ads
                timeout: 5,       // 5-second delay before the *first* ad in a session might show
                everyPage: false   // Show on page load or specific triggers? Check SDK docs.
            };
            debugLog('[AD INIT] Initializing automatic In-App ads with settings:', JSON.stringify(autoInAppSettings));
            // Initialize automatic ads using the SDK function
            window[AD_SDK_FUNCTION_NAME]({ type: 'inApp', inAppSettings: autoInAppSettings });
            debugLog('[AD INIT] Automatic In-App ads initialization called.');
        } else {
            debugLog('[AD INIT WARN] Monetag SDK function not found, cannot initialize automatic ads.');
        }
    } catch (initAdError) {
        console.error('[AD INIT ERROR] Error initializing automatic In-App ads:', initAdError);
        debugLog(`[AD INIT ERROR] Error initializing automatic ads: ${initAdError.message}`);
    }
}



// js/config.js

// Firebase Configuration
const firebaseConfig = {
    apiKey: "AIzaSyCUkEmFmJK2vr8k7M6JqYaxlcgBDf7WdJI", // Consider securing this (e.g., environment variables if possible)
    authDomain: "fourgo-cd98f.firebaseapp.com",
    projectId: "fourgo-cd98f",
    storageBucket: "fourgo-cd98f.firebasestorage.app",
    messagingSenderId: "511215742272",
    appId: "1:511215742272:web:04bd85a284919ae123dea5",
    measurementId: "G-DC7E6ECF2L"
};

// Chest Data
const CHESTS_DATA = [
     { name: "Wood Chest", next: "Bronze", image: "assets/graphics/wood-chest.png", gemCost: 200, vip: 0 },
     { name: "Bronze Chest", next: "Silver", image: "assets/graphics/bronze-chest.png", gemCost: 500, vip: 1 },
     { name: "Silver Chest", next: "Gold", image: "assets/graphics/silver-chest.png", gemCost: 1000, vip: 2 },
     { name: "Gold Chest", next: "Master", image: "assets/graphics/gold-chest.png", gemCost: 2000, vip: 3 },
     { name: "Master Chest", next: "Legendary", image: "assets/graphics/master-chest.png", gemCost: 5000, vip: 4 },
     { name: "Legendary Chest", next: "Mythic", image: "assets/graphics/legendary-chest.png", gemCost: 10000, vip: 5 },
     { name: "Mythic Chest", next: "", image: "assets/graphics/mythic-chest.png", gemCost: 20000, vip: 6 }
];

// Other constants if needed
const REFERRAL_BOT_USERNAME = 'fourgobot'; // Replace with your actual bot username
const REFERRAL_CREDIT_AMOUNT = 10;
const CREDIT_CONVERSION_RATE = 10000; // 10,000 credits = 1 USDT
const MINIMUM_CREDIT_CLAIM = 10000;
const AD_QUEST_COOLDOWN_MS = 3600 * 1000; // 1 hour


// js/firebaseService.js

// Forward declare globals defined in main.js
let app, db, auth, storage, analytics;
let firebaseInitialized = false;

// Firebase SDK URLs (use versions compatible with compat libraries if needed)
const FIREBASE_SDK_URLS = [
    'https://www.gstatic.com/firebasejs/10.13.0/firebase-app-compat.js',
    'https://www.gstatic.com/firebasejs/10.13.0/firebase-auth-compat.js',
    'https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore-compat.js',
    'https://www.gstatic.com/firebasejs/10.13.0/firebase-storage-compat.js',
    'https://www.gstatic.com/firebasejs/10.13.0/firebase-analytics-compat.js'
];

// Validate Firebase Configuration
function validateFirebaseConfig(config) {
    const requiredFields = ['apiKey', 'authDomain', 'projectId', 'storageBucket', 'messagingSenderId', 'appId'];
    for (const field of requiredFields) {
        if (!config[field]) {
            throw new Error(`Firebase config is missing required field: ${field}`);
        }
    }
    debugLog("Firebase config validated successfully");
}

// --- Firebase Initialization ---
async function initializeFirebase(maxRetries = 3) {
    debugLog("Initializing Firebase...");
    if (firebaseInitialized) {
        debugLog("Firebase already initialized.");
        return true;
    }
     // Check if firebase is already globally available (e.g., if SDKs were loaded manually)
     if (window.firebase && window.firebase.apps && window.firebase.apps.length > 0 && !app) {
         debugLog("Firebase detected in global scope, attempting to reuse existing instance.");
         app = window.firebase.apps[0]; // Use the first initialized app
         try {
            // Try to get services from the existing app instance
            db = app.firestore();
            auth = app.auth();
            storage = app.storage();
            try { analytics = app.analytics(); } catch (e) { console.warn("Analytics setup failed:", e.message); }
             firebaseInitialized = true; // Mark as initialized since we got the services
             debugLog("Reused existing Firebase app instance and services.");
             return true;
         } catch (reuseError) {
             console.warn("Failed to reuse existing Firebase instance services, proceeding with initialization:", reuseError);
             // Reset app variable if reusing failed, to allow normal initialization
             app = null;
         }
     }

    let attempts = 0;
    while (attempts < maxRetries && !firebaseInitialized) {
        try {
            debugLog(`Attempt ${attempts + 1}/${maxRetries} to initialize Firebase...`);
            validateFirebaseConfig(firebaseConfig); // Use config from config.js

            // Load SDKs dynamically
            await Promise.all(FIREBASE_SDK_URLS.map(url => loadScript(url, 1))); // Use utility function

            if (typeof firebase === 'undefined' || typeof firebase.initializeApp === 'undefined') {
                 throw new Error("Firebase SDK core not loaded correctly.");
            }

            // Check if already initialized within this attempt
            if (firebase.apps.length === 0) {
                 app = firebase.initializeApp(firebaseConfig);
                 debugLog("Firebase app initialized.");
            } else {
                 app = firebase.apps[0];
                 debugLog("Reusing existing Firebase app instance.");
            }

            // Initialize services
            db = firebase.firestore();
            auth = firebase.auth();
            storage = firebase.storage();
            try { analytics = firebase.analytics(); } catch (e) { console.warn("Analytics setup failed:", e.message); }

            // Test Firestore connection (optional, but good)
            await db.collection('internal_status').doc('init_test').set({
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                status: 'ok'
            }, { merge: true });

            firebaseInitialized = true;
            debugLog("Firebase fully initialized and connected.");
            return true;
        } catch (error) {
            attempts++;
            console.error(`Firebase initialization attempt ${attempts} failed:`, error);
            debugLog(`Firebase init attempt ${attempts} failed: ${error.message}`);
            if (attempts >= maxRetries) {
                console.error("Max retries reached. Firebase initialization failed definitively.");
                debugLog("Max retries reached. Firebase initialization failed definitively.");
                alert("Error connecting to the database. Please restart the app."); // User feedback
                return false;
            }
            // Clear potentially partially loaded state if needed
            // e.g., app = null; db = null; etc.
            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait before retry
        }
    }
    return false;
}

// Helper to ensure Firebase is ready before running a callback
async function ensureFirebaseReady(callback, callbackName = 'Unnamed Callback') {
     debugLog(`Ensuring Firebase is ready for: ${callbackName}`);
    if (!firebaseInitialized || !db) {
        debugLog("Firebase not ready, attempting initialization...");
        const success = await initializeFirebase();
        if (!success) {
            console.error("Firebase initialization failed after retries. Cannot proceed.");
            debugLog(`Firebase init failed, cannot execute ${callbackName}`);
            alert("Database connection failed. Please try again later.");
            return; // Stop execution if Firebase fails
        }
    }
     debugLog(`Firebase ready, executing: ${callbackName}`);
     try {
         await callback();
         debugLog(`Successfully executed: ${callbackName}`);
     } catch (error) {
         console.error(`Error during ${callbackName}:`, error);
         debugLog(`Error during ${callbackName}: ${error.message}`);
         // Optionally show an error to the user
         // alert(`An error occurred while loading data for ${callbackName}.`);
     }
 }

// --- Storage Abstraction (Firestore) ---
const Storage = {
    getItem: async (key) => {
        // Needs global telegramUser from main.js
         debugLog(`Storage: Getting item '${key}' for user ${window.telegramUser?.id}`);
        if (!firebaseInitialized || !db) {
            console.error("Firestore not initialized. Cannot fetch item:", key);
            debugLog(`Storage Error: Firestore not init for getItem '${key}'`);
            return null;
        }
        if (!window.telegramUser || !window.telegramUser.id) {
            console.error("User not identified. Cannot fetch item:", key);
            debugLog(`Storage Error: User not identified for getItem '${key}'`);
            return null;
        }
        try {
            const docRef = db.collection('userData').doc(window.telegramUser.id.toString());
            const doc = await docRef.get();
            const value = doc.exists ? doc.data()[key] : null;
             debugLog(`Storage: Got item '${key}', value:`, value);
             return value;
        } catch (error) {
            console.error(`Storage: Error fetching ${key}:`, error);
            debugLog(`Storage Error: Failed fetching '${key}': ${error.message}`);
            return null;
        }
    },
    setItem: async (key, value) => {
        // Needs global telegramUser from main.js
         debugLog(`Storage: Setting item '${key}' for user ${window.telegramUser?.id}`, value);
        if (!firebaseInitialized || !db) {
            console.error("Firestore not initialized. Cannot set item:", key);
            debugLog(`Storage Error: Firestore not init for setItem '${key}'`);
            return false;
        }
         if (!window.telegramUser || !window.telegramUser.id) {
            console.error("User not identified. Cannot set item:", key);
             debugLog(`Storage Error: User not identified for setItem '${key}'`);
             return false;
         }
        try {
            const docRef = db.collection('userData').doc(window.telegramUser.id.toString());
            await docRef.set({ [key]: value }, { merge: true });
             debugLog(`Storage: Set item '${key}' successfully.`);
            return true;
        } catch (error) {
            console.error(`Storage: Error setting ${key}:`, error);
            debugLog(`Storage Error: Failed setting '${key}': ${error.message}`);
            return false;
        }
    }
};


// js/navigation.js

function setupNavigation() {
    debugLog('[NAV] Setting up navigation...');
    const sections = document.querySelectorAll('.main-content .section'); // Be more specific
    const navButtons = document.querySelectorAll('nav.bottom-nav .nav-button');
    const bottomNav = document.querySelector('nav.bottom-nav');

    if (!bottomNav || sections.length === 0 || navButtons.length === 0) {
        console.error('[NAV ERROR] Required navigation elements not found!');
        debugLog('[NAV ERROR] Required navigation elements not found!');
        alert("UI Error: Navigation could not be set up.");
        return;
    }

     debugLog(`[NAV] Found ${sections.length} sections and ${navButtons.length} nav buttons.`);

     // Ensure nav is visible (redundant with !important styles, but safe)
     bottomNav.style.display = 'flex'; // Use 'flex' as per CSS
     bottomNav.style.visibility = 'visible';
     bottomNav.style.opacity = '1';

    navButtons.forEach((button, index) => {
        const sectionId = button.getAttribute('data-section');
         debugLog(`[NAV] Setting up listener for button ${index}: ${sectionId}`);
         if (!sectionId) {
             console.warn(`[NAV WARN] Button ${index} is missing data-section attribute.`);
             debugLog(`[NAV WARN] Button ${index} is missing data-section attribute.`);
             return; // Skip buttons without data-section
         }

        button.addEventListener('click', () => {
            debugLog(`[NAV] Click detected on button: ${sectionId}`);
            switchSection(sectionId); // Switch section on click
        });

         // Optional: Force visual styles again just in case
         button.style.visibility = 'visible';
         button.style.opacity = '1';
         const img = button.querySelector('img');
         if (img) img.onerror = () => {
            console.error(`[NAV ERROR] Image failed to load for button ${sectionId}: ${img.src}`);
            img.src='assets/icons/placeholder.png'; // Fallback placeholder
         };
    });

    // Set default section
    const defaultSection = 'earn'; // Or read from localStorage/hash
    debugLog(`[NAV] Setting default section to: ${defaultSection}`);
    switchSection(defaultSection, true); // Pass true for initial load

    debugLog('[NAV] Navigation setup complete.');
}

async function switchSection(sectionId, isInitialLoad = false) {
     debugLog(`[NAV] Attempting to switch to section: ${sectionId}`);
    const sections = document.querySelectorAll('.main-content .section');
    const navButtons = document.querySelectorAll('nav.bottom-nav .nav-button');

    let foundSection = false;
    sections.forEach(section => {
        if (section.id === sectionId) {
             if (!section.classList.contains('active')) {
                  section.classList.add('active');
                  debugLog(`[NAV] Activated section element: #${section.id}`);
             } else if (!isInitialLoad) { // Avoid logging if already active on initial load
                  debugLog(`[NAV] Section #${section.id} was already active.`);
             }
             foundSection = true;
        } else {
            if (section.classList.contains('active')) {
                section.classList.remove('active');
                 debugLog(`[NAV] Deactivated section element: #${section.id}`);
             }
        }
    });

    if (!foundSection) {
         console.error(`[NAV ERROR] Target section element with id "${sectionId}" not found in DOM.`);
         debugLog(`[NAV ERROR] Target section element with id "${sectionId}" not found.`);
         // Optionally switch to a default section like 'earn'
         // if (sectionId !== 'earn') {
         //     switchSection('earn');
         // }
         return; // Stop if section doesn't exist
    }

    let foundButton = false;
    navButtons.forEach(btn => {
         const btnSectionId = btn.getAttribute('data-section');
         if (btnSectionId === sectionId) {
             if (!btn.classList.contains('active')) {
                 btn.classList.add('active');
                 debugLog(`[NAV] Activated button: [data-section="${btnSectionId}"]`);
             }
             foundButton = true;
         } else {
             if (btn.classList.contains('active')) {
                 btn.classList.remove('active');
                 debugLog(`[NAV] Deactivated button: [data-section="${btnSectionId}"]`);
             }
         }
     });

     if (!foundButton) {
         console.warn(`[NAV WARN] Target button with data-section "${sectionId}" not found.`);
         debugLog(`[NAV WARN] Target button with data-section "${sectionId}" not found.`);
     }

    // Load data for the activated section (call functions from uiUpdater.js or section files)
     debugLog(`[NAV] Loading data for section: ${sectionId}`);
     try {
         // Use ensureFirebaseReady to handle data loading for relevant sections
         // Use window. to access functions defined in other files loaded globally
         if (sectionId === 'earn') await ensureFirebaseReady(window.updateEarnSectionUI, 'updateEarnSectionUI');
         else if (sectionId === 'invite') await ensureFirebaseReady(window.updateInviteSectionUI, 'updateInviteSectionUI');
         else if (sectionId === 'top') await ensureFirebaseReady(window.updateTopSectionUI, 'updateTopSectionUI');
         else if (sectionId === 'wallet') await ensureFirebaseReady(window.updateWalletSectionUI, 'updateWalletSectionUI');
         else if (sectionId === 'chest') {
             // Chests need user stats (gems, VIP) to update correctly
             await ensureFirebaseReady(window.updateUserStatsUI, 'updateChestUserStats');
             window.updateChestUI(); // Now update chest UI using cached stats
         } else if (sectionId === 'game') {
             // Add game section update logic if needed
             debugLog(`[NAV] No specific data load function defined for game section yet.`);
         }
          else {
            debugLog(`[NAV] No specific data load function mapped for section: ${sectionId}`);
         }

     } catch (error) {
         console.error(`[NAV ERROR] Error loading data for section ${sectionId}:`, error);
         debugLog(`[NAV ERROR] Error loading data for section ${sectionId}: ${error.message}`);
     }
 }


// js/telegramService.js

// Forward declare global
let telegramUser;

function initializeTelegram() {
     debugLog("Initializing Telegram Web App...");
    try {
        if (!window.Telegram || !window.Telegram.WebApp) {
            throw new Error("Telegram WebApp script not loaded or available.");
        }
        window.Telegram.WebApp.ready();
        // Use initDataUnsafe for user data, but be aware of potential security implications if validating server-side
        const initData = window.Telegram.WebApp.initDataUnsafe || {};
        telegramUser = initData.user;

        if (telegramUser) {
            debugLog("Telegram user data found:", { id: telegramUser.id, username: telegramUser.username });
            // Update profile pic in uiUpdater.js or main.js after initialization
        } else {
            console.warn("No Telegram user data available. Running in test mode or outside Telegram.");
            debugLog("No Telegram user data found. Using test user.");
            // Define a fallback test user if needed for development outside Telegram
            telegramUser = {
                id: "test_user_" + Date.now(), // Unique test ID
                username: "TestUser",
                first_name: "Test",
                last_name: "",
                language_code: "en",
                photo_url: "https://via.placeholder.com/40/808080/000000?text=T"
            };
            // Update profile pic in uiUpdater.js or main.js
        }
        debugLog("Telegram Web App initialized successfully.");
        return true;
    } catch (error) {
        console.error("Telegram Web App initialization failed:", error);
        debugLog(`Telegram Web App initialization failed: ${error.message}`);
         // Define a fallback test user if Telegram fails catastrophically
         telegramUser = {
             id: "fallback_user_" + Date.now(),
             username: "FallbackUser",
             first_name: "Fallback",
             last_name: "",
             language_code: "en",
             photo_url: "https://via.placeholder.com/40/FF0000/FFFFFF?text=F" // Error indicator
         };
         // Update profile pic in uiUpdater.js or main.js
         alert("Could not initialize Telegram features. Using fallback mode.");
        return false;
    }
}

function getTelegramStartParam() {
    try {
        return window.Telegram?.WebApp?.initDataUnsafe?.start_param;
    } catch (e) {
        debugLog("Error accessing Telegram start_param:", e);
        return null;
    }
}

function openTelegramLink(link) {
     if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.openTelegramLink) {
        window.Telegram.WebApp.openTelegramLink(link);
     } else {
        window.open(link, '_blank');
        debugLog("[TELEGRAM WARN] Not in Telegram context or method unavailable, opening link in new tab.");
     }
}


// js/uiUpdater.js

// --- User Data / Stats UI ---

async function initializeUserData() {
     debugLog("Initializing user data...");
    // Needs global telegramUser from main.js
    if (!window.telegramUser || !window.telegramUser.id) {
         console.warn("Cannot initialize user data: No Telegram user available or no ID.");
         debugLog("User init skipped: No Telegram user ID.");
         return;
    }
    if (!firebaseInitialized || !db) { // Needs globals from firebaseService.js
        console.error("Firestore not initialized. Cannot initialize user data.");
        debugLog("User init skipped: Firestore not initialized.");
        return;
    }

    const userIdStr = window.telegramUser.id.toString();
    const userDocRef = db.collection('userData').doc(userIdStr);
    const rankingDocRef = db.collection('users').doc(userIdStr); // Assuming 'users' for ranking

    try {
        const doc = await userDocRef.get();
        if (!doc.exists) {
            debugLog(`User ${userIdStr} not found in userData, creating new record.`);
            const newUser = {
                gems: 0,
                usdt: 0,
                ton: 0,
                referrals: 0,
                referralCredits: 0,
                inviteRecords: [],
                claimHistory: [],
                landPieces: 0,
                foxMedals: 0,
                vipLevel: 0,
                isReferred: false,
                referredBy: null,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(), // Needs firebase global
                lastLogin: firebase.firestore.FieldValue.serverTimestamp(),
                claimedQuests: [],
                adProgress: {},
                walletAddress: null,
                // transactions: [] // Transactions are now a subcollection
            };
            await userDocRef.set(newUser);
            // Initialize transactions subcollection (optional, happens on first transaction)
            // await userDocRef.collection('transactions').doc('initial').set({ init: true });

            // Also create ranking entry
            const rankingEntry = {
                username: window.telegramUser.username || window.telegramUser.first_name || `User_${userIdStr.slice(-4)}`,
                foxMedals: 0,
                photoUrl: window.telegramUser.photo_url || 'assets/icons/user-avatar.png',
                userId: userIdStr
            };
            await rankingDocRef.set(rankingEntry, { merge: true });

            debugLog("New user data initialized in userData and users collections.");
            if (window.analytics) window.analytics.logEvent('user_signup', { userId: userIdStr }); // Needs analytics global
        } else {
            debugLog(`User ${userIdStr} found. Updating last login and checking fields.`);
            // Ensure essential fields exist if user doc was created before fields were added
            const updates = {
                lastLogin: firebase.firestore.FieldValue.serverTimestamp()
            };
            const userData = doc.data();
            // Check and initialize missing fields if necessary
            if (userData.gems === undefined) updates.gems = 0;
            if (userData.usdt === undefined) updates.usdt = 0;
            if (userData.ton === undefined) updates.ton = 0;
            if (userData.referrals === undefined) updates.referrals = 0;
            if (userData.referralCredits === undefined) updates.referralCredits = 0;
            if (userData.inviteRecords === undefined) updates.inviteRecords = [];
            if (userData.claimHistory === undefined) updates.claimHistory = [];
            if (userData.landPieces === undefined) updates.landPieces = 0;
            if (userData.foxMedals === undefined) updates.foxMedals = 0;
            if (userData.vipLevel === undefined) updates.vipLevel = 0;
            if (userData.isReferred === undefined) updates.isReferred = false;
            if (userData.referredBy === undefined) updates.referredBy = null;
            if (userData.claimedQuests === undefined) updates.claimedQuests = [];
            if (userData.adProgress === undefined) updates.adProgress = {};
            if (userData.walletAddress === undefined) updates.walletAddress = null;
            // Add other checks as needed

             // Only update if there are fields to add/correct besides lastLogin
             if (Object.keys(updates).length > 1) {
                await userDocRef.update(updates);
                debugLog("Updated missing fields for existing user.");
             } else {
                 await userDocRef.update({ lastLogin: updates.lastLogin }); // Just update login time
             }

             // Ensure ranking entry exists too
             const rankDoc = await rankingDocRef.get();
             if (!rankDoc.exists) {
                  const rankingEntry = {
                      username: window.telegramUser.username || window.telegramUser.first_name || `User_${userIdStr.slice(-4)}`,
                      foxMedals: userData.foxMedals || 0, // Sync medals
                      photoUrl: window.telegramUser.photo_url || 'assets/icons/user-avatar.png',
                      userId: userIdStr
                  };
                  await rankingDocRef.set(rankingEntry);
                  debugLog("Created missing ranking entry for existing user.");
             } else {
                 // Optionally update username/photo in ranking if changed in Telegram
                 const rankData = rankDoc.data();
                 const currentPhoto = window.telegramUser.photo_url || 'assets/icons/user-avatar.png';
                 const currentUsername = window.telegramUser.username || window.telegramUser.first_name || `User_${userIdStr.slice(-4)}`;
                 const rankUpdates = {};
                 if (rankData.photoUrl !== currentPhoto) rankUpdates.photoUrl = currentPhoto;
                 if (rankData.username !== currentUsername) rankUpdates.username = currentUsername;
                 // Sync medals just in case they got out of sync (optional, userData should be source of truth)
                 // if (rankData.foxMedals !== (userData.foxMedals || 0)) rankUpdates.foxMedals = userData.foxMedals || 0;

                 if (Object.keys(rankUpdates).length > 0) {
                     await rankingDocRef.update(rankUpdates);
                     debugLog("Updated ranking entry username/photo.");
                 }
             }
        }
         // Fetch the potentially newly created or updated data into cache
         await window.fetchAndUpdateUserData(); // Use window. prefix

    } catch (error) {
        console.error("Error initializing/checking user data:", error);
        debugLog(`Error initializing user data for ${userIdStr}: ${error.message}`);
        alert("There was a problem loading your profile.");
    }
}

// Fetch user data and store globally
async function fetchAndUpdateUserData() {
    // debugLog("Fetching and updating user data..."); // Can be noisy
    // Needs globals telegramUser, firebaseInitialized, db from main.js/firebaseService.js
    if (!window.telegramUser || !window.telegramUser.id || !firebaseInitialized || !db) {
        debugLog("User data fetch skipped: Conditions not met.");
        window.currentUserData = null; // Reset cache (use window. prefix)
        return null;
    }
    try {
        const userDocRef = db.collection('userData').doc(window.telegramUser.id.toString());
        const userDoc = await userDocRef.get();
        if (!userDoc.exists) {
            debugLog("User doc not found during fetch. Might be new user.");
            window.currentUserData = null; // Reset cache
            // If user doc doesn't exist here, initializeUserData should handle it on startup.
            // Avoid recursive calls by not calling initializeUserData here.
            return null;
        }
        window.currentUserData = userDoc.data(); // Update cache
        // debugLog("User data fetched and cached:", window.currentUserData);
        return window.currentUserData;
    } catch (error) {
        console.error("Error fetching user data:", error);
        debugLog(`Error fetching user data: ${error.message}`);
        window.currentUserData = null; // Reset cache on error
        return null;
    }
}

// Update the top stats bar and potentially other common elements
function updateUserStatsUI() {
     // debugLog("Updating user stats UI..."); // Can be noisy
     const data = window.currentUserData; // Use cached data (use window. prefix)

     const gemsEl = document.getElementById('gems');
     const usdtEl = document.getElementById('usdt');
     const tonEl = document.getElementById('ton');
     // Wallet balances might be updated separately in updateWalletSectionUI, but syncing here is okay
     const walletUsdtEl = document.getElementById('wallet-usdt');
     const walletTonEl = document.getElementById('wallet-ton');
     const profilePic = document.querySelector('.profile-pic img');

     if (!gemsEl || !usdtEl || !tonEl || !walletUsdtEl || !walletTonEl || !profilePic) {
         console.warn("One or more UI elements for stats not found.");
         debugLog("Stats UI update skipped: Missing elements.");
         return;
     }

     if (!data) {
          debugLog("Stats UI update skipped: No user data available in cache.");
          // Set UI to defaults or loading state
          gemsEl.textContent = 0;
          usdtEl.textContent = '0.0000';
          tonEl.textContent = '0.0000';
          walletUsdtEl.textContent = '0.0000';
          walletTonEl.textContent = '0.0000';
          profilePic.src = 'assets/icons/user-avatar.png'; // Default avatar
          return;
     }

    try {
        gemsEl.textContent = (data.gems || 0).toLocaleString();
        usdtEl.textContent = (data.usdt || 0).toFixed(4);
        tonEl.textContent = (data.ton || 0).toFixed(4);
        walletUsdtEl.textContent = (data.usdt || 0).toFixed(4);
        walletTonEl.textContent = (data.ton || 0).toFixed(4);

        // Update profile picture if telegramUser is available
        if (window.telegramUser && profilePic) {
            profilePic.src = window.telegramUser.photo_url || 'assets/icons/user-avatar.png';
            profilePic.onerror = () => { // Add error handling for profile pics
                profilePic.src = 'assets/icons/user-avatar.png';
                console.warn("Failed to load Telegram profile picture, using default.");
            };
        }

        // debugLog("User stats UI updated successfully."); // Can be noisy
    } catch (error) {
        console.error("Error updating user stats UI:", error);
        debugLog(`Error updating stats UI: ${error.message}`);
    }
}

// --- Wallet UI Updates ---

async function updateWalletSectionUI() {
     debugLog("Updating Wallet section UI...");
     if (!window.currentUserData) {
        await window.fetchAndUpdateUserData(); // Ensure data is fetched if not present
     }
     updateUserStatsUI(); // Update balances shown in the wallet section from cached data
     await updateWalletConnectionStatusUI(); // Update connection button/status text
     await updateTransactionHistory(); // Update tx list
     setupWithdrawListeners(); // Re-attach listeners in case elements were re-rendered
     debugLog("Wallet section UI update complete.");
 }

 async function updateWalletConnectionStatusUI() {
     debugLog("Updating Wallet Connection Status UI...");
     const elements = getWalletElements(); // Use function from walletService.js
     if (!elements.connectButton || !elements.connectionStatus) {
        debugLog("Wallet connect button or status element not found.");
        return;
     }

     const isConnected = tonConnectUI && tonConnectUI.connected; // Use global from walletService.js
     debugLog(`Wallet connection status: ${isConnected}`);

     const userHasWallet = !!window.currentUserData?.walletAddress;

     if (isConnected) {
         const wallet = tonConnectUI.wallet;
         let address = wallet?.account?.address;
         let shortAddress = address ? `${address.slice(0, 6)}...${address.slice(-4)}` : 'Connected';

         elements.connectionStatus.textContent = `Connected: ${shortAddress}`;
         elements.connectionStatus.className = 'wallet-status connected';
         elements.connectButton.textContent = 'DISCONNECT';
         elements.connectButton.classList.add('connected');
         // Enable withdraw buttons only if user has balance (check should happen in confirmWithdraw)
         elements.withdrawButtons.forEach(btn => btn.disabled = false );

         // Update stored address if different or not set
         const storedAddress = await Storage.getItem('walletAddress'); // Use Storage from firebaseService.js
         if (address && address !== storedAddress) {
             await Storage.setItem('walletAddress', address);
             debugLog(`Wallet connected: Address ${address} stored/updated.`);
             // Refresh currentUserData if needed
             if (window.currentUserData) window.currentUserData.walletAddress = address;
         } else if (address) {
             debugLog(`Wallet connected: Address ${address} already stored.`);
         } else {
             debugLog("Wallet connected, but address not immediately available in walletInfo.");
         }

     } else {
         elements.connectionStatus.textContent = 'Disconnected';
         elements.connectionStatus.className = 'wallet-status disconnected';
         elements.connectButton.textContent = 'CONNECT TON WALLET';
         elements.connectButton.classList.remove('connected');
         elements.withdrawButtons.forEach(btn => btn.disabled = true );
         debugLog("Wallet disconnected state UI updated.");
         // Optionally clear stored address on explicit disconnect?
         // await Storage.setItem('walletAddress', null);
     }
     elements.connectButton.disabled = false; // Ensure button is enabled after update
 }


async function updateTransactionHistory() {
    debugLog("Updating transaction history...");
    const elements = getWalletElements(); // Use function from walletService.js
    if (!elements.transactionList) {
        debugLog("Transaction list element not found.");
        return;
     }
    elements.transactionList.innerHTML = '<li><p>Loading history...</p></li>'; // Use <p> for consistency

    if (!firebaseInitialized || !db || !window.telegramUser || !window.telegramUser.id) {
        elements.transactionList.innerHTML = '<li><p>History unavailable.</p></li>';
        return;
    }

    try {
        // Reference the subcollection correctly
        const txCollectionRef = db.collection('userData').doc(window.telegramUser.id.toString()).collection('transactions');
        const snapshot = await txCollectionRef.orderBy('timestamp', 'desc').limit(15).get();

        if (snapshot.empty) {
             elements.transactionList.innerHTML = '<li><p>No transactions yet</p></li>';
             return;
        }

        debugLog(`Workspaceed ${snapshot.docs.length} transaction history entries.`);
        elements.transactionList.innerHTML = snapshot.docs.map(doc => {
            const tx = doc.data();
            const txTime = formatTimestamp(tx.timestamp); // Use utility function

            let detail = '';
            const status = tx.status || 'unknown';
            const statusClass = status.toLowerCase(); // Ensure class is lowercase

            // Build detail string based on type
            if (tx.type === 'withdrawal') {
                 detail = `Withdraw ${tx.amount?.toFixed(4) || '?'} ${tx.currency || '?'} (Fee: ${tx.fee?.toFixed(4) || '?'})`;
            } else if (tx.type === 'credit_claim') {
                 detail = `Claimed ${tx.usdtAmount?.toFixed(4) || '?'} USDT (${tx.creditsSpent?.toLocaleString() || '?'} C)`;
            } else if (tx.type === 'quest_reward') { // Example for future expansion
                 detail = `Quest Reward: +${tx.rewardAmount?.toLocaleString() || '?'} ${tx.rewardCurrency || '?'}`;
            } else {
                detail = `Type: ${tx.type || 'Unknown'} | Amount: ${tx.amount || 'N/A'}`; // Generic fallback
            }
            // Add destination for withdrawals if needed
            // if (tx.type === 'withdrawal' && tx.destination) {
            //     detail += ` to ${tx.destination.slice(0, 6)}...${tx.destination.slice(-4)}`;
            // }

            return `<li> ${detail} - <span class="tx-status ${statusClass}">${status}</span><br><small>${txTime}</small> </li>`; // Added line break and small tag for time
        }).join('');
    } catch (error) {
        console.error(`Error updating transaction history: ${error.message}`);
        debugLog(`Error updating transaction history: ${error.message}`);
        elements.transactionList.innerHTML = `<li><p class="error">Error loading history.</p></li>`;
    }
}


// Add update functions for other sections if needed (e.g., Game list if dynamic)
// function updateGameSectionUI() { ... }



// js/utils.js

// Debug Logging Helper
function debugLog(message, data = null) {
    const timestamp = new Date().toLocaleTimeString();
    console.log(`[DEBUG] ${timestamp}: ${message}`, data !== null ? data : '');
    const debugConsole = document.getElementById('debugConsole');
    if (debugConsole) {
        const entry = document.createElement('div');
        entry.textContent = `${timestamp}: ${message}${data ? ` - ${JSON.stringify(data)}` : ''}`;
        debugConsole.appendChild(entry);
        // Auto-scroll to bottom
        debugConsole.scrollTop = debugConsole.scrollHeight;
    }
}

// Dynamically load a script and return a Promise
function loadScript(src, retries = 3, delay = 1000) {
     debugLog(`Attempting to load script: ${src}`);
    return new Promise((resolve, reject) => {
        let attempts = 0;
        const tryLoad = () => {
            // Check if script already exists
            if (document.querySelector(`script[src="${src}"]`)) {
                debugLog(`Script already loaded: ${src}`);
                resolve();
                return;
            }
            const script = document.createElement('script');
            script.src = src;
            script.async = true;
            script.onload = () => {
                debugLog(`Script loaded successfully: ${src}`);
                resolve();
            };
            script.onerror = () => {
                attempts++;
                 document.head.removeChild(script); // Clean up failed script tag
                if (attempts < retries) {
                    console.warn(`Failed to load script: ${src}. Retrying (${attempts}/${retries})...`);
                    setTimeout(tryLoad, delay);
                } else {
                    const errorMsg = `Failed to load script after ${retries} attempts: ${src}`;
                    console.error(errorMsg);
                    debugLog(errorMsg); // Log to debug console too
                    reject(new Error(errorMsg));
                }
            };
            document.head.appendChild(script);
        };
        tryLoad();
    });
}

// Helper to format Firestore Timestamps safely
function formatTimestamp(timestamp) {
    let txTime = 'Invalid date';
    if (timestamp && typeof timestamp.toDate === 'function') {
       try { txTime = timestamp.toDate().toLocaleString(); } catch (dateErr) { console.warn("Error formatting date:", dateErr); }
    } else if (timestamp) {
        // Try parsing if it's a string or number
        const date = new Date(timestamp);
        if (!isNaN(date.getTime())) {
             txTime = date.toLocaleString();
        }
    }
    return txTime;
}


// js/walletService.js

// Forward declare globals
let tonConnectUI = null;

const TONCONNECT_MANIFEST_URL = 'https://fourgo.app/tonconnect-manifest.json'; // Or load from config.js
const TONCONNECT_CDN_URL = 'https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js';

function getWalletElements() {
   return {
        connectButton: document.querySelector('.connect-button'),
        connectionStatus: document.getElementById('connection-status'),
        withdrawButtons: document.querySelectorAll('.withdraw-button'), // Re-select if needed after cloning
        walletSection: document.getElementById('wallet'),
        transactionList: document.getElementById('transaction-list'),
        // Modal elements
        modal: document.getElementById('withdraw-modal'),
        amountInput: document.getElementById('withdraw-amount'),
        availableBalanceEl: document.getElementById('available-balance'),
        currencySpan: document.getElementById('currency'),
        feeSpan: document.getElementById('withdraw-fee'),
        feeCurrencySpan: document.getElementById('fee-currency'),
        confirmButton: document.getElementById('confirm-withdraw'),
        cancelButton: document.getElementById('cancel-withdraw')
    };
}

async function initializeTonConnect() {
    debugLog("Initializing TON Connect...");
    try {
        if (!window.TonConnectUI) {
            debugLog("Attempting to load TON Connect UI from CDN:", TONCONNECT_CDN_URL);
            await loadScript(TONCONNECT_CDN_URL); // Use utility function
            if (!window.TonConnectUI) throw new Error("Loaded from CDN, but TonConnectUI not defined.");
            debugLog("TON Connect UI loaded successfully from CDN.");
        } else {
             debugLog("TON Connect UI already available in window scope.");
        }

        // Check if UI instance already exists
        if (tonConnectUI) {
             debugLog("TON Connect UI instance already exists.");
             return tonConnectUI;
        }

        tonConnectUI = new TonConnectUI({
            manifestUrl: TONCONNECT_MANIFEST_URL,
            buttonRootId: null // We manage the button connection manually
        });
        debugLog("TON Connect UI instance created.");
        return tonConnectUI;

    } catch (error) {
        console.error(`TON Connect initialization failed: ${error.message}`);
        debugLog(`TON Connect initialization failed: ${error.message}`);
        alert("Wallet connection features are unavailable.");
        // Return a dummy object to prevent errors elsewhere if needed
        return { connected: false, account: null, connectWallet: async () => { alert("Wallet connection unavailable."); }, disconnect: async () => {}, onStatusChange: () => {} };
    }
}

async function handleConnectClick() {
    debugLog("[WALLET ACTION] Connect/Disconnect button clicked.");
    const elements = getWalletElements();
    if (!elements.connectButton || !tonConnectUI) {
        debugLog("Wallet connect button or TON Connect UI not ready.");
        return;
    }

    elements.connectButton.disabled = true; elements.connectButton.textContent = 'Processing...';
    try {
        if (tonConnectUI.connected) {
            debugLog("Disconnecting wallet...");
            await tonConnectUI.disconnect(); // Triggers status change listener
            debugLog("Wallet disconnect initiated.");
        } else {
            debugLog("Connecting wallet...");
             // The connectWallet method should handle opening the modal/redirects
             await tonConnectUI.connectWallet();
             // Status change listener will handle UI updates upon connection
            debugLog("Wallet connection process initiated via TON Connect UI.");
        }
    } catch (error) {
        console.error(`Wallet connection/disconnection error: ${error.message}`);
        debugLog(`Wallet connect/disconnect error: ${error.message}`);
        alert(`Wallet action failed: ${error.message}`);
        await updateWalletConnectionStatusUI(); // Update UI based on actual state on error
    } finally {
        // Re-enable button only if status change didn't handle it (safety net)
        // Status listener should ideally re-enable it.
        setTimeout(() => {
             const currentElements = getWalletElements(); // Re-fetch in case DOM changed
             if (currentElements.connectButton && currentElements.connectButton.textContent === 'Processing...') {
                  currentElements.connectButton.disabled = false;
                 updateWalletConnectionStatusUI(); // Ensure correct text/state
             }
         }, 1500); // Slightly longer timeout
    }
}

async function initWalletSystem() {
    debugLog("Initializing wallet system...");
    tonConnectUI = await initializeTonConnect(); // Ensure TON Connect is ready
    if (!tonConnectUI) return;

    const elements = getWalletElements();
    if (!elements.connectButton) {
        debugLog("Wallet connect button not found during init.");
        return;
    }

    try {
        // TON Connect status change listener
        tonConnectUI.onStatusChange(async (walletInfo) => {
            const isConnected = !!walletInfo;
            debugLog(`[WALLET STATUS CHANGE] Wallet status changed. Connected: ${isConnected}`, walletInfo ? { address: walletInfo.account.address, chain: walletInfo.account.chain } : null);

             // Re-fetch user data to ensure consistency, especially if wallet address changes state
             await window.fetchAndUpdateUserData();

            await updateWalletConnectionStatusUI(); // Update UI based on new status
            const currentElements = getWalletElements(); // Re-fetch
             if (currentElements.connectButton) currentElements.connectButton.disabled = false; // Re-enable button

             // Store or clear wallet address on status change
             if (isConnected && walletInfo.account?.address) {
                await Storage.setItem('walletAddress', walletInfo.account.address);
                debugLog(`Wallet connected: Address ${walletInfo.account.address} stored.`);
             } else if (!isConnected) {
                 // Optionally clear stored address on disconnect if desired
                 // await Storage.setItem('walletAddress', null);
                 // debugLog("Wallet disconnected, cleared stored address.");
             }

        }, (error) => {
             console.error("[WALLET STATUS CHANGE ERROR]", error);
             debugLog(`[WALLET STATUS CHANGE ERROR] ${error.message || 'Unknown error'}`);
             // Maybe update UI to show an error state?
        });

        // Add connect/disconnect button listener (ensure only one listener)
        elements.connectButton.removeEventListener('click', handleConnectClick); // Remove previous if any
        elements.connectButton.addEventListener('click', handleConnectClick);

        // Setup withdraw button listeners
        setupWithdrawListeners();

        // Initial UI update based on current state
        await updateWalletConnectionStatusUI();

        debugLog("Wallet system initialized successfully.");
    } catch (error) {
        console.error(`Wallet system init failed: ${error.message}`);
        debugLog(`Wallet system init failed: ${error.message}`);
    }
}

function setupWithdrawListeners() {
     const elements = getWalletElements();
     elements.withdrawButtons.forEach(button => {
         const card = button.closest('.balance-card');
         // Remove old listeners before adding new ones to prevent duplicates
         button.replaceWith(button.cloneNode(true)); // Simple way to remove all listeners
     });
     // Re-select buttons after cloning
     const newWithdrawButtons = document.querySelectorAll('.wallet-section .withdraw-button');
     newWithdrawButtons.forEach(button => {
         const card = button.closest('.balance-card');
         if (card) {
             button.addEventListener('click', () => showWithdrawModal(card));
         } else {
             debugLog("[WALLET WARN] Could not find parent card for withdraw button during listener setup.");
         }
     });

     // Setup modal cancel listener
     const modalElements = getWalletElements();
     if (modalElements.cancelButton) {
         modalElements.cancelButton.onclick = () => {
             if(modalElements.modal) modalElements.modal.style.display = 'none';
             debugLog("Withdraw modal cancelled.");
         };
     }
     // Confirm listener is added in showWithdrawModal
}


function showWithdrawModal(cardElement) {
    debugLog("Showing withdraw modal...");
    const elements = getWalletElements(); // Get modal elements
    if (!elements.modal || !elements.amountInput || !elements.availableBalanceEl || !elements.currencySpan || !elements.feeSpan || !elements.feeCurrencySpan || !elements.confirmButton || !elements.cancelButton) {
        debugLog("Withdraw modal elements not found.");
        return;
     }

    const isUsdt = cardElement.classList.contains('usdt-card');
    const currency = isUsdt ? 'USDT' : 'TON';
    // Fetch balance directly from cached user data for accuracy
    const balance = isUsdt ? (window.currentUserData?.usdt || 0) : (window.currentUserData?.ton || 0);
    const fee = isUsdt ? 0.01 : 0.005; // TODO: Fetch fees dynamically if they change

    elements.availableBalanceEl.textContent = balance.toFixed(4);
    elements.currencySpan.textContent = currency;
    elements.feeSpan.textContent = fee.toFixed(isUsdt ? 2 : 3);
    elements.feeCurrencySpan.textContent = currency;
    elements.amountInput.value = '';
    elements.amountInput.max = Math.max(0, balance - fee).toFixed(4);
    elements.amountInput.step = isUsdt ? "0.0001" : "0.001";

    // Re-enable confirm button and set default text
    elements.confirmButton.disabled = false;
    elements.confirmButton.textContent = 'Confirm';

    // Add confirm listener (replace old one if exists)
    const newConfirmButton = elements.confirmButton.cloneNode(true);
    elements.confirmButton.parentNode.replaceChild(newConfirmButton, elements.confirmButton);
    newConfirmButton.onclick = () => confirmWithdraw(currency, balance, fee);

    elements.modal.style.display = 'flex';
    debugLog(`Withdraw modal shown for ${currency}. Balance: ${balance}, Fee: ${fee}`);
}

async function confirmWithdraw(currency, balance, fee) {
    debugLog(`[WITHDRAW ACTION] Confirming withdrawal for ${currency}...`);
    const elements = getWalletElements(); // Get modal elements
    if (!elements.modal || !elements.amountInput || !elements.confirmButton) return;

    const amount = parseFloat(elements.amountInput.value);

    elements.confirmButton.disabled = true; elements.confirmButton.textContent = 'Processing...';

    // --- Input Validation ---
    if (isNaN(amount) || amount <= 0) {
         alert("Invalid amount entered.");
         elements.confirmButton.disabled = false; elements.confirmButton.textContent = 'Confirm';
         return;
    }
    const totalDeduction = amount + fee;
     if (totalDeduction > balance) { // Check against accurate balance
        alert("Insufficient balance (including fee).");
        elements.confirmButton.disabled = false; elements.confirmButton.textContent = 'Confirm';
        return;
     }
     if (!tonConnectUI || !tonConnectUI.connected || !tonConnectUI.account?.address) {
        alert("Wallet not connected or address unavailable.");
        elements.confirmButton.disabled = false; elements.confirmButton.textContent = 'Confirm';
        elements.modal.style.display = 'none';
        return;
     }
     // --- End Validation ---

    const destinationAddress = tonConnectUI.account.address;
    const userDocRef = db.collection('userData').doc(window.telegramUser.id.toString());
    const balanceField = currency.toLowerCase(); // 'usdt' or 'ton'

    try {
        debugLog(`[WITHDRAW SIMULATION] Initiating withdrawal: ${amount} ${currency} to ${destinationAddress} (Fee: ${fee} ${currency}, Total: ${totalDeduction})`);

        // Create Transaction Record (Pending) in subcollection
        const transaction = {
            txId: `sim_tx_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`, // More unique ID
            userId: window.telegramUser.id.toString(),
            amount: amount, currency: currency, fee: fee, totalDeducted: totalDeduction,
            destination: destinationAddress, status: 'pending',
            timestamp: firebase.firestore.FieldValue.serverTimestamp(), type: 'withdrawal'
        };
        const txRef = userDocRef.collection('transactions').doc(transaction.txId);
        await txRef.set(transaction);
        debugLog(`[WITHDRAW SIMULATION] Pending transaction record created: ${transaction.txId}`);

        // Deduct Balance from User Data atomically
        await userDocRef.update({ [balanceField]: firebase.firestore.FieldValue.increment(-totalDeduction) });
        debugLog(`[WITHDRAW SIMULATION] User balance deducted: -${totalDeduction} ${currency}`);

        // Update UI immediately to show pending state and reduced balance
        await window.fetchAndUpdateUserData(); // Refresh cache
        await updateWalletSectionUI(); // Update wallet UI (shows new balance, pending tx)

        // Simulate Processing Delay & Completion/Failure
        setTimeout(async () => {
             const shouldSucceed = Math.random() > 0.1; // 90% success rate for simulation
             try {
                 const finalStatus = shouldSucceed ? 'completed' : 'failed';
                 const updateData = { status: finalStatus };
                 if (!shouldSucceed) {
                     updateData.failureReason = 'Simulated transaction failure.';
                 }
                 await txRef.update(updateData);
                 debugLog(`[WITHDRAW SIMULATION] Transaction ${transaction.txId} marked as ${finalStatus}.`);
                 await updateTransactionHistory(); // Refresh history UI
             } catch (simError) {
                  console.error("Error updating simulated transaction status:", simError);
                  debugLog(`[WITHDRAW SIMULATION ERROR] Failed updating tx ${transaction.txId} status: ${simError.message}`);
                  // Attempt to mark as failed in Firestore if update failed
                  try { await txRef.update({ status: 'failed', failureReason: `Update error: ${simError.message}` }); } catch (failErr) { console.error("Failed to mark tx as failed:", failErr); }
                  await updateTransactionHistory(); // Refresh history UI even on error
             }
         }, 5000 + Math.random() * 3000); // 5-8 second delay for simulation

        if (window.analytics) window.analytics.logEvent('withdrawal_initiated', { userId: window.telegramUser.id, currency, amount, fee });

        elements.modal.style.display = 'none';
        alert(`Withdrawal of ${amount.toFixed(4)} ${currency} initiated (Fee: ${fee.toFixed(4)} ${currency}). Status will update in history (Simulation).`);

    } catch (error) {
        console.error(`Withdrawal error: ${error.message}`);
        debugLog(`[WITHDRAW ERROR] ${error.message}`);
        alert(`Withdrawal failed: ${error.message}`);
        // Attempt to revert UI changes or show error clearly
        elements.confirmButton.disabled = false; elements.confirmButton.textContent = 'Confirm';
        // Consider re-fetching user data to ensure consistency after failure
        await window.fetchAndUpdateUserData();
        await updateWalletSectionUI();
    }
    // No finally needed as button state handled above
}
