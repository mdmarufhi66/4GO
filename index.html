<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4Metas Mini App</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src='//whephiwums.com/sdk.js' data-zone='9180370' data-sdk='show_9180370'></script>
    <style>
        /* Updated body structure */
        body {
            background: linear-gradient(to bottom, #330033, #000000);
            color: white;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Main content area */
        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            padding-bottom: 70px; /* Space for bottom nav */
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            position: sticky;
            top: 0;
            background: linear-gradient(to bottom, #330033, #000000);
            z-index: 1000;
        }
        header h1 {
            font-size: 24px;
            margin: 0;
        }
        .back-arrow, .menu-dots {
            font-size: 24px;
            cursor: pointer;
        }
        .user-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 0 10px;
        }
        .user-stats .logo img {
            width: 50px;
            height: 50px;
        }
        .user-stats .metric {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .user-stats .metric img {
            width: 20px;
            height: 20px;
        }
        .user-stats .profile-pic img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        .section {
            display: none;
        }
        .section.active {
            display: block;
        }
        .banner-placeholder {
            background: #1a1a3d;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            margin-bottom: 20px;
        }
        .banner-placeholder img {
            width: 100%;
            border-radius: 10px;
        }
        .quest-section h2 {
            font-size: 18px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .quest-section .badge {
            background: #ff00ff;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
        }
        .quest-list {
            list-style: none;
            padding: 0;
        }
        .quest-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .quest-item img {
            width: 30px;
            height: 30px;
            border-radius: 50%;
        }
        .quest-reward {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .quest-reward img {
            width: 20px;
            height: 20px;
        }
        .go-button, .claim-button, .claimed-button {
            border: none;
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
        }
        .go-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
        }
        .claim-button {
            background: linear-gradient(to right, #00ff00, #66ff66);
        }
        .claimed-button {
            background: #ccc;
            cursor: default;
        }
        .quest-item .progress {
            font-size: 12px;
            color: #ccc;
            margin-left: 10px;
        }
        .claim-button.active {
            background: linear-gradient(to right, #00ff00, #66ff66);
        }
        .wallet-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .balance-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .balance-card img {
            width: 30px;
            height: 30px;
        }
        .balance-info span {
            display: block;
            font-size: 16px;
        }
        .balance-info small {
            font-size: 12px;
            color: #ccc;
        }
        .withdraw-button {
            background: #00ff00;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
        }
        .warning-button {
            background: #ffcc00;
            border: none;
            color: black;
            padding: 5px 10px;
            border-radius: 50%;
            cursor: pointer;
        }
        .connect-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 15px;
            width: 100%;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.3s ease;
        }
        .connect-button.connected {
            background: linear-gradient(to right, #00ff00, #66ff66);
        }
        .connect-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .wallet-status {
            text-align: center;
            margin: 10px 0;
        }
        .wallet-status.connected {
            color: #00ff00;
        }
        .wallet-status.disconnected {
            color: #ffcc00;
        }
        .transaction-history {
            margin-top: 20px;
        }
        .transaction-history ul {
            list-style: none;
            padding: 0;
        }
        .transaction-history li {
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-content {
            background: #1a1a3d;
            padding: 20px;
            border-radius: 10px;
            color: white;
            width: 80%;
            max-width: 400px;
        }
        .modal-content input {
            width: 100%;
            padding: 5px;
            margin: 10px 0;
        }
        .game-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .game-list {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }
        .game-item {
            background: #1a1a3d;
            border-radius: 10px;
            text-align: center;
            padding: 5px;
        }
        .game-item img {
            width: 100%;
            border-radius: 10px;
        }
        .game-item p {
            margin: 5px 0;
            font-size: 12px;
        }
        .invite-section .invite-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .invite-stats .spin-info {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .action-button {
            background: linear-gradient(to right, #00ff00, #66ff66);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 15px;
            flex: 1;
            cursor: pointer;
        }
        .total-credit {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .total-credit small {
            font-size: 12px;
            color: #ccc;
        }
        .total-credit small img {
            width: 15px;
            height: 15px;
        }
        .record-section h3, .invite-record h3 {
            font-size: 16px;
            margin: 10px 0;
        }
        .no-frens {
            text-align: center;
            color: #ccc;
        }
        .no-frens img {
            width: 50px;
            height: 50px;
        }
        .record-header {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #ccc;
            margin-bottom: 10px;
        }
        .record-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .record-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        .record-item .user-info {
            flex: 1;
            margin-left: 10px;
        }
        .record-item .user-info small {
            color: #ccc;
            font-size: 12px;
        }
        .record-item .credit {
            background: #ff00ff;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
        }
        .chest-section .chest-slider {
            position: relative;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .chest-container {
            display: flex;
            transition: transform 0.3s ease;
        }
        .chest-item {
            flex: 0 0 100%;
            text-align: center;
        }
        .chest-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 16px;
        }
        .chest-title span {
            color: #ccc;
        }
        .chest-image img {
            width: 150px;
            height: 150px;
        }
        .not-enough {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            color: #ffcc00;
            margin-top: 10px;
        }
        .not-enough img {
            width: 20px;
            height: 20px;
        }
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.5);
            border: none;
            color: white;
            padding: 10px;
            cursor: pointer;
            z-index: 100;
        }
        .nav-arrow.left {
            left: 0;
        }
        .nav-arrow.right {
            right: 0;
        }
        .rewards {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
        }
        .reward-item {
            text-align: center;
        }
        .reward-item img {
            width: 40px;
            height: 40px;
        }
        .reward-item p {
            margin: 5px 0;
            font-size: 12px;
        }
        .cost {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            margin-bottom: 10px;
        }
        .cost img {
            width: 20px;
            height: 20px;
        }
        .vip-requirement {
            text-align: center;
            color: #ffcc00;
            margin-bottom: 10px;
        }
        .open-chest-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 15px;
            width: 100%;
            cursor: pointer;
        }
        .top-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .ranking-list {
            list-style: none;
            padding: 0;
        }
        .ranking-item {
            display: flex;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .ranking-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .ranking-item span {
            flex: 1;
        }
        .ranking-item .medal-count {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .ranking-item .medal-count img {
            width: 20px;
            height: 20px;
        }

        nav.bottom-nav {
            display: flex !important;
            justify-content: space-around !important;
            background: #1a1a3d !important;
            padding: 10px 0 !important;
            position: fixed !important;
            bottom: env(safe-area-inset-bottom, 0px) !important;
            left: 0 !important;
            right: 0 !important;
            z-index: 100000 !important;
            height: 60px !important;
            visibility: visible !important;
            opacity: 1 !important;
            border-top: 2px solid red !important;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5) !important;
        }

        nav.bottom-nav .nav-button {
            background: none !important;
            border: none !important;
            color: #ccc !important;
            display: flex !important;
            flex-direction: column !important;
            align-items: center !important;
            justify-content: center !important;
            cursor: pointer !important;
            font-size: 12px !important;
            width: 60px !important;
            height: 100% !important;
            visibility: visible !important;
            opacity: 1 !important;
            min-height: 40px !important;
        }

        nav.bottom-nav .nav-button.active {
            color: white !important;
        }

        nav.bottom-nav .nav-button img {
            width: 24px !important;
            height: 24px !important;
            margin-bottom: 5px !important;
            display: block !important;
        }

        nav.bottom-nav .nav-button span {
            display: block !important;
        }

        /* Additional styles for wallet integration */
        .error-message {
            color: #ffcc00;
            text-align: center;
            margin: 10px 0;
            display: none;
        }

        .tx-status.pending { color: #ffcc00; }
        .tx-status.completed { color: #00ff00; }
        .tx-status.failed { color: #ff0000; }
    </style>
</head>
<body>
    <header>
        <div class="back-arrow">X</div>
        <h1>4Metas</h1>
        <div class="menu-dots">⋮</div>
    </header>

    <div class="main-content">
        <section class="user-stats">
            <div class="logo">
                <img src="assets/icons/logo.png" alt="4Metas Logo">
            </div>
            <div class="metric">
                <img src="assets/icons/gem.png" alt="Gem">
                <span id="gems">0</span>
            </div>
            <div class="metric">
                <img src="assets/icons/usdt.png" alt="USDT">
                <span id="usdt">0.0000</span>
            </div>
            <div class="metric">
                <img src="assets/icons/ton.png" alt="TON">
                <span id="ton">0.0000</span>
            </div>
            <div class="profile-pic">
                <img src="assets/icons/user-avatar.png" alt="User Profile">
            </div>
        </section>

        <section id="earn" class="section earn-section active">
            <div class="banner-placeholder">
                <img src="assets/icons/banner.png" alt="Banner">
            </div>
            <div class="quest-section">
                <h2>DAILY QUEST <span class="badge" id="daily-quest-count">0</span></h2>
                <ul class="quest-list" id="daily-quest-list">
                    <li class="no-quests">
                        <p>No daily quests available</p>
                    </li>
                </ul>
            </div>
            <div class="quest-section">
                <h2>BASIC QUEST <span class="badge" id="basic-quest-count">0</span></h2>
                <ul class="quest-list" id="basic-quest-list">
                    <li class="no-quests">
                        <p>No basic quests available</p>
                    </li>
                </ul>
            </div>
        </section>

        <section id="wallet" class="section wallet-section">
            <h2>Wallet</h2>
            <div class="wallet-status disconnected">
                <span id="connection-status">Disconnected</span>
            </div>
            <div class="balance-card usdt-card">
                <img src="assets/icons/usdt.png" alt="USDT Icon">
                <div class="balance-info">
                    <span id="wallet-usdt">0.0000</span>
                    <small>USDT</small>
                </div>
                <button class="withdraw-button" disabled>WITHDRAW</button>
                <button class="warning-button">!</button>
            </div>
            <div class="balance-card ton-card">
                <img src="assets/icons/ton.png" alt="TON Icon">
                <div class="balance-info">
                    <span id="wallet-ton">0.0000</span>
                    <small>TON</small>
                </div>
                <button class="withdraw-button" disabled>WITHDRAW</button>
                <button class="warning-button">!</button>
            </div>
            <p class="instruction">Connect wallet to withdraw your balance.</p>
            <button class="connect-button">CONNECT TON WALLET</button>
            <div class="transaction-history">
                <h3>Transaction History</h3>
                <ul id="transaction-list">
                    <li>No transactions yet</li>
                </ul>
            </div>
            <div id="withdraw-modal" class="modal" style="display: none;">
                <div class="modal-content">
                    <h3>Withdraw Funds</h3>
                    <label>Amount: <input type="number" id="withdraw-amount" min="0" step="0.0001"></label>
                    <p>Available: <span id="available-balance">0</span> <span id="currency"></span></p>
                    <p>Fee: <span id="withdraw-fee">0</span> <span id="fee-currency"></span></p>
                    <button id="confirm-withdraw">Confirm</button>
                    <button id="cancel-withdraw">Cancel</button>
                </div>
            </div>
        </section>

        <section id="game" class="section game-section">
            <div class="banner-placeholder">
                <img src="assets/icons/game-banner.png" alt="Game Banner">
            </div>
            <h2>Game List</h2>
            <div class="game-list">
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/FF0000/FFFFFF?text=TG" alt="Traffic Go">
                    <p>Traffic Go</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/00FF00/FFFFFF?text=CM" alt="Cutting Master">
                    <p>Cutting Master</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/0000FF/FFFFFF?text=EM" alt="Element Magic">
                    <p>Element Magic</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/FFFF00/FFFFFF?text=JS" alt="Juicy Splash">
                    <p>Juicy Splash</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/FF00FF/FFFFFF?text=COR" alt="Creed of Rescue">
                    <p>Creed of Rescue</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/00FFFF/FFFFFF?text=FJ" alt="Farm Jam">
                    <p>Farm Jam</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/FFA500/FFFFFF?text=2048" alt="2048 Blocks">
                    <p>2048 Blocks</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/800080/FFFFFF?text=CRC" alt="Cut Rope Combo">
                    <p>Cut Rope Combo</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/008000/FFFFFF?text=HJ" alt="Happy Jelly Jump">
                    <p>Happy Jelly Jump</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/000080/FFFFFF?text=UTR" alt="Undersea Tunnel Race">
                    <p>Undersea Tunnel Race</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/FFC0CB/FFFFFF?text=MM" alt="Motor Master">
                    <p>Motor Master</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/FFD700/FFFFFF?text=OF" alt="Open Fire">
                    <p>Open Fire</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/ADFF2F/FFFFFF?text=MTD" alt="Monster TD">
                    <p>Monster TD</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/FF4500/FFFFFF?text=BW" alt="Bloody Warrior">
                    <p>Bloody Warrior</p>
                </div>
            </div>
        </section>

        <section id="invite" class="section invite-section">
            <div class="invite-stats">
                <span id="my-invite">My Invite: 0</span>
                <div class="spin-info">
                    <span>Spin x0</span>
                    <span class="warning">!</span>
                </div>
            </div>
            <div class="action-buttons">
                <button class="action-button invite-friend">Invite Friend</button>
                <button class="action-button copy-link">Copy Link</button>
            </div>
            <div class="total-credit">
                <div class="credit-info">
                    <span id="total-credit">Total Credit <span class="warning">!</span> : 0</span>
                    <small>10,000 = 1 <img src="assets/icons/usdt.png" alt="USDT"></small>
                </div>
                <button class="claim-button">Claim</button>
            </div>
            <div class="record-section">
                <h3>Claim Record</h3>
                <div class="no-frens">
                    <img src="assets/icons/nofrens.png" alt="No Frens">
                    <p>No Frens yet</p>
                </div>
            </div>
            <div class="invite-record">
                <h3 id="invite-record-title">Invite Record (0)</h3>
                <div class="record-header">
                    <span>User</span>
                    <span>Join Time</span>
                    <span>Credit</span>
                </div>
                <div class="record-list">
                    <div class="no-frens">
                        <img src="assets/icons/nofrens.png" alt="No Frens">
                        <p>No invites yet</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="chest" class="section chest-section">
            <div class="chest-slider">
                <button class="nav-arrow left" onclick="prevChest()"><</button>
                <div class="chest-container" id="chestContainer">
                    <div class="chest-item">
                        <div class="chest-title">
                            <h2>Wood Chest</h2>
                            <span>Bronze</span>
                        </div>
                        <div class="chest-image">
                            <img src="assets/graphics/wood-chest.png" alt="Wood Chest">
                        </div>
                        <div class="not-enough">
                            <span>NOT ENOUGH</span>
                            <img src="assets/icons/gem.png" alt="Gem">
                        </div>
                    </div>
                    <div class="chest-item">
                        <div class="chest-title">
                            <h2>Bronze Chest</h2>
                            <span>Silver</span>
                        </div>
                        <div class="chest-image">
                            <img src="assets/graphics/bronze-chest.png" alt="Bronze Chest">
                        </div>
                        <div class="not-enough">
                            <span>NOT ENOUGH</span>
                            <img src="assets/icons/gem.png" alt="Gem">
                        </div>
                    </div>
                    <div class="chest-item">
                        <div class="chest-title">
                            <h2>Silver Chest</h2>
                            <span>Gold</span>
                        </div>
                        <div class="chest-image">
                            <img src="assets/graphics/silver-chest.png" alt="Silver Chest">
                        </div>
                        <div class="not-enough">
                            <span>NOT ENOUGH</span>
                            <img src="assets/icons/gem.png" alt="Gem">
                        </div>
                    </div>
                    </div>
                <button class="nav-arrow right" onclick="nextChest()">></button>
            </div>
            <div class="rewards">
                <div class="reward-item usdt">
                    <img src="assets/icons/usdt.png" alt="USDT">
                    <p>USDT</p>
                </div>
                <div class="reward-item land-piece">
                    <img src="assets/icons/land-piece.png" alt="Land Piece">
                    <p>Land Piece</p>
                </div>
                <div class="reward-item fox-medal">
                    <img src="assets/icons/fox-medal.png" alt="Fox Medal">
                    <p>Fox Medal</p>
                </div>
            </div>
            <div class="cost" id="chestCost">
                <span>200</span>
                <img src="assets/icons/gem.png" alt="Gem">
            </div>
            <div class="vip-requirement" id="chestVipRequirement" style="display: none;">
                NEED VIP 1
            </div>
            <button class="open-chest-button" onclick="openChest()">Open Chest</button>
        </section>

        <section id="top" class="section top-section">
            <h2>Medal Ranking <span class="warning">!</span></h2>
            <ul class="ranking-list" id="ranking-list">
                <li class="no-rankings">
                    <p>No rankings available</p>
                </li>
            </ul>
        </section>
    </div>

    <nav class="bottom-nav">
        <button class="nav-button" data-section="earn">
            <img src="assets/icons/earn.png" alt="Earn">
            <span>Earn</span>
        </button>
        <button class="nav-button" data-section="wallet">
            <img src="assets/icons/wallet.png" alt="Wallet">
            <span>Wallet</span>
        </button>
        <button class="nav-button" data-section="game">
            <img src="assets/icons/game.png" alt="Game">
            <span>Game</span>
        </button>
        <button class="nav-button" data-section="invite">
            <img src="assets/icons/invite.png" alt="Invite">
            <span>Invite</span>
        </button>
        <button class="nav-button" data-section="chest">
            <img src="assets/icons/chest.png" alt="Chest">
            <span>Chest</span>
        </button>
        <button class="nav-button" data-section="top">
            <img src="assets/icons/top.png" alt="Top">
            <span>Top</span>
        </button>
    </nav>
<div id="debugConsole" style="
    position: fixed;
    bottom: 70px;
    left: 0;
    right: 0;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px;
    font-family: monospace;
    font-size: 12px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 1000;
    display: none;
"></div>
<button onclick="document.getElementById('debugConsole').style.display =
    document.getElementById('debugConsole').style.display === 'none' ? 'block' : 'none'"
    style="
        position: fixed;
        bottom: 120px;
        right: 10px;
        z-index: 1001;
        padding: 5px 10px;
        background: #ff00ff;
        color: white;
        border: none;
        border-radius: 5px;
    ">
    Toggle Debug
</button>
    <script>
        console.log('Script started');
        console.log('Nav buttons present at start:', document.querySelectorAll('.nav-button').length);

        // Function to dynamically load a script and return a Promise
        function loadScript(src, retries = 3, delay = 1000) {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const tryLoad = () => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.async = true;
                    script.onload = () => {
                        console.log(`Script loaded successfully: ${src}`);
                        resolve();
                    };
                    script.onerror = () => {
                        attempts++;
                        if (attempts < retries) {
                            console.warn(`Failed to load script: ${src}. Retrying (${attempts}/${retries})...`);
                            setTimeout(tryLoad, delay);
                        } else {
                            console.error(`Failed to load script after ${retries} attempts: ${src}`);
                            reject(new Error(`Failed to load script after ${retries} attempts: ${src}`));
                        }
                    };
                    document.head.appendChild(script);
                };
                tryLoad();
            });
        }

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCUkEmFmJK2vr8k7M6JqYaxlcgBDf7WdJI",
            authDomain: "fourgo-cd98f.firebaseapp.com",
            projectId: "fourgo-cd98f",
            storageBucket: "fourgo-cd98f.firebasestorage.app",
            messagingSenderId: "511215742272",
            appId: "1:511215742272:web:04bd85a284919ae123dea5",
            measurementId: "G-DC7E6ECF2L"
        };

        // Validate Firebase Configuration
        function validateFirebaseConfig(config) {
            const requiredFields = [
                'apiKey',
                'authDomain',
                'projectId',
                'storageBucket',
                'messagingSenderId',
                'appId'
            ];
            for (const field of requiredFields) {
                if (!config[field]) {
                    throw new Error(`Firebase config is missing required field: ${field}`);
                }
            }
            console.log("Firebase config validated successfully");
        }

// Initialize Firebase with dynamic loading using compat scripts
let app, db, auth, storage, analytics;
let firebaseInitialized = false;
async function initializeFirebase(maxRetries = 3) {
    if (firebaseInitialized) {
        console.log("Firebase already initialized, skipping reinitialization");
        return true;
    }

    // Check if Firebase is already in the global scope and has an app instance
    if (window.firebase && window.firebase.apps && window.firebase.apps.length > 0) {
        console.log("Firebase detected in global scope, reusing existing instance");
        app = window.firebase.apps[0];
        db = app.firestore();
        auth = app.auth();
        storage = app.storage();
        // Check if analytics exists before trying to access it
        if (app.analytics) {
          analytics = app.analytics();
        } else {
            console.warn("Firebase Analytics component not available on existing instance.");
            // Optionally load analytics if needed
            try {
                await loadScript('https://www.gstatic.com/firebasejs/10.13.0/firebase-analytics-compat.js');
                analytics = firebase.analytics(); // Use global firebase here
                console.log("Firebase Analytics loaded dynamically.");
            } catch (error) {
                console.error("Failed to load Firebase Analytics dynamically:", error);
            }
        }
        firebaseInitialized = true;
        return true;
    }


    let attempts = 0;
    const scriptUrls = [
        'https://www.gstatic.com/firebasejs/10.13.0/firebase-app-compat.js',
        'https://www.gstatic.com/firebasejs/10.13.0/firebase-auth-compat.js',
        'https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore-compat.js',
        'https://www.gstatic.com/firebasejs/10.13.0/firebase-storage-compat.js',
        'https://www.gstatic.com/firebasejs/10.13.0/firebase-analytics-compat.js'
    ];

    while (attempts < maxRetries && !firebaseInitialized) {
        try {
            console.log(`Attempt ${attempts + 1}/${maxRetries} to initialize Firebase...`);
            validateFirebaseConfig(firebaseConfig);

            await Promise.all(scriptUrls.map(url => loadScript(url)));
            if (typeof firebase === 'undefined') {
                throw new Error("Firebase SDK not loaded into global scope");
            }

            // Check if app is already initialized (might happen between attempts)
            if (!firebase.apps.length) {
                app = firebase.initializeApp(firebaseConfig);
            } else {
                app = firebase.app(); // Get default app if already initialized
            }
            db = firebase.firestore();
            auth = firebase.auth();
            storage = firebase.storage();
            analytics = firebase.analytics();

            // Test Firestore connection
            await db.collection('test').doc('init').set({
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            }, { merge: true });

            firebaseInitialized = true;
            console.log("Firebase fully initialized");
            return true;
        } catch (error) {
            attempts++;
            console.error(`Firebase initialization attempt ${attempts} failed:`, error.message);
            if (attempts >= maxRetries) {
                console.error("Max retries reached. Firebase initialization failed.");
                return false;
            }
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
    }
    return false;
}

        // Telegram Web App Setup with error handling
        let telegramUser;
        try {
            window.Telegram.WebApp.ready();
            telegramUser = window.Telegram.WebApp.initDataUnsafe.user;
            if (telegramUser) {
                const profilePic = document.querySelector('.profile-pic img');
                if (profilePic) profilePic.src = telegramUser.photo_url || 'assets/icons/user-avatar.png';
                const headerTitle = document.querySelector('header h1');
                if (headerTitle) headerTitle.innerText = `4Metas`; // Removed name for privacy/simplicity
                console.log("Telegram Web App initialized successfully");
            } else {
                console.warn("No Telegram user data available. Running in test mode.");
                telegramUser = {
                    id: "test_user_123",
                    username: "TestUser",
                    first_name: "Test",
                    photo_url: "https://via.placeholder.com/40/808080/000000?text=T"
                };
                 const profilePic = document.querySelector('.profile-pic img');
                 if (profilePic) profilePic.src = telegramUser.photo_url;
            }
        } catch (error) {
            console.error("Telegram Web App initialization failed:", error);
            telegramUser = { // Fallback user for testing
                id: "test_user_123_fallback",
                username: "TestUserFB",
                first_name: "TestFB",
                photo_url: "https://via.placeholder.com/40/808080/000000?text=F"
            };
             const profilePic = document.querySelector('.profile-pic img');
             if (profilePic) profilePic.src = telegramUser.photo_url;
        }

        // Storage abstraction using Firebase Firestore
        const Storage = {
            getItem: async (key) => {
                if (!firebaseInitialized || !db) {
                    console.error("Firestore not initialized. Cannot fetch item:", key);
                    return null;
                }
                if (!telegramUser || !telegramUser.id) {
                     console.error("Telegram user ID not available. Cannot fetch item:", key);
                     return null;
                }
                try {
                    const doc = await db.collection('userData')
                        .doc(telegramUser.id.toString()).get();
                    return doc.exists ? doc.data()[key] : null;
                } catch (error) {
                    console.error(`Error fetching ${key}:`, error.message);
                    return null;
                }
            },
            setItem: async (key, value) => {
                if (!firebaseInitialized || !db) {
                    console.error("Firestore not initialized. Cannot set item:", key);
                    return false;
                }
                 if (!telegramUser || !telegramUser.id) {
                     console.error("Telegram user ID not available. Cannot set item:", key);
                     return false;
                 }
                try {
                    await db.collection('userData')
                        .doc(telegramUser.id.toString())
                        .set({ [key]: value }, { merge: true });
                    return true;
                } catch (error) {
                    console.error(`Error setting ${key}:`, error.message);
                    return false;
                }
            }
        };

        // Navigation Logic with Button Style Forcing
        document.addEventListener('DOMContentLoaded', () => {
            try {
                console.log('Setting up navigation');
                const sections = document.querySelectorAll('.section');
                const navButtons = document.querySelectorAll('nav.bottom-nav .nav-button');
                const bottomNav = document.querySelector('nav.bottom-nav');

                console.log('Found sections:', sections.length);
                console.log('Found nav buttons:', navButtons.length);
                console.log('Bottom nav exists:', !!bottomNav);
                if (bottomNav) {
                    const computedStyle = window.getComputedStyle(bottomNav);
                    console.log('Initial nav styles:');
                    console.log('  Display:', computedStyle.display);
                    console.log('  Visibility:', computedStyle.visibility);
                    console.log('  Opacity:', computedStyle.opacity);
                    // ... log other styles if needed
                }

                navButtons.forEach((btn, index) => {
                    console.log(`Button ${index}:`, btn.getAttribute('data-section'));
                    // Force styles (ensure they match CSS or override if necessary)
                    btn.style.display = 'flex';
                    btn.style.visibility = 'visible';
                    btn.style.opacity = '1';
                    // Check image loading
                    const img = btn.querySelector('img');
                    if (img) {
                        img.onerror = () => {
                            console.error(`Image failed to load for button ${index}: ${img.src}`);
                            img.src = 'https://via.placeholder.com/24/FFFFFF/000000?text=X'; // Fallback
                        };
                        img.onload = () => {
                             // console.log(`Image loaded for button ${index}: ${img.src}`); // Can be verbose
                        };
                    }
                });

                async function switchSection(sectionId) {
                    console.log(`Switching to section: ${sectionId}`);
                    sections.forEach(section => section.classList.remove('active'));
                    navButtons.forEach(btn => btn.classList.remove('active'));

                    const targetSection = document.getElementById(sectionId);
                    const targetButton = document.querySelector(`.nav-button[data-section="${sectionId}"]`);

                    if (targetSection) targetSection.classList.add('active');
                    else console.error(`Section with id "${sectionId}" not found`);

                    if (targetButton) targetButton.classList.add('active');
                    else console.error(`Button with data-section "${sectionId}" not found`);

                    try {
                        // Use ensureFirebaseReady for sections needing DB access
                        if (sectionId === 'earn') await ensureFirebaseReady(updateEarnSectionUI);
                        else if (sectionId === 'invite') await ensureFirebaseReady(updateInviteSectionUI);
                        else if (sectionId === 'top') await ensureFirebaseReady(updateTopSectionUI);
                        else if (sectionId === 'wallet') await ensureFirebaseReady(updateWalletSectionUI);
                        else if (sectionId === 'chest') await ensureFirebaseReady(updateChestSectionUI); // Added for chest data update

                    } catch (error) {
                        console.error(`Error updating section ${sectionId}:`, error.message);
                    }
                }

                navButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const sectionId = button.getAttribute('data-section');
                        switchSection(sectionId);
                    });
                });

                // Set default section
                console.log('Setting default section to Earn');
                switchSection('earn'); // Default to Earn

                // Ensure nav is visible and positioned (Force styles)
                if (bottomNav) {
                    bottomNav.style.display = 'flex'; // Use flex as per CSS
                    bottomNav.style.visibility = 'visible';
                    bottomNav.style.opacity = '1';
                    bottomNav.style.position = 'fixed';
                    bottomNav.style.bottom = '0px'; // Use 0px or env variable
                    bottomNav.style.left = '0px';
                    bottomNav.style.right = '0px';
                    bottomNav.style.height = '60px'; // Match CSS
                    bottomNav.style.zIndex = '100000'; // Match CSS
                    bottomNav.style.background = '#1a1a3d'; // Match CSS
                    console.log('Forced bottom-nav styles applied.');
                } else {
                    console.error('Bottom nav element not found in DOM');
                }
            } catch (error) {
                console.error('Navigation setup failed:', error.message, error.stack);
            }
        });

        // Helper to ensure Firebase is ready before running a callback
        async function ensureFirebaseReady(callback) {
            if (!firebaseInitialized || !db || !auth) { // Check auth too if needed by callback
                console.log("Firebase not ready, attempting initialization...");
                const success = await initializeFirebase();
                if (!success) {
                    console.error("Firebase initialization failed after retries. Cannot proceed.");
                    alert("Failed to connect to database. Please try again later.");
                    return;
                }
            }
            // Check if analytics is needed and initialized
            if (callback.needsAnalytics && !analytics) {
                 console.warn("Analytics needed but not initialized. Attempting to initialize/load.");
                 // Add logic to ensure analytics is loaded if required by the callback
                 if (!app.analytics) { // Check if it exists on the app object first
                    try {
                        await loadScript('https://www.gstatic.com/firebasejs/10.13.0/firebase-analytics-compat.js');
                        analytics = firebase.analytics(); // Use global firebase here
                        console.log("Firebase Analytics loaded dynamically for callback.");
                    } catch (error) {
                        console.error("Failed to load Firebase Analytics dynamically:", error);
                        // Decide how to proceed - maybe skip analytics logging
                    }
                 } else {
                    analytics = app.analytics();
                 }
            }

            console.log("Firebase ready, executing callback...");
            try {
                await callback();
            } catch (error) {
                 console.error("Error during Firebase-dependent callback execution:", error.message, error.stack);
                 // Potentially show an error message to the user
            }
        }

        // User Data Management
        async function initializeUserData() {
            if (!telegramUser || !telegramUser.id) {
                console.warn("Cannot initialize user data: No valid Telegram user available");
                return;
            }
            if (!firebaseInitialized || !db) {
                console.error("Firestore not initialized. Cannot initialize user data.");
                return;
            }
            const userIdStr = telegramUser.id.toString();
            const userDocRef = db.collection('userData').doc(userIdStr);
            const rankingDocRef = db.collection('users').doc(userIdStr); // Assumes 'users' collection for ranking

            try {
                const doc = await userDocRef.get();
                if (!doc.exists) {
                    const initialData = {
                        gems: 0,
                        usdt: 0,
                        ton: 0,
                        referrals: 0, // Use 'referrals' for count of people referred
                        inviteRecords: [], // Store details of referred users
                        totalCreditsEarnedFromInvites: 0, // Store raw credits earned
                        landPieces: 0,
                        foxMedals: 0,
                        isReferred: false,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        claimedQuests: [], // Store IDs of completed one-time quests
                        adProgress: {}, // Store progress for multi-step ad quests { questId: { watched: N, claimed: bool, lastClaimed: timestamp } }
                        walletAddress: null
                    };
                    await userDocRef.set(initialData);
                    console.log("New user data document created in userData");

                    // Initialize ranking data only if 'users' collection is used
                    const rankingData = {
                        username: telegramUser.username || telegramUser.first_name || 'Anonymous',
                        foxMedals: 0,
                        photoUrl: telegramUser.photo_url || 'https://via.placeholder.com/40/808080/000000?text=U'
                        // Add any other fields needed for ranking
                    };
                    await rankingDocRef.set(rankingData, { merge: true }); // Use merge to avoid overwriting existing fields if any
                    console.log("New user data initialized in users collection for ranking");


                    if (analytics) {
                         analytics.logEvent('user_signup', { userId: userIdStr });
                    } else {
                         console.warn("Analytics not available for signup event.");
                    }
                    console.log("New user data initialized");
                } else {
                    console.log("Existing user data found.");
                    // Ensure essential fields exist if migrating older data structures
                    const currentData = doc.data();
                    const updates = {};
                    if (currentData.claimedQuests === undefined) updates.claimedQuests = [];
                    if (currentData.adProgress === undefined) updates.adProgress = {};
                    if (currentData.inviteRecords === undefined) updates.inviteRecords = [];
                     if (currentData.totalCreditsEarnedFromInvites === undefined) updates.totalCreditsEarnedFromInvites = 0; // Add if missing


                    if (Object.keys(updates).length > 0) {
                        await userDocRef.update(updates);
                        console.log("User data schema updated with missing fields.");
                    }
                }
                await updateUserStatsUI(); // Update UI after ensuring data exists
            } catch (error) {
                console.error("Error initializing/checking user data:", error.message, error.stack);
            }
        }

        async function updateUserStatsUI() {
            if (!telegramUser || !telegramUser.id) {
                 console.warn("Cannot update UI: No valid Telegram user.");
                 return;
            }
            if (!firebaseInitialized || !db) {
                console.error("Firestore not initialized. Cannot update user stats UI.");
                return;
            }
            const userIdStr = telegramUser.id.toString();
            try {
                const userDoc = await db.collection('userData').doc(userIdStr).get();
                if (!userDoc.exists) {
                     console.warn("User data not found, cannot update UI. Initializing...");
                     await initializeUserData(); // Try to initialize if missing
                     return; // Exit and let initialization handle the first UI update
                }

                const data = userDoc.data();
                document.getElementById('gems').textContent = data.gems || 0;
                document.getElementById('usdt').textContent = (data.usdt || 0).toFixed(4);
                document.getElementById('ton').textContent = (data.ton || 0).toFixed(4);
                document.getElementById('wallet-usdt').textContent = (data.usdt || 0).toFixed(4);
                document.getElementById('wallet-ton').textContent = (data.ton || 0).toFixed(4);
                console.log("User stats UI updated successfully");
            } catch (error) {
                console.error("Error updating user stats UI:", error.message, error.stack);
            }
        }

        // Fetch and Update Earn Section (Quests) with Enhanced Debugging & Zero Reward Logic
        async function updateEarnSectionUI() {
            try {
                if (!firebaseInitialized || !db) {
                    console.log("[DEBUG] Firebase not initialized for Earn section, attempting to initialize...");
                    const success = await initializeFirebase();
                    if (!success) {
                        throw new Error("Failed to initialize Firebase after retries for Earn section");
                    }
                    console.log("[DEBUG] Firebase initialized successfully for Earn section");
                }

                let userData = {}; // Default empty object
                if (telegramUser && telegramUser.id && firebaseInitialized && db) {
                    const userDoc = await db.collection('userData').doc(telegramUser.id.toString()).get();
                    if (userDoc.exists) {
                         userData = userDoc.data();
                         // Ensure necessary fields exist on userData fetched
                         userData.adProgress = userData.adProgress || {};
                         userData.claimedQuests = userData.claimedQuests || [];
                    } else {
                        console.warn("[DEBUG] User data not found for Earn section. May need initialization.");
                        // Initialize if necessary, or handle the case where user data might not be ready yet
                        await initializeUserData(); // Attempt initialization
                        // Re-fetch after initialization attempt
                        const refetchedDoc = await db.collection('userData').doc(telegramUser.id.toString()).get();
                         if (refetchedDoc.exists) userData = refetchedDoc.data();
                         userData.adProgress = userData.adProgress || {};
                         userData.claimedQuests = userData.claimedQuests || [];
                    }
                } else {
                    console.warn("[DEBUG] Cannot fetch user data for Earn section: Invalid user or Firebase state.");
                    // Handle UI appropriately, maybe show a loading state or message
                     document.getElementById('daily-quest-list').innerHTML = '<li>Loading user data...</li>';
                     document.getElementById('basic-quest-list').innerHTML = '<li>Loading user data...</li>';
                    return; // Exit if we can't get user data
                }


                // Fetch Daily Quests
                console.log("[DEBUG] Starting daily quests fetch...");
                const dailyQuestsSnapshot = await db.collection('quests').doc('daily').get({ source: 'server' });
                const dailyQuestsRaw = dailyQuestsSnapshot.exists ? dailyQuestsSnapshot.data() : {};
                const dailyQuests = dailyQuestsRaw.tasks || [];
                const validatedDailyQuests = dailyQuests.map(quest => ({ /* validation as before */
                     id: quest.id || Math.random().toString(36).substring(7),
                     title: quest.title || "Untitled Quest",
                     icon: quest.icon || 'https://via.placeholder.com/30/FFFFFF/000000?text=Q',
                     reward: Number(quest.reward) || 0,
                     action: quest.action || 'GO',
                     link: quest.link || '',
                     type: quest.type || 'default' // Add type for consistency if needed
                }));
                const dailyQuestList = document.getElementById('daily-quest-list');
                const dailyQuestCount = document.getElementById('daily-quest-count');
                if (!dailyQuestList || !dailyQuestCount) throw new Error("Required DOM elements missing for daily quests");
                dailyQuestCount.textContent = validatedDailyQuests.length;
                dailyQuestList.innerHTML = validatedDailyQuests.length === 0 ? `<li><p>No daily quests available</p></li>` : validatedDailyQuests.map(quest => {
                    const isClaimed = userData.claimedQuests?.includes(quest.id); // Check general claimedQuests
                    const buttonText = isClaimed ? 'Claimed' : quest.action;
                    const buttonClass = isClaimed ? 'claimed-button' : 'go-button';
                    const buttonStyle = isClaimed ? 'background: #ccc; cursor: default;' : 'background: linear-gradient(to right, #ff00ff, #ff6666);';
                    const rewardDisplay = quest.reward > 0 ? `
                        <img src="assets/icons/gem.png" alt="Gem">
                        <span>+${quest.reward}</span>` : '';
                    return `
                        <li class="quest-item" data-quest-id="${quest.id}" data-quest-type="${quest.type}" data-quest-reward="${quest.reward}">
                            <img src="${quest.icon}" alt="${quest.title}" onerror="this.src='https://via.placeholder.com/30/FFFFFF/000000?text=Q'">
                            <span>${quest.title}</span>
                            <div class="quest-reward">
                                ${rewardDisplay}
                                <button class="${buttonClass}" data-quest-link="${quest.link}" data-quest-title="${quest.title}" style="${buttonStyle}" ${isClaimed ? 'disabled' : ''}>${buttonText}</button>
                            </div>
                        </li>`;
                }).join('');


                 // Fetch Basic Quests
                console.log("[DEBUG] Starting basic quests fetch...");
                const basicQuestsSnapshot = await db.collection('quests').doc('basic').get({ source: 'server' });
                const basicQuestsRaw = basicQuestsSnapshot.exists ? basicQuestsSnapshot.data() : {};
                const basicQuests = basicQuestsRaw.tasks || [];
                const validatedBasicQuests = basicQuests.map(quest => ({ /* validation */
                     id: quest.id || Math.random().toString(36).substring(7),
                     title: quest.title || "Untitled Quest",
                     icon: quest.icon || 'https://via.placeholder.com/30/FFFFFF/000000?text=Q',
                     reward: Number(quest.reward) || 0,
                     action: quest.action || 'GO',
                     link: quest.link || '',
                     type: quest.type || 'default', // Ensure type exists
                     adLimit: quest.adLimit || 0,
                     adType: quest.adType || 'rewarded_interstitial'
                }));
                const basicQuestList = document.getElementById('basic-quest-list');
                const basicQuestCount = document.getElementById('basic-quest-count');
                 if (!basicQuestList || !basicQuestCount) throw new Error("Required DOM elements missing for basic quests");
                 basicQuestCount.textContent = validatedBasicQuests.length;

                 // Current time for cooldown check
                const currentTime = new Date(); // Use client time for cooldown checks

                // *** MODIFIED BASIC QUEST RENDERING LOGIC ***
                basicQuestList.innerHTML = validatedBasicQuests.length === 0 ? `
                    <li class="no-quests">
                        <p>No basic quests available</p>
                    </li>
                ` : validatedBasicQuests.map(quest => {
                    // Check if the quest is already marked as completed in claimedQuests (used for zero-reward or simple link quests)
                    const isCompletedGeneral = userData.claimedQuests?.includes(quest.id);

                    let buttonText, buttonClass, buttonStyle, isDisabled = false;
                    let rewardDisplay = ''; // To hold reward/progress HTML

                    if (quest.type === 'ads' && quest.reward === 0) {
                        // --- Handling for Zero-Reward Ad Quests ---
                        if (isCompletedGeneral) {
                            buttonText = 'Completed';
                            buttonClass = 'claimed-button';
                            buttonStyle = 'background: #ccc; cursor: default;';
                            isDisabled = true;
                        } else {
                            buttonText = quest.action || 'Watch Ad'; // Use action text or default
                            buttonClass = 'go-button'; // Use the 'go' style
                            buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);';
                            isDisabled = false;
                        }
                        // No reward display for these quests
                        rewardDisplay = '';

                    } else if (quest.type === 'ads') {
                        // --- Handling for Original Ad Quests WITH Rewards ---
                        const adProgress = userData.adProgress[quest.id] || { watched: 0, claimed: false, lastClaimed: null };
                        const isTaskCompleted = adProgress.watched >= quest.adLimit;
                        const isTaskClaimed = adProgress.claimed; // Use the specific 'claimed' flag for reward tasks
                        const lastClaimedTime = adProgress.lastClaimed ? new Date(adProgress.lastClaimed) : null;
                        const timeSinceLastClaim = lastClaimedTime ? currentTime.getTime() - lastClaimedTime.getTime() : Infinity; // Use getTime() for comparison
                        const cooldownPeriod = 3600000; // 1 hour in milliseconds
                        const isCooldownOver = timeSinceLastClaim >= cooldownPeriod;

                        // Reset logic: If claimed and cooldown is over, reset the task
                        if (isTaskClaimed && isCooldownOver) {
                            console.log(`[DEBUG] Resetting reward ad quest ${quest.id} as cooldown is over`);
                            // Perform the Firestore update asynchronously, don't wait for it here to avoid blocking UI render
                            db.collection('userData').doc(telegramUser.id.toString()).update({
                                [`adProgress.${quest.id}`]: { watched: 0, claimed: false, lastClaimed: null }
                            }).then(() => {
                                console.log(`[DEBUG] Reward Quest ${quest.id} reset in Firestore`);
                            }).catch(error => {
                                console.error(`[ERROR] Failed to reset reward quest ${quest.id}:`, error.message);
                            });
                            // Update local adProgress to reflect reset immediately for this render cycle
                            adProgress.watched = 0;
                            adProgress.claimed = false; // Mark as not claimed locally for button state
                        }


                        if (isTaskClaimed && !isCooldownOver) { // Still claimed and in cooldown
                            const timeLeft = Math.ceil((cooldownPeriod - timeSinceLastClaim) / 60000); // Minutes left
                            buttonText = `Wait ${timeLeft}m`;
                            buttonClass = 'claimed-button';
                            buttonStyle = 'background: #ccc; cursor: default;';
                            isDisabled = true;
                        } else if (isTaskCompleted && !isTaskClaimed) { // Completed watch count AND not yet claimed (or was reset)
                            buttonText = 'Claim';
                            buttonClass = 'claim-button active';
                            buttonStyle = 'background: linear-gradient(to right, #00ff00, #66ff66);';
                            isDisabled = false;
                        } else { // Not completed watch count OR claimed+reset (needs watching again)
                            buttonText = quest.action || 'Watch Ad';
                            buttonClass = 'go-button';
                            buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);';
                            // Disable if claimed and cooldown is not over (handled in the first 'if' block)
                            isDisabled = isTaskClaimed && !isCooldownOver;
                        }

                        // Show reward and progress only for quests with rewards > 0
                        if (quest.reward > 0) {
                            rewardDisplay = `
                                <img src="assets/icons/gem.png" alt="Gem">
                                <span>+${quest.reward}</span>
                                <span class="progress">${adProgress.watched}/${quest.adLimit}</span>
                            `;
                        } else {
                             rewardDisplay = ''; // Should not happen if reward > 0 check is correct, but safe fallback
                        }

                    } else {
                        // --- Handling for Non-Ad Quests (e.g., Link clicks) ---
                        if (isCompletedGeneral) {
                            buttonText = 'Claimed';
                            buttonClass = 'claimed-button';
                            buttonStyle = 'background: #ccc; cursor: default;';
                            isDisabled = true;
                        } else {
                            buttonText = quest.action || 'GO';
                            buttonClass = 'go-button';
                            buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);';
                            isDisabled = false;
                        }
                        // Show reward if it's greater than 0
                        if (quest.reward > 0) {
                             rewardDisplay = `
                                <img src="assets/icons/gem.png" alt="Gem">
                                <span>+${quest.reward}</span>
                             `;
                        } else {
                             rewardDisplay = ''; // No reward display if 0
                        }
                    }

                    // Construct the final list item HTML
                    return `
                        <li class="quest-item" data-quest-id="${quest.id}" data-quest-type="${quest.type}" data-ad-limit="${quest.adLimit}" data-ad-type="${quest.adType}" data-quest-reward="${quest.reward}">
                            <img src="${quest.icon}" alt="${quest.title}" onerror="this.src='https://via.placeholder.com/30/FFFFFF/000000?text=Q'">
                            <span>${quest.title}</span>
                            <div class="quest-reward">
                                ${rewardDisplay} {/* Reward/Progress display logic handled above */}
                                <button class="${buttonClass}" data-quest-link="${quest.link}" data-quest-title="${quest.title}" style="${buttonStyle}" ${isDisabled ? 'disabled' : ''}>${buttonText}</button>
                            </div>
                        </li>
                    `;
                }).join('');
                // *** END OF MODIFIED BASIC QUEST RENDERING LOGIC ***


                console.log("[DEBUG] Earn section UI update completed successfully");

            } catch (error) {
                console.error("[ERROR] Failed to update earn section UI:", {
                    message: error.message,
                    stack: error.stack
                });

                // Basic error display in quest lists
                const dailyQuestList = document.getElementById('daily-quest-list');
                const basicQuestList = document.getElementById('basic-quest-list');
                const errorHtml = `<li class="error"><p>Failed to load quests. Please try again later.</p></li>`;
                if (dailyQuestList) dailyQuestList.innerHTML = errorHtml;
                if (basicQuestList) basicQuestList.innerHTML = errorHtml;
            }
        } // End of updateEarnSectionUI


        // Referral System
        function generateReferralLink() {
            if (!telegramUser || !telegramUser.id) {
                 console.warn("Cannot generate referral link: No user ID.");
                 return; // Exit if no user ID
            }
            const botUsername = 'fourgobot'; // Make sure this is your bot's username
            const referralLink = `https://t.me/${botUsername}?start=ref_${telegramUser.id}`;
            const inviteButton = document.querySelector('.invite-friend');
            const copyButton = document.querySelector('.copy-link');
            if (inviteButton) inviteButton.setAttribute('data-link', referralLink);
            if (copyButton) copyButton.setAttribute('data-link', referralLink);
            console.log("Referral link generated:", referralLink);
        }

        async function handleReferral() {
            if (!telegramUser || !telegramUser.id) {
                 console.warn("Cannot handle referral: No user ID.");
                 return;
            }
            if (!firebaseInitialized || !db) {
                console.error("Firestore not initialized. Cannot handle referral.");
                return;
            }

            let startParam = null;
            try {
                 // Check if Telegram WebApp and initData are available
                 if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe) {
                     startParam = window.Telegram.WebApp.initDataUnsafe.start_param;
                 } else {
                      console.warn("Telegram WebApp initData not available for referral check.");
                      // Maybe get param from URL for testing? const urlParams = new URLSearchParams(window.location.search); startParam = urlParams.get('start_param');
                 }
            } catch (error) {
                 console.error("Error accessing Telegram start_param:", error);
                 return; // Exit if we can't get the parameter
            }


            if (startParam && startParam.startsWith('ref_')) {
                const referrerId = startParam.split('_')[1];
                const currentUserId = telegramUser.id.toString();

                // Prevent self-referral
                if (referrerId === currentUserId) {
                    console.log("User tried to self-refer.");
                    return;
                }

                const userDocRef = db.collection('userData').doc(currentUserId);
                const referrerDocRef = db.collection('userData').doc(referrerId);

                try {
                    const userDoc = await userDocRef.get();
                    // Ensure userDoc exists and check isReferred field
                    if (!userDoc.exists) {
                         console.warn("Current user document doesn't exist yet for referral check. Initializing...");
                         await initializeUserData(); // Initialize first
                         // After initialization, the isReferred flag will be false, so proceed
                    } else if (userDoc.data().isReferred === true) {
                         console.log("User has already been referred.");
                         return; // Already referred, do nothing
                    }


                    // --- Proceed with applying referral ---
                    // Use a transaction to ensure atomicity if needed, though separate updates might be okay here
                    const batch = db.batch(); // Use batch for atomicity

                    // Mark current user as referred
                    batch.update(userDocRef, { isReferred: true });

                     // Prepare data for referrer update
                     const creditsPerReferral = 10; // Configurable: Credits given per referral
                     const gemsPerReferral = 50; // Configurable: Gems given per referral (optional)

                     const newRecord = {
                         userId: currentUserId, // Store referred user's ID if needed
                         username: telegramUser.username || telegramUser.first_name || `User_${currentUserId.substring(0,4)}`,
                         joinTime: new Date().toISOString().split('.')[0].replace('T', ' '), // Format timestamp
                         credit: creditsPerReferral // Store credits awarded for this specific referral
                     };

                     // Update referrer's data: increment counts and add record
                     batch.update(referrerDocRef, {
                         referrals: firebase.firestore.FieldValue.increment(1), // Increment count
                         gems: firebase.firestore.FieldValue.increment(gemsPerReferral), // Increment gems
                         totalCreditsEarnedFromInvites: firebase.firestore.FieldValue.increment(creditsPerReferral), // Increment total credits
                         inviteRecords: firebase.firestore.FieldValue.arrayUnion(newRecord) // Add detailed record
                     });


                    // Commit the batch update
                    await batch.commit();


                    if (analytics) {
                         analytics.logEvent('referral_success', { referrerId: referrerId, newUserId: currentUserId });
                    }
                    console.log(`Referral handled successfully: User ${currentUserId} referred by ${referrerId}`);

                } catch (error) {
                    // Check if error is due to referrer not existing
                    if (error.code === 'not-found' || (error.message && error.message.includes("No document to update"))) {
                         console.warn(`Referrer document (${referrerId}) not found. Cannot apply referral bonus.`);
                         // Mark current user as referred anyway? Or revert? Decided to mark as referred.
                         try { await userDocRef.update({ isReferred: true }); } catch (e) {}
                    } else {
                        console.error("Error handling referral transaction:", error.message, error.stack);
                    }
                }
            }
        }


        async function updateInviteSectionUI() {
            if (!telegramUser || !telegramUser.id) {
                 console.warn("Cannot update invite UI: No valid user.");
                 return;
            }
            if (!firebaseInitialized || !db) {
                console.error("Firestore not initialized. Cannot update invite section UI.");
                return;
            }
            const userIdStr = telegramUser.id.toString();
            try {
                const userDoc = await db.collection('userData').doc(userIdStr).get();
                 if (!userDoc.exists) {
                      console.warn("User data not found for invite section.");
                      // Display loading or default state
                      document.getElementById('my-invite').textContent = `My Invite: 0`;
                      document.getElementById('total-credit').textContent = `Total Credit ! : 0`;
                      document.getElementById('invite-record-title').textContent = `Invite Record (0)`;
                      document.querySelector('.invite-record .record-list').innerHTML = `<div class="no-frens"><img src="assets/icons/nofrens.png" alt="No Frens"><p>Loading invites...</p></div>`;
                      return;
                 }

                const data = userDoc.data();
                const referrals = data.referrals || 0; // Count of people invited
                const totalCredit = data.totalCreditsEarnedFromInvites || 0; // Total credits accumulated
                const inviteRecords = data.inviteRecords || []; // Array of invite details

                document.getElementById('my-invite').textContent = `My Invite: ${referrals}`;
                // Display the accumulated credits, not referrals * 10
                document.getElementById('total-credit').textContent = `Total Credit ! : ${totalCredit}`;
                document.getElementById('invite-record-title').textContent = `Invite Record (${inviteRecords.length})`; // Use length of records array

                const recordList = document.querySelector('.invite-record .record-list');
                const claimRecordList = document.querySelector('.record-section'); // Assuming this shows claim history, not frens list

                // Display Invite Records
                if (inviteRecords.length === 0) {
                     recordList.innerHTML = `
                         <div class="no-frens">
                             <img src="assets/icons/nofrens.png" alt="No Frens">
                             <p>No invites yet</p>
                         </div>`;
                 } else {
                     // Ensure header is present before adding items
                     recordList.innerHTML = `
                         <div class="record-header">
                             <span>User</span>
                             <span>Join Time</span>
                             <span>Credit</span>
                         </div>
                         ${inviteRecords.map(record => `
                             <div class="record-item">
                                 <img src="https://via.placeholder.com/40/808080/000000?text=${(record.username || 'U')[0]}" alt="${record.username || 'User'}">
                                 <div class="user-info">
                                     <span>${record.username || 'Invited User'}</span>
                                     <small>${record.joinTime || 'N/A'}</small>
                                 </div>
                                 <span class="credit">${record.credit || 0}</span>
                             </div>`).join('')}`;
                 }

                // Update Claim Record Section (Placeholder - needs logic if it shows actual claims)
                 claimRecordList.innerHTML = `
                     <h3>Claim Record</h3>
                     <div class="no-frens">
                         <p>Claim history not implemented yet.</p>
                     </div>`;


                // Update Claim button state
                const claimButton = document.querySelector('.invite-section .claim-button');
                 const creditToUsdtRate = 10000; // 10,000 credits = 1 USDT
                 if (totalCredit >= creditToUsdtRate) {
                     claimButton.disabled = false;
                     claimButton.style.opacity = '1';
                     claimButton.textContent = 'Claim';
                 } else {
                     claimButton.disabled = true;
                     claimButton.style.opacity = '0.5';
                     claimButton.textContent = `Need ${creditToUsdtRate}`;
                 }


                console.log("Invite section UI updated successfully");
            } catch (error) {
                console.error("Error updating invite section UI:", error.message, error.stack);
                // Display error state in UI
                 document.getElementById('my-invite').textContent = `My Invite: Error`;
                 document.getElementById('total-credit').textContent = `Total Credit ! : Error`;
            }
        }


        async function updateTopSectionUI() {
            if (!firebaseInitialized || !db) {
                console.error("Firestore not initialized. Cannot update top section UI.");
                return;
            }
            const rankingList = document.getElementById('ranking-list');
            if (!rankingList) {
                console.error("Ranking list element not found.");
                return;
            }
            rankingList.innerHTML = `<li class="no-rankings"><p>Loading rankings...</p></li>`; // Show loading state

            try {
                 // Assuming 'users' collection holds ranking data
                const rankingsSnapshot = await db.collection('users')
                    .orderBy('foxMedals', 'desc') // Order by medals descending
                    .limit(20) // Limit to top 20
                    .get();

                const rankings = [];
                rankingsSnapshot.forEach(doc => {
                    const data = doc.data();
                    rankings.push({
                        username: data.username || 'Anonymous',
                        foxMedals: data.foxMedals || 0,
                        photoUrl: data.photoUrl || 'https://via.placeholder.com/40/808080/000000?text=U'
                    });
                });

                if (rankings.length === 0) {
                    rankingList.innerHTML = `
                        <li class="no-rankings">
                            <p>No rankings available yet</p>
                        </li>`;
                } else {
                    rankingList.innerHTML = rankings.map((user, index) => `
                        <li class="ranking-item">
                             <span style="width: 30px; text-align: right; margin-right: 10px;">${index + 1}.</span> {/* Rank number */}
                            <img src="${user.photoUrl}" alt="${user.username}" onerror="this.src='https://via.placeholder.com/40/808080/000000?text=U'">
                            <span>${user.username}</span>
                            <div class="medal-count">
                                <span>${user.foxMedals}</span>
                                <img src="assets/icons/fox-medal.png" alt="Fox Medal">
                            </div>
                        </li>
                    `).join('');
                }

                console.log("Top section UI updated successfully");
            } catch (error) {
                console.error("Error updating top section UI:", error.message, error.stack);
                rankingList.innerHTML = `<li class="no-rankings"><p>Error loading rankings.</p></li>`; // Show error state
            }
        }

        async function updateWalletSectionUI() {
            if (!firebaseInitialized || !db) {
                console.error("Firestore not initialized. Cannot update wallet section UI.");
                return;
            }
             if (!telegramUser || !telegramUser.id) {
                  console.warn("Cannot update wallet UI: No valid user.");
                  return;
             }
            try {
                await updateUserStatsUI(); // Refreshes balances displayed
                await updateTransactionHistory(); // Refreshes transaction list
                 await updateWalletUI(); // Refreshes connect button state based on tonConnectUI
                console.log("Wallet section UI updated successfully");
            } catch (error) {
                console.error("Error updating wallet section UI:", error.message, error.stack);
            }
        }

        // Claim Credits Logic (Updated)
        document.querySelector('.invite-section .claim-button').addEventListener('click', async () => {
            if (!telegramUser || !telegramUser.id) {
                alert("User not authenticated. Please try again.");
                return;
            }
            if (!firebaseInitialized || !db) {
                console.error("Firestore not initialized. Cannot claim credits.");
                alert("Database not initialized. Please try again later.");
                return;
            }
            const userIdStr = telegramUser.id.toString();
            const userDocRef = db.collection('userData').doc(userIdStr);
            const claimButton = document.querySelector('.invite-section .claim-button');

            claimButton.disabled = true; // Disable button during process
            claimButton.textContent = 'Claiming...';

            try {
                await db.runTransaction(async (transaction) => {
                    const userDoc = await transaction.get(userDocRef);
                    if (!userDoc.exists) {
                        throw new Error("User data not found.");
                    }
                    const data = userDoc.data();
                    const currentCredits = data.totalCreditsEarnedFromInvites || 0;
                    const creditToUsdtRate = 10000; // 10,000 credits = 1 USDT

                    if (currentCredits < creditToUsdtRate) {
                        throw new Error(`You need ${creditToUsdtRate} credits to claim 1 USDT. You have ${currentCredits}.`);
                    }

                    const usdtToClaim = Math.floor(currentCredits / creditToUsdtRate);
                    const creditsToDeduct = usdtToClaim * creditToUsdtRate;

                    // Update user data within the transaction
                    transaction.update(userDocRef, {
                        usdt: firebase.firestore.FieldValue.increment(usdtToClaim),
                        totalCreditsEarnedFromInvites: firebase.firestore.FieldValue.increment(-creditsToDeduct)
                    });

                    // Optionally log the claim transaction details elsewhere if needed
                    // e.g., transaction.set(db.collection('creditClaims').doc(), { userId: userIdStr, usdtClaimed: usdtToClaim, creditsUsed: creditsToDeduct, timestamp: firebase.firestore.FieldValue.serverTimestamp() });

                    return usdtToClaim; // Return value to the calling code
                });

                 // Success case (after transaction completes)
                 const usdtClaimed = await db.runTransaction(/* ... */); // Re-run or get result if possible
                 alert(`Successfully claimed ${usdtClaimed} USDT!`); // Show exact amount claimed
                 if (analytics) {
                     analytics.logEvent('credit_claim_success', { userId: userIdStr, usdt: usdtClaimed });
                 }
                 // Refresh UI after successful claim
                 await updateUserStatsUI();
                 await updateInviteSectionUI();


            } catch (error) {
                console.error("Error claiming credits:", error.message, error.stack);
                alert("Failed to claim credits: " + error.message);
                 if (analytics) {
                      analytics.logEvent('credit_claim_failed', { userId: userIdStr, error: error.message });
                 }
            } finally {
                 // Re-enable button and update its state regardless of success/failure
                 await updateInviteSectionUI(); // This function will correctly set button state based on remaining credits
            }
        });


        // Chest Slider Logic & Data
        const chests = [ // Define chest data (consider fetching from Firestore later)
            { id: "wood", name: "Wood Chest", next: "Bronze", image: "assets/graphics/wood-chest.png", gemCost: 200, vip: 0, rewards: { usdtRange: [0.01, 0.05], landPieceChance: 0.1, foxMedalChance: 0.05 } },
            { id: "bronze", name: "Bronze Chest", next: "Silver", image: "assets/graphics/bronze-chest.png", gemCost: 500, vip: 1, rewards: { usdtRange: [0.03, 0.10], landPieceChance: 0.2, foxMedalChance: 0.1 } },
            { id: "silver", name: "Silver Chest", next: "Gold", image: "assets/graphics/silver-chest.png", gemCost: 1000, vip: 2, rewards: { usdtRange: [0.08, 0.25], landPieceChance: 0.35, foxMedalChance: 0.2 } },
            { id: "gold", name: "Gold Chest", next: "Master", image: "assets/graphics/gold-chest.png", gemCost: 2000, vip: 3, rewards: { usdtRange: [0.20, 0.60], landPieceChance: 0.5, foxMedalChance: 0.35 } },
            // Add Master, Legendary, Mythic definitions here...
            { id: "master", name: "Master Chest", next: "Legendary", image: "assets/graphics/master-chest.png", gemCost: 5000, vip: 4, rewards: { usdtRange: [0.50, 1.50], landPieceChance: 0.7, foxMedalChance: 0.5 } },
            { id: "legendary", name: "Legendary Chest", next: "Mythic", image: "assets/graphics/legendary-chest.png", gemCost: 10000, vip: 5, rewards: { usdtRange: [1.20, 3.00], landPieceChance: 0.9, foxMedalChance: 0.7 } },
            { id: "mythic", name: "Mythic Chest", next: "", image: "assets/graphics/mythic-chest.png", gemCost: 20000, vip: 6, rewards: { usdtRange: [2.50, 6.00], landPieceChance: 1.0, foxMedalChance: 0.9 } } // Example final chest
        ];

        let currentChestIndex = 0;
        const chestContainer = document.getElementById('chestContainer');
        const chestCostElement = document.getElementById('chestCost');
        const chestVipRequirementElement = document.getElementById('chestVipRequirement');
        const openChestButton = document.querySelector('.open-chest-button');

        // Function to build chest slider HTML dynamically
        function buildChestSlider() {
             if (!chestContainer) return;
             chestContainer.innerHTML = chests.map(chest => `
                 <div class="chest-item">
                     <div class="chest-title">
                         <h2>${chest.name}</h2>
                         ${chest.next ? `<span>Next: ${chest.next}</span>` : ''}
                     </div>
                     <div class="chest-image">
                         <img src="${chest.image}" alt="${chest.name}" onerror="this.src='https://via.placeholder.com/150/1a1a3d/FFFFFF?text=Chest'">
                     </div>
                     <div class="not-enough" id="not-enough-${chest.id}" style="display: none;"> {/* Hide initially */}
                         <span>NOT ENOUGH</span>
                         <img src="assets/icons/gem.png" alt="Gem">
                     </div>
                 </div>
             `).join('');
             updateChestUI(); // Initial UI update after building
        }

        // Function to update chest display and button state
        async function updateChestUI() {
             if (!chestContainer || !chestCostElement || !chestVipRequirementElement || !openChestButton || chests.length === 0) return;

             const chest = chests[currentChestIndex];
             chestContainer.style.transform = `translateX(-${currentChestIndex * 100}%)`; // Slide effect

             // --- Update Cost/VIP display ---
             chestCostElement.querySelector('span').textContent = chest.gemCost;
             if (chest.vip > 0) { // Requires VIP
                 chestVipRequirementElement.textContent = `NEED VIP ${chest.vip}`; // Assuming VIP levels start at 1
                 chestVipRequirementElement.style.display = 'block';
                 chestCostElement.style.display = 'none'; // Hide gem cost if VIP needed first
             } else { // No VIP requirement (or VIP 0)
                 chestVipRequirementElement.style.display = 'none';
                 chestCostElement.style.display = 'flex'; // Show gem cost
             }


            // --- Update Button State & Not Enough Gems Message ---
             let userGems = 0;
             let userVipLevel = 0; // Placeholder for user's VIP level (needs fetching)

             // Fetch user data (gems and potentially VIP level)
             if (telegramUser && telegramUser.id && firebaseInitialized && db) {
                 try {
                     const userDoc = await db.collection('userData').doc(telegramUser.id.toString()).get();
                     if (userDoc.exists) {
                         userGems = userDoc.data().gems || 0;
                         userVipLevel = userDoc.data().vipLevel || 0; // Assuming you store vipLevel
                     }
                 } catch (error) {
                     console.error("Error fetching user data for chest UI:", error);
                 }
             }

             let canOpen = true;
             let reason = "";

             // Check VIP level
             if (chest.vip > userVipLevel) {
                  canOpen = false;
                  reason = `Requires VIP ${chest.vip}`;
                  chestVipRequirementElement.style.color = '#ffcc00'; // Highlight unmet requirement
             } else {
                  chestVipRequirementElement.style.color = '#ccc'; // Normal color if met or not applicable
             }


             // Check Gem cost (only if VIP requirement is met or not applicable)
             const notEnoughGemsElement = document.getElementById(`not-enough-${chest.id}`);
             if (canOpen && userGems < chest.gemCost) {
                 canOpen = false;
                 reason = `Need ${chest.gemCost} Gems`;
                 if (notEnoughGemsElement) notEnoughGemsElement.style.display = 'flex'; // Show "NOT ENOUGH"
             } else {
                  if (notEnoughGemsElement) notEnoughGemsElement.style.display = 'none'; // Hide "NOT ENOUGH"
             }


             // Update button
             openChestButton.disabled = !canOpen;
             if (canOpen) {
                 openChestButton.textContent = `Open Chest (${chest.gemCost} Gems)`;
                 openChestButton.style.opacity = '1';
                 openChestButton.style.cursor = 'pointer';
                 openChestButton.style.background = 'linear-gradient(to right, #ff00ff, #ff6666)'; // Active gradient
             } else {
                 openChestButton.textContent = reason || `Open Chest (${chest.gemCost} Gems)`; // Show reason if disabled
                 openChestButton.style.opacity = '0.5';
                 openChestButton.style.cursor = 'not-allowed';
                 openChestButton.style.background = '#666'; // Disabled background
             }

             // Update slider navigation arrows
             document.querySelector('.nav-arrow.left').style.display = currentChestIndex === 0 ? 'none' : 'block';
             document.querySelector('.nav-arrow.right').style.display = currentChestIndex === chests.length - 1 ? 'none' : 'block';
        }

         // Added function to wrap chest UI update
        async function updateChestSectionUI() {
             await updateChestUI();
        }


        window.nextChest = function() {
            if (currentChestIndex < chests.length - 1) {
                currentChestIndex++;
                ensureFirebaseReady(updateChestUI); // Update UI after changing index
            }
        };

        window.prevChest = function() {
            if (currentChestIndex > 0) {
                currentChestIndex--;
                ensureFirebaseReady(updateChestUI); // Update UI after changing index
            }
        };

        window.openChest = async function() {
            if (!telegramUser || !telegramUser.id) {
                alert("User not authenticated. Please try again.");
                return;
            }
            if (!firebaseInitialized || !db) {
                console.error("Firestore not initialized. Cannot open chest.");
                alert("Database not initialized. Please try again later.");
                return;
            }
             if (openChestButton.disabled) {
                 console.log("Open chest button is disabled.");
                 return; // Prevent action if button is disabled
             }

            const userIdStr = telegramUser.id.toString();
            const userDocRef = db.collection('userData').doc(userIdStr);
            const rankingDocRef = db.collection('users').doc(userIdStr); // For updating medals in ranking
            const chest = chests[currentChestIndex];

             openChestButton.disabled = true; // Disable button during operation
             openChestButton.textContent = 'Opening...';

            try {
                // Use a transaction for atomicity (deduct gems, add rewards)
                 const results = await db.runTransaction(async (transaction) => {
                     const userDoc = await transaction.get(userDocRef);
                     if (!userDoc.exists) throw new Error("User data not found.");

                     const userData = userDoc.data();
                     const currentGems = userData.gems || 0;
                     const currentVipLevel = userData.vipLevel || 0; // Assuming VIP level is stored

                     // Final checks within transaction
                     if (chest.vip > currentVipLevel) throw new Error(`Requires VIP ${chest.vip}`);
                     if (currentGems < chest.gemCost) throw new Error(`Not enough Gems. Need ${chest.gemCost}, have ${currentGems}.`);

                     // Calculate Rewards
                     const rewardsConfig = chest.rewards;
                     let usdtReward = 0;
                     let landPieceReward = 0;
                     let foxMedalReward = 0;

                     // USDT (random within range)
                     if (rewardsConfig.usdtRange) {
                          usdtReward = Math.random() * (rewardsConfig.usdtRange[1] - rewardsConfig.usdtRange[0]) + rewardsConfig.usdtRange[0];
                          usdtReward = parseFloat(usdtReward.toFixed(4)); // Format to 4 decimal places
                     }
                     // Land Piece (based on chance)
                     if (rewardsConfig.landPieceChance && Math.random() < rewardsConfig.landPieceChance) {
                          landPieceReward = 1;
                     }
                      // Fox Medal (based on chance)
                     if (rewardsConfig.foxMedalChance && Math.random() < rewardsConfig.foxMedalChance) {
                          foxMedalReward = 1;
                     }

                     // Prepare updates
                     const updates = {
                         gems: firebase.firestore.FieldValue.increment(-chest.gemCost),
                         usdt: firebase.firestore.FieldValue.increment(usdtReward),
                         landPieces: firebase.firestore.FieldValue.increment(landPieceReward),
                         foxMedals: firebase.firestore.FieldValue.increment(foxMedalReward)
                     };

                     // Update user data
                     transaction.update(userDocRef, updates);

                      // Update ranking data if medals were awarded
                      if (foxMedalReward > 0) {
                           transaction.set(rankingDocRef, { // Use set with merge to handle potentially missing doc
                                foxMedals: firebase.firestore.FieldValue.increment(foxMedalReward)
                           }, { merge: true });
                      }

                     // Return the rewards calculated
                     return { usdt: usdtReward, land: landPieceReward, medal: foxMedalReward };
                 });


                 // Transaction successful
                 let rewardMessage = `Opened ${chest.name}! Rewards:`;
                 if (results.usdt > 0) rewardMessage += `\n- ${results.usdt.toFixed(4)} USDT`;
                 if (results.land > 0) rewardMessage += `\n- ${results.land} Land Piece`;
                 if (results.medal > 0) rewardMessage += `\n- ${results.medal} Fox Medal`;
                 if (results.usdt === 0 && results.land === 0 && results.medal === 0) rewardMessage += `\n- No special rewards this time.`;

                 alert(rewardMessage);

                 if (analytics) {
                     analytics.logEvent('chest_opened', {
                         chestId: chest.id,
                         chestName: chest.name,
                         userId: userIdStr,
                         usdtReward: results.usdt,
                         landReward: results.land,
                         medalReward: results.medal
                     });
                 }

                 // Refresh UI sections
                 await updateUserStatsUI();
                 await updateChestUI(); // Update button state and potentially "Not Enough" message
                 if (results.medal > 0) await updateTopSectionUI(); // Update rankings if medals changed


            } catch (error) {
                console.error("Error opening chest:", error.message, error.stack);
                alert("Failed to open chest: " + error.message);
                // Re-enable button after error
                 openChestButton.disabled = false;
                 await updateChestUI(); // Refresh UI to show correct state/reason
            }
             // No finally block needed for button re-enabling as updateChestUI handles it
        };

        // Call buildChestSlider on load after DOM is ready
        document.addEventListener('DOMContentLoaded', buildChestSlider);


        // *** MODIFIED CLICK EVENT LISTENER FOR QUESTS ***
        document.addEventListener('click', async (event) => {
            const button = event.target;
            if (!button.closest) return; // Ensure target has closest method
            const taskItem = button.closest('.quest-item');
            if (!taskItem || button.tagName !== 'BUTTON' || button.disabled) return; // Only handle enabled button clicks within quest items

            const questId = taskItem.dataset.questId;
            const reward = parseInt(taskItem.dataset.questReward); // Read reward from data attribute
            const questType = taskItem.dataset.questType;
            const adLimit = parseInt(taskItem.dataset.adLimit) || 0;
            const adType = taskItem.dataset.adType || 'rewarded_interstitial';
            const link = button.dataset.questLink;

            if (!firebaseInitialized || !db) {
                alert("Database not initialized. Please try again later.");
                return;
            }
            if (!telegramUser || !telegramUser.id) {
                 alert("User not identified. Please restart the app.");
                 return;
            }

            const userIdStr = telegramUser.id.toString();
            const userDocRef = db.collection('userData').doc(userIdStr);

            // --- Disable button temporarily ---
            button.disabled = true;
            const originalButtonText = button.textContent;
            button.textContent = 'Processing...';


            try {
                 // Fetch latest user data within the handler to avoid stale data issues
                 const userDoc = await userDocRef.get();
                 if (!userDoc.exists) {
                      throw new Error("User data could not be loaded.");
                 }
                 const userData = userDoc.data();
                 userData.adProgress = userData.adProgress || {};
                 userData.claimedQuests = userData.claimedQuests || [];

                 // --- Check if task is already completed/claimed based on latest data ---
                 const isZeroRewardAd = questType === 'ads' && reward === 0;
                 const isRewardAd = questType === 'ads' && reward > 0;
                 const isLinkQuest = questType !== 'ads'; // Assuming 'default' or other types are link-based

                 if (isZeroRewardAd && userData.claimedQuests.includes(questId)) {
                      console.log(`[DEBUG] Zero-reward ad quest ${questId} already completed.`);
                      throw new Error("Quest already completed."); // Throw error to stop processing
                 }
                 const adProgress = userData.adProgress[questId] || { watched: 0, claimed: false };
                 if (isRewardAd && adProgress.claimed) {
                      // Consider cooldown here if button wasn't disabled correctly
                     const lastClaimedTime = adProgress.lastClaimed ? new Date(adProgress.lastClaimed) : null;
                     const timeSinceLastClaim = lastClaimedTime ? new Date().getTime() - lastClaimedTime.getTime() : Infinity;
                     const cooldownPeriod = 3600000; // 1 hour
                     if (timeSinceLastClaim < cooldownPeriod) {
                          console.log(`[DEBUG] Reward ad quest ${questId} already claimed and in cooldown.`);
                          throw new Error("Quest is in cooldown.");
                     }
                     // If cooldown is over, it should have been reset, so this state might be less common here unless UI wasn't refreshed
                 }
                 if (isLinkQuest && userData.claimedQuests.includes(questId)) {
                      console.log(`[DEBUG] Non-ad quest ${questId} already claimed.`);
                      throw new Error("Quest already claimed.");
                 }
                 // --- End of completion check ---


                 // --- Handling Button Clicks ---

                 // 1. Claim button for ad-based quests WITH rewards
                 if (button.classList.contains('claim-button') && isRewardAd) {
                     if (adProgress.watched < adLimit) {
                         throw new Error("You need to watch all ads to claim this reward!");
                     }
                     const currentTime = new Date().toISOString();
                     await userDocRef.update({
                         gems: firebase.firestore.FieldValue.increment(reward), // Grant Gems
                         [`adProgress.${questId}`]: { // Update entire adProgress object for the quest
                             watched: adProgress.watched, // Keep watched count
                             claimed: true, // Mark as claimed
                             lastClaimed: currentTime // Set timestamp
                         }
                     });
                     alert(`Reward claimed! You earned ${reward} gems.`);
                     if (analytics) analytics.logEvent('ads_quest_reward_claimed', { questId, userId: userIdStr, reward });

                 }
                 // 2. GO button for ad-based quests (both reward and zero-reward)
                 else if (button.classList.contains('go-button') && (isZeroRewardAd || isRewardAd)) {
                     // Check if we need to watch an ad
                     const needsWatching = isZeroRewardAd || (isRewardAd && adProgress.watched < adLimit && !adProgress.claimed);

                     if (needsWatching) {
                         console.log(`[DEBUG] Showing ad for quest: ${questId}, Type: ${isZeroRewardAd ? 'Zero-Reward' : 'Reward'}`);
                         await showAd(adType); // Trigger the ad

                         // --- Update Firestore based on quest type AFTER ad success ---
                         if (isZeroRewardAd) {
                             // For Zero-Reward: Mark as completed by adding to claimedQuests
                             await userDocRef.update({
                                 claimedQuests: firebase.firestore.FieldValue.arrayUnion(questId)
                             });
                             console.log(`[DEBUG] Zero-reward ad quest ${questId} marked as completed.`);
                             alert(`Ad watched! Quest completed.`);
                             if (analytics) analytics.logEvent('ad_quest_watched', { questId, userId: userIdStr, reward: 0 });

                         } else { // isRewardAd
                             // For Reward Ads: Increment watch count in adProgress
                             const newWatched = adProgress.watched + 1;
                             await userDocRef.update({
                                 // Update only the 'watched' field within the specific quest's adProgress
                                 [`adProgress.${questId}.watched`]: newWatched
                             });
                             console.log("[DEBUG] Reward ad watched, progress updated:", newWatched);
                             if (newWatched >= adLimit) {
                                 alert("All ads watched! You can now claim your reward.");
                             } else {
                                 alert(`Ad watched! Progress: ${newWatched}/${adLimit}`);
                             }
                              if (analytics) analytics.logEvent('ad_quest_watched', { questId, userId: userIdStr, reward });
                         }
                     } else if (isRewardAd && adProgress.watched >= adLimit && !adProgress.claimed) {
                          // This case means watch limit reached, but claim button wasn't clicked yet (UI might need refresh)
                          alert("All ads watched! Click the 'Claim' button.");
                          // No Firestore update needed here, just inform user
                     } else {
                          // Should not typically reach here if completion checks are correct
                          console.warn("Unexpected state for ad quest button:", questId);
                     }

                 }
                 // 3. GO button for non-ad quests (link clicks)
                 else if (button.classList.contains('go-button') && isLinkQuest) {
                     console.log("[DEBUG] Handling non-ad (link) quest:", { questId, link });

                     // Open link first (user action)
                     if (link) {
                          console.log("[DEBUG] Redirecting to link:", link);
                          Telegram.WebApp.openTelegramLink(link); // Use Telegram API to open link
                     } else {
                          console.warn("Link quest has no link defined:", questId);
                          // Decide how to handle - complete anyway or show error? Assuming completion for now.
                     }


                     // --- Update Firestore AFTER link is opened ---
                     const updates = {
                         claimedQuests: firebase.firestore.FieldValue.arrayUnion(questId) // Always mark as completed
                     };
                     if (reward > 0) {
                         updates.gems = firebase.firestore.FieldValue.increment(reward); // Add gems only if reward > 0
                     }
                     await userDocRef.update(updates);

                     // Inform user
                     if (reward > 0) {
                         alert(`Quest completed! You earned ${reward} gems.`);
                     } else {
                          alert(`Quest completed!`); // Different message if no reward
                     }
                      if (analytics) analytics.logEvent('link_quest_completed', { questId, userId: userIdStr, reward });
                 } else {
                     // Button type not recognized or unexpected state
                     console.warn("Unhandled button click:", button.classList, questType, reward);
                      throw new Error("Unknown quest action."); // Prevent UI refresh if action unknown
                 }

                 // --- Refresh relevant UI sections AFTER successful action ---
                 await updateUserStatsUI();
                 await updateEarnSectionUI(); // Refresh the quest list specifically


            } catch (error) {
                 console.error("[ERROR] Error processing quest action:", error.message, error.stack);
                 alert("Action failed: " + error.message); // Show error to user
                 // Re-enable button and restore text after error
                 button.disabled = false;
                 button.textContent = originalButtonText;
            }
             // No finally block needed here as UI refresh handles the button state update on success,
             // and the catch block handles re-enabling on error.

        });
        // *** END OF MODIFIED CLICK EVENT LISTENER ***


        // Invite Section Interactions
        document.querySelector('.invite-friend').addEventListener('click', () => {
            const link = document.querySelector('.invite-friend').getAttribute('data-link');
            if (link) {
                 Telegram.WebApp.openTelegramLink(link);
            } else {
                 alert("Could not generate invite link. Please try again later.");
                 generateReferralLink(); // Try regenerating
            }
        });

        document.querySelector('.copy-link').addEventListener('click', () => {
            const link = document.querySelector('.copy-link').getAttribute('data-link');
             if (link && navigator.clipboard) {
                 navigator.clipboard.writeText(link).then(() => {
                     alert("Referral link copied to clipboard!");
                 }).catch(err => {
                      console.error("Failed to copy link:", err);
                      alert("Failed to copy link. Please copy manually.");
                 });
            } else if (link) {
                 // Fallback for environments without navigator.clipboard
                 alert(`Copy this link:\n${link}`);
            } else {
                 alert("Could not get invite link. Please try again later.");
                 generateReferralLink(); // Try regenerating
            }
        });


        // Function to show Monetag Ads with support for multiple ad types
        function showAd(adType) {
            return new Promise((resolve, reject) => {
                const maxWaitTime = 15000; // 15 seconds timeout
                const startTime = Date.now();

                console.log(`[DEBUG] Attempting to show ad of type: ${adType}`);
                debugLog(`[AD] Requesting ad type: ${adType}`); // Use debug console

                function checkSDK() {
                    // Check for the specific function for the given zone ID
                    if (window.show_9180370) {
                        console.log("[DEBUG] Monetag SDK loaded, triggering ad...");
                        debugLog(`[AD] SDK found (show_9180370), triggering...`);
                        try {
                            // The Monetag SDK function might return a promise or might not.
                            // Handle potential errors during the call itself.
                             window.show_9180370(); // Call the SDK function
                             // Since we don't know if it returns a reliable promise for completion/error,
                             // we'll assume success after a short delay, but log any immediate errors.
                             console.log(`[DEBUG] ${adType} ad triggered via SDK.`);
                             debugLog(`[AD] SDK function called for ${adType}. Assuming success shortly.`);
                             // Resolve after a delay to simulate ad display time if no promise is returned
                             setTimeout(() => {
                                 console.log(`[DEBUG] Assuming ${adType} ad completed after timeout.`);
                                 debugLog(`[AD] Assuming ${adType} completed.`);
                                 resolve();
                             }, 2000); // 2-second delay (adjust if needed)

                        } catch (error) {
                            console.error("[DEBUG] Failed to trigger Monetag ad via SDK call:", error.message);
                            debugLog(`[AD] Error calling SDK: ${error.message}`);
                            reject(error);
                        }
                    } else if (Date.now() - startTime < maxWaitTime) {
                        console.log("[DEBUG] Monetag SDK not loaded yet, retrying in 500ms...");
                        // Don't log retry attempts to debug console, too noisy
                        setTimeout(checkSDK, 500);
                    } else {
                        // SDK failed to load within timeout
                        console.warn("[DEBUG] Monetag SDK failed to load within 15 seconds.");
                        debugLog(`[AD] SDK (show_9180370) failed to load in ${maxWaitTime/1000}s.`);
                        reject(new Error("Ad SDK failed to load in time."));
                        // Removed simulation fallback to avoid confusion - just report failure.
                        // alert("Ad could not be loaded at this time.");
                    }
                }
                checkSDK();
            });
        } // End of showAd


        // Initialize App
        async function initApp() {
            try {
                console.log("Initializing app...");
                await initializeFirebase(); // Ensure Firebase is ready first
                 if (!firebaseInitialized) throw new Error("Firebase could not be initialized.");

                await initializeUserData(); // Setup user data in Firestore
                await handleReferral(); // Check for incoming referral link
                generateReferralLink(); // Create user's own referral link

                // --- Startup Ad Removed ---
                /* // REMOVED THE STARTUP AD CALL
                showAd('inApp').catch(error => {
                    console.error("Failed to show initial ad:", error.message);
                    debugLog(`[AD INIT FAILED] ${error.message}`);
                });
                */
                // --- End of Startup Ad Removal ---

                // Initialize TON Connect and Wallet System
                tonConnectUI = await initializeTonConnect();
                await initWalletSystem();

                // Initial UI refresh for the default section (Earn)
                await ensureFirebaseReady(updateEarnSectionUI);
                // Build chest slider HTML after DOM is ready (moved listener earlier)
                // buildChestSlider(); // Ensure this runs if DOMContentLoaded doesn't cover it


                 console.log("App initialization complete.");

            } catch (error) {
                console.error("App initialization failed:", error.message, error.stack);
                alert("Failed to initialize the app. Please refresh and try again. Error: " + error.message);
                 // Display error message prominently in the UI if possible
                 const mainContent = document.querySelector('.main-content');
                 if (mainContent) {
                      mainContent.innerHTML = `<div style="padding: 20px; text-align: center; color: #ffcc00;">
                          <h2>Initialization Error</h2>
                          <p>Could not start the application. Please try refreshing.</p>
                          <p><small>Details: ${error.message}</small></p>
                          </div>`;
                 }
            }
        } // End of initApp

        // Call initApp when the page loads and DOM is ready
        // Using DOMContentLoaded ensures HTML structure is available
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM loaded, starting initApp...");
            initApp(); // Start the main initialization sequence
        });


        // ====== TON CONNECT IMPLEMENTATION ====== //

        let tonConnectUI = null;

        // Debug logging helper
        function debugLog(message) {
            console.log(`[TON_CONNECT] ${message}`); // Prefix logs
            const debugConsole = document.getElementById('debugConsole');
            if (debugConsole) {
                debugConsole.innerHTML += `<div>${new Date().toLocaleTimeString()}: [TON] ${message}</div>`;
                debugConsole.scrollTop = debugConsole.scrollHeight;
            }
        }

        // Get wallet-related DOM elements
        function getWalletElements() {
            const elements = {
                connectButton: document.querySelector('.connect-button'),
                connectionStatus: document.getElementById('connection-status'),
                withdrawButtons: document.querySelectorAll('.withdraw-button'),
                walletSection: document.getElementById('wallet')
            };
            // debugLog(`Wallet elements check: connectButton=${!!elements.connectButton}, status=${!!elements.connectionStatus}`);
            return elements;
        }

        // Dynamically load a script with retries (re-use existing one if identical)
        // async function loadScript(src, retries = 3, delay = 1000) { ... } // Already defined above

        // Create TON Connect UI manually for version 0.0.14 (Fallback)
        function createManualTonConnectUI() {
            debugLog("Creating manual TON Connect UI fallback");
            let manualStatusChangeCallback = null;
            let manualConnected = false;
            let manualAccount = null;

            return {
                get connected() { return manualConnected; },
                get account() { return manualAccount; },

                connectWallet: async function() {
                    debugLog("Manual connect: Triggering wallet interaction (simulated)");
                    // Simulate opening external wallet - no guarantee of return
                    if (window.Telegram && window.Telegram.WebApp) {
                        Telegram.WebApp.openLink('ton://transfer/'); // Example TON link
                    }
                    // Simulate connection after a delay for demo - IN REALITY THIS IS NOT RELIABLE
                    // A proper solution would involve deep linking or App Clip / Instant App interaction
                    setTimeout(() => {
                         manualConnected = true;
                         manualAccount = { address: "MANUAL_FALLBACK_ADDRESS" }; // Placeholder
                         if (manualStatusChangeCallback) {
                              manualStatusChangeCallback(manualAccount);
                         }
                         debugLog("Manual connection simulated (fallback only)");
                         alert("Manual connection simulated. Address is placeholder.");
                    }, 5000);
                },

                disconnect: async function() {
                    debugLog("Manual disconnect");
                    manualConnected = false;
                    manualAccount = null;
                    if (manualStatusChangeCallback) {
                        manualStatusChangeCallback(null);
                    }
                },

                onStatusChange: function(callback) {
                    debugLog("Setting manual status change callback");
                    manualStatusChangeCallback = callback;
                    // Immediately call back with current status if already connected
                    if (manualConnected && manualStatusChangeCallback) {
                         manualStatusChangeCallback(manualAccount);
                    }
                },
                 // Add dummy methods if needed by other parts of the code
                 sendTransaction: async function(transaction) {
                     debugLog("Manual sendTransaction: Not implemented in fallback.");
                     alert("Transaction sending not available in manual fallback mode.");
                     throw new Error("sendTransaction not implemented in manual fallback");
                 }
            };
        }


        // Create TON Connect UI with inline script (Strategy 3)
        function createInlineScriptTonConnectUI() {
            debugLog("Attempting TON Connect UI via inline script loader");
            return new Promise((resolve) => {
                if (window.TonConnectUI) { // Check if somehow loaded already
                     debugLog("TonConnectUI already exists globally before inline script.");
                     resolve(new TonConnectUI({ manifestUrl: 'https://fourgo.app/tonconnect-manifest.json' }));
                     return;
                }

                const script = document.createElement('script');
                script.id = "ton-connect-inline-loader";
                script.innerHTML = `
                    (async function() {
                        console.log('[Inline Loader] Starting TON Connect UI load attempt...');
                        const cdnUrls = [
                            'https://unpkg.com/@tonconnect/ui@0.0.14/dist/tonconnect-ui.min.js',
                            'https://cdn.jsdelivr.net/npm/@tonconnect/ui@0.0.14/dist/tonconnect-ui.min.js'
                            // Add more CDNs or specific versions if needed
                        ];
                        let loaded = false;
                        for (const url of cdnUrls) {
                            if (loaded) break;
                            console.log('[Inline Loader] Trying URL: ' + url);
                            try {
                                await new Promise((resolve, reject) => {
                                    const scriptTag = document.createElement('script');
                                    scriptTag.src = url;
                                    scriptTag.async = true;
                                    scriptTag.onload = () => { console.log('[Inline Loader] Loaded from ' + url); loaded = true; resolve(); };
                                    scriptTag.onerror = (err) => { console.error('[Inline Loader] Failed to load from ' + url, err); reject(err); };
                                    document.head.appendChild(scriptTag);
                                });
                            } catch (e) { /* Error logged by onerror */ }
                        }
                        if (loaded && window.TonConnectUI) {
                             console.log('[Inline Loader] TON Connect UI loaded successfully.');
                            window.tonConnectLoadedByInline = true; // Flag for outer check
                        } else {
                             console.error('[Inline Loader] Failed to load TON Connect UI from all sources.');
                             window.tonConnectLoadedByInline = false;
                        }
                    })();
                `;
                document.head.appendChild(script);

                // Check periodically if the library loaded via inline script
                let checks = 0;
                const maxChecks = 20; // ~10 seconds
                const checkInterval = setInterval(() => {
                    checks++;
                    if (window.TonConnectUI && window.tonConnectLoadedByInline === true) {
                        clearInterval(checkInterval);
                        debugLog("TON Connect UI loaded via inline script initialization.");
                        try {
                            resolve(new TonConnectUI({ manifestUrl: 'https://fourgo.app/tonconnect-manifest.json' }));
                        } catch (uiError) {
                             debugLog(`Error initializing TonConnectUI after inline load: ${uiError.message}`);
                             resolve(createManualTonConnectUI()); // Fallback if init fails
                        }
                    } else if (checks >= maxChecks || window.tonConnectLoadedByInline === false) {
                        clearInterval(checkInterval);
                        debugLog("Inline script failed or timed out, falling back to manual implementation.");
                        resolve(createManualTonConnectUI());
                    }
                }, 500);
            });
        }


        // Initialize TON Connect with multiple strategies
        async function initializeTonConnect() {
            debugLog("Initializing TON Connect...");
            const manifestUrl = 'https://fourgo.app/tonconnect-manifest.json'; // Ensure this is correct and accessible

            try {
                // Strategy 1: Check if already available globally (e.g., from previous load)
                if (window.TonConnectUI) {
                    debugLog("TON Connect UI already available in window scope.");
                    // Ensure it's not just declared but can be instantiated
                    try {
                         return new TonConnectUI({ manifestUrl });
                    } catch(e) {
                         debugLog(`Error initializing existing TonConnectUI: ${e.message}. Proceeding to load.`);
                         // Clear the existing potentially broken reference
                         delete window.TonConnectUI;
                    }
                }

                // Strategy 2: Try loading from CDN directly using loadScript
                debugLog("Attempting load from CDN...");
                const cdnUrl = 'https://unpkg.com/@tonconnect/ui@0.0.14/dist/tonconnect-ui.min.js';
                try {
                    const loaded = await loadScript(cdnUrl, 2, 500); // Try CDN load quickly
                    if (loaded && window.TonConnectUI) {
                         debugLog("TON Connect UI loaded successfully from CDN.");
                         return new TonConnectUI({ manifestUrl });
                    }
                } catch (cdnError) {
                    debugLog(`CDN load failed: ${cdnError.message}. Trying inline loader.`);
                }

                // Strategy 3: Inline script loading as a more robust fallback
                debugLog("Attempting load via inline script...");
                const uiInstance = await createInlineScriptTonConnectUI();
                // createInlineScriptTonConnectUI returns an instance (real or manual fallback)
                if (uiInstance && typeof uiInstance.connectWallet === 'function') { // Check if it looks like a valid instance
                     // Check if it's the manual fallback (optional: handle differently if needed)
                     if (!window.TonConnectUI && uiInstance.account?.address === "MANUAL_FALLBACK_ADDRESS") {
                          debugLog("Using manual TON Connect fallback implementation.");
                     } else if (window.TonConnectUI){
                          debugLog("TON Connect UI initialized via inline script/CDN successfully.");
                     }
                     return uiInstance;
                } else {
                     debugLog("Inline script strategy failed unexpectedly. Using final manual fallback.");
                     return createManualTonConnectUI(); // Final fallback
                }


            } catch (error) {
                debugLog(`Critical TON Connect initialization error: ${error.message}`);
                debugLog("Falling back to manual TON Connect implementation due to error.");
                return createManualTonConnectUI(); // Fallback on any critical error
            }
        }


        // Update wallet UI based on connection status
        async function updateWalletUI() {
            const elements = getWalletElements();
            if (!elements.connectButton || !elements.connectionStatus) {
                debugLog("Wallet UI elements not found for update");
                return;
            }

            if (tonConnectUI && tonConnectUI.connected) {
                const walletAddress = tonConnectUI.account?.address || 'Connected (No Address)';
                const shortAddress = walletAddress.length > 10 ? `${walletAddress.substring(0, 6)}...${walletAddress.substring(walletAddress.length - 4)}` : walletAddress;

                elements.connectionStatus.textContent = `Connected: ${shortAddress}`;
                elements.connectionStatus.className = 'wallet-status connected';
                elements.connectButton.textContent = 'DISCONNECT';
                elements.connectButton.classList.add('connected');
                elements.withdrawButtons.forEach(btn => {
                    btn.disabled = false;
                    btn.style.background = '#00ff00'; // Enabled color
                    btn.style.cursor = 'pointer';
                });

                // Save connected address if available and valid
                if (tonConnectUI.account?.address) {
                    await Storage.setItem('walletAddress', tonConnectUI.account.address);
                     debugLog(`Wallet connected: ${tonConnectUI.account.address}`);
                } else {
                      debugLog(`Wallet connected, but address not available from tonConnectUI.account`);
                }

            } else {
                elements.connectionStatus.textContent = 'Disconnected';
                elements.connectionStatus.className = 'wallet-status disconnected';
                elements.connectButton.textContent = 'CONNECT TON WALLET';
                elements.connectButton.classList.remove('connected');
                elements.withdrawButtons.forEach(btn => {
                    btn.disabled = true;
                    btn.style.background = '#666'; // Disabled color
                     btn.style.cursor = 'not-allowed';
                });
                // Optionally clear saved address on disconnect
                // await Storage.setItem('walletAddress', null);
                debugLog("Wallet disconnected");
            }
             // Transaction history update is called separately in updateWalletSectionUI
        }


        // Handle wallet connection/disconnection button click
        async function handleConnectClick() {
            const elements = getWalletElements();
            if (!elements.connectButton) {
                debugLog("Connect button not found for click handler");
                return;
            }
             if (!tonConnectUI) {
                  debugLog("TON Connect UI not initialized, cannot connect/disconnect.");
                  alert("Wallet connection service is not ready. Please wait or refresh.");
                  return;
             }


            elements.connectButton.disabled = true; // Disable during action
            elements.connectButton.textContent = 'Processing...';

            try {
                if (tonConnectUI.connected) {
                    debugLog("Requesting disconnect...");
                    await tonConnectUI.disconnect();
                    debugLog("Wallet disconnected by user action.");
                } else {
                    debugLog("Requesting connect...");
                    // This opens the TON Connect modal or redirects
                    await tonConnectUI.connectWallet();
                    // Note: The actual connection happens asynchronously. The onStatusChange listener handles the UI update.
                    debugLog("Wallet connection requested. Waiting for user action and status change...");
                }
                // Let onStatusChange handle the UI update after action completes
                // await updateWalletUI(); // No longer call updateUI directly here
            } catch (error) {
                debugLog(`Wallet connect/disconnect error: ${error.message}`);
                alert(`Wallet action failed: ${error.message}`);
                 // Re-enable button after error if status didn't change
                 elements.connectButton.disabled = false;
                 // Restore button text based on potentially unchanged state
                 await updateWalletUI();
            } finally {
                // Re-enable button in most cases, status change will update text/state
                 // Small delay might be needed if disconnect is instant but UI update is slightly delayed
                 setTimeout(() => {
                    if (elements.connectButton.textContent === 'Processing...') {
                         // If text is still processing, force update UI state
                          updateWalletUI().finally(() => { elements.connectButton.disabled = false; });
                    } else {
                         elements.connectButton.disabled = false;
                    }
                 }, 500);
            }
        }

        // Initialize wallet system
        async function initWalletSystem() {
            debugLog("Initializing wallet system...");
             if (!tonConnectUI) {
                  debugLog("Cannot initialize wallet system: TON Connect UI is not ready.");
                  // Display an error in the wallet section?
                  const statusEl = document.getElementById('connection-status');
                  if (statusEl) statusEl.textContent = 'Wallet Error';
                  return;
             }

            const elements = getWalletElements();
            if (!elements.connectButton) {
                debugLog("Connect button not found during wallet init");
                return;
            }

            try {
                // Setup TON Connect status listener
                tonConnectUI.onStatusChange(
                    async (walletInfo) => { // walletInfo can be null or an object with account details
                        debugLog(`Wallet status changed: ${walletInfo ? `Connected (${walletInfo.account?.address})` : 'Disconnected'}`);
                        await updateWalletUI(); // Update UI whenever connection status changes
                    },
                    (error) => { // Add error callback for onStatusChange
                        debugLog(`Wallet status change error: ${error.message}`);
                         // Handle potential errors during status updates, e.g., network issues
                         alert(`Wallet connection update error: ${error.message}`);
                    }
                );


                // Add connect button listener only once
                 // Remove previous listener if any, to prevent duplicates during potential re-init
                 elements.connectButton.removeEventListener('click', handleConnectClick);
                 elements.connectButton.addEventListener('click', handleConnectClick);


                // Initial UI update based on current state
                await updateWalletUI();

                // Setup withdraw button listeners
                elements.withdrawButtons.forEach(button => {
                     // Remove previous listener if any
                     button.removeEventListener('click', withdrawButtonClickHandler);
                     button.addEventListener('click', withdrawButtonClickHandler);
                });


                debugLog("Wallet system initialized successfully");
            } catch (error) {
                debugLog(`Wallet system init failed: ${error.message}`);
                 // Display error in UI
                 const statusEl = document.getElementById('connection-status');
                  if (statusEl) statusEl.textContent = 'Wallet Init Error';
            }
        }
         // Named handler for withdraw button clicks
         function withdrawButtonClickHandler(event) {
             showWithdrawModal(event.target.closest('.balance-card'));
         }


        // Show withdraw modal
        function showWithdrawModal(card) {
            const modal = document.getElementById('withdraw-modal');
            if (!modal || !card) return;

            const amountInput = document.getElementById('withdraw-amount');
            const availableBalanceEl = document.getElementById('available-balance');
            const currencySpan = document.getElementById('currency');
            const feeSpan = document.getElementById('withdraw-fee');
            const feeCurrencySpan = document.getElementById('fee-currency');
            const confirmButton = document.getElementById('confirm-withdraw');
            const cancelButton = document.getElementById('cancel-withdraw');

            const isUsdt = card.classList.contains('usdt-card');
            const currency = isUsdt ? 'USDT' : 'TON';
            const balance = parseFloat(card.querySelector('.balance-info span').textContent);
            // Define fees (consider making these configurable or fetching from backend)
            const fee = isUsdt ? 0.01 : 0.005; // Example fixed fees
            const minWithdrawal = isUsdt ? 1.0 : 0.1; // Example minimum withdrawal amounts

            availableBalanceEl.textContent = balance.toFixed(4);
            currencySpan.textContent = currency;
            feeSpan.textContent = fee.toFixed(4);
            feeCurrencySpan.textContent = currency;
            amountInput.value = '';
            amountInput.min = minWithdrawal; // Set minimum value
            amountInput.max = (balance - fee).toFixed(4); // Set maximum value dynamically
            amountInput.step = "0.0001"; // Allow fine input
            amountInput.placeholder = `Min ${minWithdrawal} ${currency}`;


            modal.style.display = 'flex';

            // Remove previous listeners before adding new ones
             const newConfirmButton = confirmButton.cloneNode(true);
             confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
             newConfirmButton.onclick = () => confirmWithdraw(currency, balance, fee, minWithdrawal);


             const newCancelButton = cancelButton.cloneNode(true);
             cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);
             newCancelButton.onclick = () => modal.style.display = 'none';
        }


        // Confirm withdrawal (Updated with validation and simulated TX)
        async function confirmWithdraw(currency, balance, fee, minWithdrawal) {
            const modal = document.getElementById('withdraw-modal');
            const amountInput = document.getElementById('withdraw-amount');
            const confirmButton = document.getElementById('confirm-withdraw');

            const amount = parseFloat(amountInput.value);

            // --- Validation ---
            if (isNaN(amount) || amount <= 0) {
                 alert("Please enter a valid withdrawal amount.");
                 return;
            }
            if (amount < minWithdrawal) {
                 alert(`Minimum withdrawal amount is ${minWithdrawal} ${currency}.`);
                 return;
            }
            const totalDeduction = amount + fee;
            if (totalDeduction > balance) {
                 alert(`Insufficient balance. You need ${totalDeduction.toFixed(4)} ${currency} (including fee) but only have ${balance.toFixed(4)} ${currency}.`);
                 return;
            }
            if (!tonConnectUI || !tonConnectUI.connected || !tonConnectUI.account?.address) {
                alert("Wallet is not connected properly. Please reconnect.");
                return;
            }
            // --- End Validation ---

            confirmButton.disabled = true;
            confirmButton.textContent = 'Processing...';

            const recipientAddress = tonConnectUI.account.address; // User's connected wallet address
            const fieldToUpdate = currency.toLowerCase(); // 'usdt' or 'ton'

            try {
                 // ** TODO: Replace simulation with actual backend transaction request **
                 // This section currently only updates Firestore and simulates.
                 // In a real app, you would call your backend API here, which would:
                 // 1. Verify the user and amount.
                 // 2. Securely initiate the on-chain transfer from your platform's wallet to the user's recipientAddress.
                 // 3. Only update Firestore *after* the backend confirms the transaction is initiated or completed.

                 console.log(`[WITHDRAW SIMULATION] Requesting ${amount} ${currency} to ${recipientAddress}`);
                 debugLog(`[WITHDRAW SIM] Requesting ${amount} ${currency} to ${recipientAddress.substring(0, 6)}...`);


                 // --- Firestore Update (Simulated) ---
                 const userDocRef = db.collection('userData').doc(telegramUser.id.toString());
                 const txId = `sim_tx_${Date.now()}`; // Simulated transaction ID

                 // Log the transaction attempt in Firestore history
                 const transactionData = {
                     txId: txId,
                     userId: telegramUser.id.toString(),
                     amount: amount,
                     currency: currency,
                     fee: fee,
                     totalDeducted: totalDeduction,
                     recipient: recipientAddress,
                     status: 'pending_backend', // Status indicating backend processing needed
                     timestamp: firebase.firestore.FieldValue.serverTimestamp() // Use server timestamp
                 };
                 await db.collection('transactions') // Store in a top-level collection maybe
                         .doc(txId) // Use unique TX ID as doc ID
                         .set(transactionData);

                 // Deduct balance from user's Firestore data immediately (can be risky if backend fails)
                 // Consider deducting *after* backend confirms initiation.
                 await userDocRef.update({
                     [fieldToUpdate]: firebase.firestore.FieldValue.increment(-totalDeduction)
                 });

                 console.log(`[WITHDRAW SIMULATION] Balance updated in Firestore. Tx logged: ${txId}`);
                 debugLog(`[WITHDRAW SIM] Firestore updated. Tx: ${txId}`);
                 // --- End Firestore Update ---


                 // --- Simulate backend processing delay and completion ---
                 // REMOVE THIS in production. The backend should update the status.
                 setTimeout(async () => {
                     try {
                         await db.collection('transactions').doc(txId).update({ status: 'completed_simulated' });
                         debugLog(`[WITHDRAW SIM] Tx ${txId} marked as completed (simulated).`);
                         await updateTransactionHistory(); // Refresh history list
                     } catch (simError) {
                          debugLog(`[WITHDRAW SIM] Error updating simulated tx status: ${simError.message}`);
                     }
                 }, 8000); // Simulate 8 second processing
                 // --- End Simulation ---


                 modal.style.display = 'none';
                 await updateUserStatsUI(); // Update balances in UI
                 await updateTransactionHistory(); // Show pending transaction
                 alert(`Withdrawal request for ${amount} ${currency} submitted (Fee: ${fee} ${currency}). It will be processed shortly.`);
                 if (analytics) {
                     analytics.logEvent('withdrawal_request', { userId: telegramUser.id.toString(), currency, amount });
                 }

            } catch (error) {
                debugLog(`Withdrawal error: ${error.message}`);
                alert(`Withdrawal failed: ${error.message}`);
            } finally {
                 // Re-enable button in modal
                 const finalConfirmButton = document.getElementById('confirm-withdraw'); // Get potentially replaced button
                 if (finalConfirmButton) {
                      finalConfirmButton.disabled = false;
                      finalConfirmButton.textContent = 'Confirm';
                 }
            }
        }


        // Update transaction history
        async function updateTransactionHistory() {
            if (!firebaseInitialized || !db) {
                debugLog("Firestore not initialized. Cannot update transaction history.");
                return;
            }
             if (!telegramUser || !telegramUser.id) {
                 debugLog("No user ID for transaction history.");
                 return;
             }

            const transactionList = document.getElementById('transaction-list');
             if (!transactionList) return;

            transactionList.innerHTML = '<li>Loading history...</li>'; // Loading state

            try {
                 // Query the top-level transactions collection, filtering by userId
                const snapshot = await db.collection('transactions')
                    .where('userId', '==', telegramUser.id.toString()) // Filter by user ID
                    .orderBy('timestamp', 'desc') // Order by time descending
                    .limit(15) // Limit number of transactions shown
                    .get();

                if (snapshot.empty) {
                    transactionList.innerHTML = '<li>No transactions yet</li>';
                    return;
                }

                transactionList.innerHTML = snapshot.docs.map(doc => {
                    const tx = doc.data();
                    const txDate = tx.timestamp?.toDate ? tx.timestamp.toDate() : new Date(); // Handle Timestamp object
                    const formattedDate = txDate.toLocaleString();
                     // Display recipient address concisely
                     const shortRecipient = tx.recipient ? `${tx.recipient.substring(0, 6)}...${tx.recipient.substring(tx.recipient.length - 4)}` : 'N/A';
                    return `
                        <li>
                            Amount: ${tx.amount.toFixed(4)} ${tx.currency} (Fee: ${tx.fee.toFixed(4)})<br>
                             To: ${shortRecipient}<br>
                             Status: <span class="tx-status ${tx.status}">${tx.status.replace(/_/g, ' ')}</span><br> {/* Replace underscores */}
                             Date: ${formattedDate}
                        </li>
                    `;
                }).join('');
            } catch (error) {
                debugLog(`Error updating transaction history: ${error.message}`);
                transactionList.innerHTML = `<li>Error loading history: ${error.message}</li>`;
            }
        }

        // Function to show Monetag Ad ( Placeholder - SDK Integration Needed )
        // This function might need adjustment based on the actual Monetag SDK behavior
        // function showMonetagAd() { // Renamed to avoid conflict
        //     if (window.show_9180370) {
        //         try {
        //             console.log("Attempting to show Monetag In-App Interstitial ad");
        //             debugLog("[AD] Triggering Monetag In-App");
        //             window.show_9180370({
        //                 type: 'inApp', // Specify ad type if required by SDK
        //                 inAppSettings: { // Configuration specific to Monetag In-App ads
        //                     frequency: 2,      // Example: Show 2 ads per session
        //                     capping: 0.1,      // Example: Within 6 minutes (0.1 hours)
        //                     interval: 30,      // Example: 30-second interval between ads if frequency > 1
        //                     timeout: 5,        // Example: 5-second delay before first ad shows
        //                     everyPage: false   // Example: Session persists across navigation within the mini-app
        //                 }
        //             });
        //             console.log("Monetag In-App Interstitial ad trigger requested");
        //         } catch (error) {
        //             console.error("Failed to trigger Monetag ad:", error);
        //             debugLog(`[AD FAILED] ${error.message}`);
        //         }
        //     } else {
        //         console.warn("Monetag SDK (show_9180370) not loaded yet for In-App ad.");
        //         debugLog("[AD WARN] SDK not ready for In-App");
        //     }
        // }


    </script>
</body>
</html>
