<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4Metas Mini App</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src='//whephiwums.com/sdk.js' data-zone='9180370' data-sdk='show_9180370'></script>
    <style>
        /* Updated body structure */
        body {
            background: linear-gradient(to bottom, #330033, #000000);
            color: white;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Main content area */
        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            padding-bottom: 70px; /* Space for bottom nav */
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            position: sticky;
            top: 0;
            background: linear-gradient(to bottom, #330033, #000000);
            z-index: 1000;
        }
        header h1 {
            font-size: 24px;
            margin: 0;
        }
        .back-arrow, .menu-dots {
            font-size: 24px;
            cursor: pointer;
        }
        .user-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 0 10px;
        }
        .user-stats .logo img {
            width: 50px;
            height: 50px;
        }
        .user-stats .metric {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .user-stats .metric img {
            width: 20px;
            height: 20px;
        }
        .user-stats .profile-pic img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        .section {
            display: none;
        }
        .section.active {
            display: block;
        }
        .banner-placeholder {
            background: #1a1a3d;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            margin-bottom: 20px;
        }
        .banner-placeholder img {
            width: 100%;
            border-radius: 10px;
        }
        .quest-section h2 {
            font-size: 18px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .quest-section .badge {
            background: #ff00ff;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
        }
        .quest-list {
            list-style: none;
            padding: 0;
        }
        .quest-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .quest-item img {
            width: 30px;
            height: 30px;
            border-radius: 50%;
        }
        .quest-reward {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .quest-reward img {
            width: 20px;
            height: 20px;
        }
        .go-button, .claim-button, .claimed-button {
            border: none;
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
        }
        .go-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
        }
        .claim-button {
            background: linear-gradient(to right, #00ff00, #66ff66);
        }
        .claimed-button {
            background: #ccc;
            cursor: default;
        }
        .quest-item .progress {
            font-size: 12px;
            color: #ccc;
            margin-left: 10px;
        }
        .claim-button.active {
            background: linear-gradient(to right, #00ff00, #66ff66);
        }
        .wallet-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .balance-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .balance-card img {
            width: 30px;
            height: 30px;
        }
        .balance-info span {
            display: block;
            font-size: 16px;
        }
        .balance-info small {
            font-size: 12px;
            color: #ccc;
        }
        .withdraw-button {
            background: #00ff00;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
        }
        .warning-button {
            background: #ffcc00;
            border: none;
            color: black;
            padding: 5px 10px;
            border-radius: 50%;
            cursor: pointer;
        }
        .connect-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 15px;
            width: 100%;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.3s ease;
        }
        .connect-button.connected {
            background: linear-gradient(to right, #00ff00, #66ff66);
        }
        .connect-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .wallet-status {
            text-align: center;
            margin: 10px 0;
        }
        .wallet-status.connected {
            color: #00ff00;
        }
        .wallet-status.disconnected {
            color: #ffcc00;
        }
        .transaction-history {
            margin-top: 20px;
        }
        .transaction-history ul {
            list-style: none;
            padding: 0;
        }
        .transaction-history li {
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-content {
            background: #1a1a3d;
            padding: 20px;
            border-radius: 10px;
            color: white;
            width: 80%;
            max-width: 400px;
        }
        .modal-content input {
            width: 100%;
            padding: 5px;
            margin: 10px 0;
        }
        .game-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .game-list {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }
        .game-item {
            background: #1a1a3d;
            border-radius: 10px;
            text-align: center;
            padding: 5px;
        }
        .game-item img {
            width: 100%;
            border-radius: 10px;
        }
        .game-item p {
            margin: 5px 0;
            font-size: 12px;
        }
        .invite-section .invite-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .invite-stats .spin-info {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .action-button {
            background: linear-gradient(to right, #00ff00, #66ff66);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 15px;
            flex: 1;
            cursor: pointer;
        }
        .total-credit {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .total-credit small {
            font-size: 12px;
            color: #ccc;
        }
        .total-credit small img {
            width: 15px;
            height: 15px;
        }
        .record-section h3, .invite-record h3 {
            font-size: 16px;
            margin: 10px 0;
        }
        .no-frens {
            text-align: center;
            color: #ccc;
        }
        .no-frens img {
            width: 50px;
            height: 50px;
        }
        .record-header {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #ccc;
            margin-bottom: 10px;
        }
        .record-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .record-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        .record-item .user-info {
            flex: 1;
            margin-left: 10px;
        }
        .record-item .user-info small {
            color: #ccc;
            font-size: 12px;
        }
        .record-item .credit {
            background: #ff00ff;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
        }
        .chest-section .chest-slider {
            position: relative;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .chest-container {
            display: flex;
            transition: transform 0.3s ease;
        }
        .chest-item {
            flex: 0 0 100%;
            text-align: center;
        }
        .chest-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 16px;
        }
        .chest-title span {
            color: #ccc;
        }
        .chest-image img {
            width: 150px;
            height: 150px;
        }
        .not-enough {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            color: #ffcc00;
            margin-top: 10px;
        }
        .not-enough img {
            width: 20px;
            height: 20px;
        }
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.5);
            border: none;
            color: white;
            padding: 10px;
            cursor: pointer;
            z-index: 100;
        }
        .nav-arrow.left {
            left: 0;
        }
        .nav-arrow.right {
            right: 0;
        }
        .rewards {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
        }
        .reward-item {
            text-align: center;
        }
        .reward-item img {
            width: 40px;
            height: 40px;
        }
        .reward-item p {
            margin: 5px 0;
            font-size: 12px;
        }
        .cost {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            margin-bottom: 10px;
        }
        .cost img {
            width: 20px;
            height: 20px;
        }
        .vip-requirement {
            text-align: center;
            color: #ffcc00;
            margin-bottom: 10px;
        }
        .open-chest-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 15px;
            width: 100%;
            cursor: pointer;
        }
        .top-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .ranking-list {
            list-style: none;
            padding: 0;
        }
        .ranking-item {
            display: flex;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .ranking-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .ranking-item span {
            flex: 1;
        }
        .ranking-item .medal-count {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .ranking-item .medal-count img {
            width: 20px;
            height: 20px;
        }

        nav.bottom-nav {
            display: flex !important;
            justify-content: space-around !important;
            background: #1a1a3d !important;
            padding: 10px 0 !important;
            position: fixed !important;
            bottom: env(safe-area-inset-bottom, 0px) !important;
            left: 0 !important;
            right: 0 !important;
            z-index: 100000 !important;
            height: 60px !important;
            visibility: visible !important;
            opacity: 1 !important;
            border-top: 2px solid red !important;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5) !important;
        }

        nav.bottom-nav .nav-button {
            background: none !important;
            border: none !important;
            color: #ccc !important;
            display: flex !important;
            flex-direction: column !important;
            align-items: center !important;
            justify-content: center !important;
            cursor: pointer !important;
            font-size: 12px !important;
            width: 60px !important;
            height: 100% !important;
            visibility: visible !important;
            opacity: 1 !important;
            min-height: 40px !important;
        }

        nav.bottom-nav .nav-button.active {
            color: white !important;
        }

        nav.bottom-nav .nav-button img {
            width: 24px !important;
            height: 24px !important;
            margin-bottom: 5px !important;
            display: block !important;
        }

        nav.bottom-nav .nav-button span {
            display: block !important;
        }

        /* Additional styles for wallet integration */
        .error-message {
            color: #ffcc00;
            text-align: center;
            margin: 10px 0;
            display: none;
        }

        .tx-status.pending { color: #ffcc00; }
        .tx-status.completed { color: #00ff00; }
        .tx-status.failed { color: #ff0000; }
        /* Style for simulated statuses */
        .tx-status.pending_backend { color: #ffcc00; }
        .tx-status.completed_simulated { color: #00dddd; } /* Use a different color for simulated completion */

    </style>
</head>
<body>
    <header>
        <div class="back-arrow">X</div>
        <h1>4Metas</h1>
        <div class="menu-dots">⋮</div>
    </header>

    <div class="main-content">
        <section class="user-stats">
            <div class="logo">
                <img src="assets/icons/logo.png" alt="4Metas Logo">
            </div>
            <div class="metric">
                <img src="assets/icons/gem.png" alt="Gem">
                <span id="gems">0</span>
            </div>
            <div class="metric">
                <img src="assets/icons/usdt.png" alt="USDT">
                <span id="usdt">0.0000</span>
            </div>
            <div class="metric">
                <img src="assets/icons/ton.png" alt="TON">
                <span id="ton">0.0000</span>
            </div>
            <div class="profile-pic">
                <img src="assets/icons/user-avatar.png" alt="User Profile">
            </div>
        </section>

        <section id="earn" class="section earn-section active">
            <div class="banner-placeholder">
                <img src="assets/icons/banner.png" alt="Banner">
            </div>
            <div class="quest-section">
                <h2>DAILY QUEST <span class="badge" id="daily-quest-count">0</span></h2>
                <ul class="quest-list" id="daily-quest-list">
                    <li class="no-quests">
                        <p>No daily quests available</p>
                    </li>
                </ul>
            </div>
            <div class="quest-section">
                <h2>BASIC QUEST <span class="badge" id="basic-quest-count">0</span></h2>
                <ul class="quest-list" id="basic-quest-list">
                    <li class="no-quests">
                        <p>No basic quests available</p>
                    </li>
                </ul>
            </div>
        </section>

        <section id="wallet" class="section wallet-section">
            <h2>Wallet</h2>
            <div class="wallet-status disconnected">
                <span id="connection-status">Disconnected</span>
            </div>
            <div class="balance-card usdt-card">
                <img src="assets/icons/usdt.png" alt="USDT Icon">
                <div class="balance-info">
                    <span id="wallet-usdt">0.0000</span>
                    <small>USDT</small>
                </div>
                <button class="withdraw-button" disabled>WITHDRAW</button>
                <button class="warning-button">!</button>
            </div>
            <div class="balance-card ton-card">
                <img src="assets/icons/ton.png" alt="TON Icon">
                <div class="balance-info">
                    <span id="wallet-ton">0.0000</span>
                    <small>TON</small>
                </div>
                <button class="withdraw-button" disabled>WITHDRAW</button>
                <button class="warning-button">!</button>
            </div>
            <p class="instruction">Connect wallet to withdraw your balance.</p>
            <button class="connect-button">CONNECT TON WALLET</button>
            <div class="transaction-history">
                <h3>Transaction History</h3>
                <ul id="transaction-list">
                    <li>No transactions yet</li>
                </ul>
            </div>
            <div id="withdraw-modal" class="modal" style="display: none;">
                <div class="modal-content">
                    <h3>Withdraw Funds</h3>
                    <label>Amount: <input type="number" id="withdraw-amount" min="0" step="0.0001"></label>
                    <p>Available: <span id="available-balance">0</span> <span id="currency"></span></p>
                    <p>Fee: <span id="withdraw-fee">0</span> <span id="fee-currency"></span></p>
                    <button id="confirm-withdraw">Confirm</button>
                    <button id="cancel-withdraw">Cancel</button>
                </div>
            </div>
        </section>

        <section id="game" class="section game-section">
            <div class="banner-placeholder">
                <img src="assets/icons/game-banner.png" alt="Game Banner">
            </div>
            <h2>Game List</h2>
            <div class="game-list">
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/FF0000/FFFFFF?text=TG" alt="Traffic Go">
                    <p>Traffic Go</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/00FF00/FFFFFF?text=CM" alt="Cutting Master">
                    <p>Cutting Master</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/0000FF/FFFFFF?text=EM" alt="Element Magic">
                    <p>Element Magic</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/FFFF00/FFFFFF?text=JS" alt="Juicy Splash">
                    <p>Juicy Splash</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/FF00FF/FFFFFF?text=COR" alt="Creed of Rescue">
                    <p>Creed of Rescue</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/00FFFF/FFFFFF?text=FJ" alt="Farm Jam">
                    <p>Farm Jam</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/FFA500/FFFFFF?text=2048" alt="2048 Blocks">
                    <p>2048 Blocks</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/800080/FFFFFF?text=CRC" alt="Cut Rope Combo">
                    <p>Cut Rope Combo</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/008000/FFFFFF?text=HJ" alt="Happy Jelly Jump">
                    <p>Happy Jelly Jump</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/000080/FFFFFF?text=UTR" alt="Undersea Tunnel Race">
                    <p>Undersea Tunnel Race</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/FFC0CB/FFFFFF?text=MM" alt="Motor Master">
                    <p>Motor Master</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/FFD700/FFFFFF?text=OF" alt="Open Fire">
                    <p>Open Fire</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/ADFF2F/FFFFFF?text=MTD" alt="Monster TD">
                    <p>Monster TD</p>
                </div>
                <div class="game-item">
                    <img src="https://via.placeholder.com/80/FF4500/FFFFFF?text=BW" alt="Bloody Warrior">
                    <p>Bloody Warrior</p>
                </div>
            </div>
        </section>

        <section id="invite" class="section invite-section">
            <div class="invite-stats">
                <span id="my-invite">My Invite: 0</span>
                <div class="spin-info">
                    <span>Spin x0</span>
                    <span class="warning">!</span>
                </div>
            </div>
            <div class="action-buttons">
                <button class="action-button invite-friend">Invite Friend</button>
                <button class="action-button copy-link">Copy Link</button>
            </div>
            <div class="total-credit">
                <div class="credit-info">
                    <span id="total-credit">Total Credit <span class="warning">!</span> : 0</span>
                    <small>10,000 = 1 <img src="assets/icons/usdt.png" alt="USDT"></small>
                </div>
                <button class="claim-button">Claim</button>
            </div>
            <div class="record-section">
                <h3>Claim Record</h3>
                <div class="no-frens">
                    <img src="assets/icons/nofrens.png" alt="No Frens">
                    <p>No Frens yet</p>
                </div>
            </div>
            <div class="invite-record">
                <h3 id="invite-record-title">Invite Record (0)</h3>
                <div class="record-header">
                    <span>User</span>
                    <span>Join Time</span>
                    <span>Credit</span>
                </div>
                <div class="record-list">
                    <div class="no-frens">
                        <img src="assets/icons/nofrens.png" alt="No Frens">
                        <p>No invites yet</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="chest" class="section chest-section">
            <div class="chest-slider">
                <button class="nav-arrow left" onclick="prevChest()"><</button>
                <div class="chest-container" id="chestContainer">
                    <div class="chest-item">
                        <div class="chest-title">
                            <h2>Wood Chest</h2>
                            <span>Bronze</span>
                        </div>
                        <div class="chest-image">
                            <img src="assets/graphics/wood-chest.png" alt="Wood Chest">
                        </div>
                        <div class="not-enough">
                            <span>NOT ENOUGH</span>
                            <img src="assets/icons/gem.png" alt="Gem">
                        </div>
                    </div>
                    <div class="chest-item">
                        <div class="chest-title">
                            <h2>Bronze Chest</h2>
                            <span>Silver</span>
                        </div>
                        <div class="chest-image">
                            <img src="assets/graphics/bronze-chest.png" alt="Bronze Chest">
                        </div>
                        <div class="not-enough">
                            <span>NOT ENOUGH</span>
                            <img src="assets/icons/gem.png" alt="Gem">
                        </div>
                    </div>
                    <div class="chest-item">
                        <div class="chest-title">
                            <h2>Silver Chest</h2>
                            <span>Gold</span>
                        </div>
                        <div class="chest-image">
                            <img src="assets/graphics/silver-chest.png" alt="Silver Chest">
                        </div>
                        <div class="not-enough">
                            <span>NOT ENOUGH</span>
                            <img src="assets/icons/gem.png" alt="Gem">
                        </div>
                    </div>
                    </div>
                <button class="nav-arrow right" onclick="nextChest()">></button>
            </div>
            <div class="rewards">
                <div class="reward-item usdt">
                    <img src="assets/icons/usdt.png" alt="USDT">
                    <p>USDT</p>
                </div>
                <div class="reward-item land-piece">
                    <img src="assets/icons/land-piece.png" alt="Land Piece">
                    <p>Land Piece</p>
                </div>
                <div class="reward-item fox-medal">
                    <img src="assets/icons/fox-medal.png" alt="Fox Medal">
                    <p>Fox Medal</p>
                </div>
            </div>
            <div class="cost" id="chestCost">
                <span>200</span>
                <img src="assets/icons/gem.png" alt="Gem">
            </div>
            <div class="vip-requirement" id="chestVipRequirement" style="display: none;">
                NEED VIP 1
            </div>
            <button class="open-chest-button" onclick="openChest()">Open Chest</button>
        </section>

        <section id="top" class="section top-section">
            <h2>Medal Ranking <span class="warning">!</span></h2>
            <ul class="ranking-list" id="ranking-list">
                <li class="no-rankings">
                    <p>No rankings available</p>
                </li>
            </ul>
        </section>
    </div>

    <nav class="bottom-nav">
        <button class="nav-button" data-section="earn">
            <img src="assets/icons/earn.png" alt="Earn">
            <span>Earn</span>
        </button>
        <button class="nav-button" data-section="wallet">
            <img src="assets/icons/wallet.png" alt="Wallet">
            <span>Wallet</span>
        </button>
        <button class="nav-button" data-section="game">
            <img src="assets/icons/game.png" alt="Game">
            <span>Game</span>
        </button>
        <button class="nav-button" data-section="invite">
            <img src="assets/icons/invite.png" alt="Invite">
            <span>Invite</span>
        </button>
        <button class="nav-button" data-section="chest">
            <img src="assets/icons/chest.png" alt="Chest">
            <span>Chest</span>
        </button>
        <button class="nav-button" data-section="top">
            <img src="assets/icons/top.png" alt="Top">
            <span>Top</span>
        </button>
    </nav>
<div id="debugConsole" style="
    position: fixed;
    bottom: 70px; /* Adjusted position */
    left: 0;
    right: 0;
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 10px;
    font-family: monospace;
    font-size: 12px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 1000;
    display: none; /* Start hidden */
    border-top: 1px solid #ff00ff;
"></div>
<button onclick="toggleDebugConsole()"
    style="
        position: fixed;
        bottom: 75px; /* Position above debug console */
        right: 10px;
        z-index: 1001;
        padding: 5px 10px;
        background: #ff00ff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    ">
    Debug
</button>
    <script>
        // --- Debug Console Toggle ---
        function toggleDebugConsole() {
            const consoleEl = document.getElementById('debugConsole');
            if (consoleEl) {
                consoleEl.style.display = (consoleEl.style.display === 'none') ? 'block' : 'none';
            }
        }

        // --- Debug Logging Helper ---
        function debugLog(message) {
            const now = new Date();
            const timestamp = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
            console.log(`[${timestamp}] ${message}`); // Log to browser console
            const debugConsole = document.getElementById('debugConsole');
            if (debugConsole) {
                // Sanitize message slightly to prevent accidental HTML injection
                const sanitizedMessage = message.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                debugConsole.innerHTML += `<div>[${timestamp}] ${sanitizedMessage}</div>`;
                debugConsole.scrollTop = debugConsole.scrollHeight; // Auto-scroll
            }
        }

        debugLog('Script started'); // Initial log
        debugLog('Nav buttons present at start: ' + document.querySelectorAll('.nav-button').length);

        // Function to dynamically load a script and return a Promise
        function loadScript(src, retries = 3, delay = 1000) {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const tryLoad = () => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.async = true;
                    script.onload = () => {
                        debugLog(`Script loaded successfully: ${src}`);
                        resolve(true); // Resolve with true on success
                    };
                    script.onerror = () => {
                        attempts++;
                        if (attempts < retries) {
                            debugLog(`Failed to load script: ${src}. Retrying (${attempts}/${retries})...`);
                            setTimeout(tryLoad, delay);
                        } else {
                            debugLog(`Failed to load script after ${retries} attempts: ${src}`);
                            reject(new Error(`Failed to load script after ${retries} attempts: ${src}`));
                        }
                    };
                    document.head.appendChild(script);
                };
                tryLoad();
            });
        }

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCUkEmFmJK2vr8k7M6JqYaxlcgBDf7WdJI", // WARNING: Exposing API key client-side is insecure
            authDomain: "fourgo-cd98f.firebaseapp.com",
            projectId: "fourgo-cd98f",
            storageBucket: "fourgo-cd98f.firebasestorage.app",
            messagingSenderId: "511215742272",
            appId: "1:511215742272:web:04bd85a284919ae123dea5",
            measurementId: "G-DC7E6ECF2L"
        };

        // Validate Firebase Configuration
        function validateFirebaseConfig(config) {
            const requiredFields = ['apiKey','authDomain','projectId','storageBucket','messagingSenderId','appId'];
            for (const field of requiredFields) {
                if (!config[field]) {
                    throw new Error(`Firebase config is missing required field: ${field}`);
                }
            }
            debugLog("Firebase config validated successfully");
        }

        // Initialize Firebase with dynamic loading using compat scripts
        let app, db, auth, storage, analytics;
        let firebaseInitialized = false;
        async function initializeFirebase(maxRetries = 3) {
            if (firebaseInitialized) {
                debugLog("Firebase already initialized, skipping reinitialization");
                return true;
            }

            if (window.firebase && window.firebase.apps && window.firebase.apps.length > 0) {
                debugLog("Firebase detected in global scope, reusing existing instance");
                app = window.firebase.apps[0];
                db = app.firestore();
                auth = app.auth();
                storage = app.storage();
                if (app.analytics) {
                  analytics = app.analytics();
                } else {
                    debugLog("Firebase Analytics component not available on existing instance.");
                    try {
                        await loadScript('https://www.gstatic.com/firebasejs/10.13.0/firebase-analytics-compat.js');
                        analytics = firebase.analytics();
                        debugLog("Firebase Analytics loaded dynamically.");
                    } catch (error) {
                        debugLog("Failed to load Firebase Analytics dynamically: " + error.message);
                    }
                }
                firebaseInitialized = true;
                return true;
            }

            let attempts = 0;
            const scriptUrls = [
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-app-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-auth-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-storage-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-analytics-compat.js'
            ];

            while (attempts < maxRetries && !firebaseInitialized) {
                try {
                    debugLog(`Attempt ${attempts + 1}/${maxRetries} to initialize Firebase...`);
                    validateFirebaseConfig(firebaseConfig);

                    await Promise.all(scriptUrls.map(url => loadScript(url)));
                    if (typeof firebase === 'undefined') {
                        throw new Error("Firebase SDK not loaded into global scope");
                    }

                    if (!firebase.apps.length) {
                        app = firebase.initializeApp(firebaseConfig);
                    } else {
                        app = firebase.app();
                    }
                    db = firebase.firestore();
                    auth = firebase.auth();
                    storage = firebase.storage();
                    analytics = firebase.analytics();

                    await db.collection('test').doc('init').set({
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true });

                    firebaseInitialized = true;
                    debugLog("Firebase fully initialized");
                    return true;
                } catch (error) {
                    attempts++;
                    debugLog(`Firebase initialization attempt ${attempts} failed: ${error.message}`);
                    if (attempts >= maxRetries) {
                        debugLog("Max retries reached. Firebase initialization failed.");
                        return false;
                    }
                    await new Promise(resolve => setTimeout(resolve, 2000));
                }
            }
            return false;
        }

        // Telegram Web App Setup with error handling
        let telegramUser;
        try {
            debugLog("Initializing Telegram Web App...");
            window.Telegram.WebApp.ready();
            telegramUser = window.Telegram.WebApp.initDataUnsafe.user;
            if (telegramUser) {
                const profilePic = document.querySelector('.profile-pic img');
                if (profilePic) profilePic.src = telegramUser.photo_url || 'assets/icons/user-avatar.png';
                const headerTitle = document.querySelector('header h1');
                // if (headerTitle) headerTitle.innerText = `${telegramUser.first_name || '4Metas'}`;
                 if (headerTitle) headerTitle.innerText = `4Metas`; // Keep it simple
                debugLog(`Telegram Web App initialized. User: ${telegramUser.id}, ${telegramUser.username || telegramUser.first_name}`);
            } else {
                debugLog("No Telegram user data available. Running in test mode.");
                telegramUser = { id: "test_user_123", username: "TestUser", first_name: "Test", photo_url: "https://via.placeholder.com/40/808080/000000?text=T" };
                 const profilePic = document.querySelector('.profile-pic img');
                 if (profilePic) profilePic.src = telegramUser.photo_url;
            }
        } catch (error) {
            debugLog(`Telegram Web App initialization failed: ${error.message}`);
            telegramUser = { id: "test_user_123_fallback", username: "TestUserFB", first_name: "TestFB", photo_url: "https://via.placeholder.com/40/808080/000000?text=F" };
             const profilePic = document.querySelector('.profile-pic img');
             if (profilePic) profilePic.src = telegramUser.photo_url;
        }

        // Storage abstraction using Firebase Firestore
        const Storage = {
            getItem: async (key) => {
                if (!firebaseInitialized || !db) {
                    debugLog("Firestore not initialized. Cannot fetch item: " + key);
                    return null;
                }
                if (!telegramUser || !telegramUser.id) {
                     debugLog("Telegram user ID not available. Cannot fetch item: " + key);
                     return null;
                }
                try {
                    const doc = await db.collection('userData')
                        .doc(telegramUser.id.toString()).get();
                    return doc.exists ? doc.data()[key] : null;
                } catch (error) {
                    debugLog(`Error fetching ${key}: ${error.message}`);
                    return null;
                }
            },
            setItem: async (key, value) => {
                if (!firebaseInitialized || !db) {
                    debugLog("Firestore not initialized. Cannot set item: " + key);
                    return false;
                }
                 if (!telegramUser || !telegramUser.id) {
                     debugLog("Telegram user ID not available. Cannot set item: " + key);
                     return false;
                 }
                try {
                    await db.collection('userData')
                        .doc(telegramUser.id.toString())
                        .set({ [key]: value }, { merge: true });
                    return true;
                } catch (error) {
                    debugLog(`Error setting ${key}: ${error.message}`);
                    return false;
                }
            }
        };

        // Navigation Logic with Button Style Forcing
        document.addEventListener('DOMContentLoaded', () => {
            try {
                debugLog('Setting up navigation');
                const sections = document.querySelectorAll('.section');
                const navButtons = document.querySelectorAll('nav.bottom-nav .nav-button');
                const bottomNav = document.querySelector('nav.bottom-nav');

                debugLog(`Found sections: ${sections.length}, Found nav buttons: ${navButtons.length}, Bottom nav exists: ${!!bottomNav}`);

                navButtons.forEach((btn, index) => {
                    // debugLog(`Button ${index}: ${btn.getAttribute('data-section')}`); // Less verbose logging
                    btn.style.display = 'flex';
                    btn.style.visibility = 'visible';
                    btn.style.opacity = '1';
                    const img = btn.querySelector('img');
                    if (img) {
                        img.onerror = () => {
                            debugLog(`Image failed to load for button ${index}: ${img.src}`);
                            img.src = 'https://via.placeholder.com/24/FFFFFF/000000?text=X'; // Fallback
                        };
                    }
                });

                async function switchSection(sectionId) {
                    debugLog(`Switching to section: ${sectionId}`);
                    sections.forEach(section => section.classList.remove('active'));
                    navButtons.forEach(btn => btn.classList.remove('active'));

                    const targetSection = document.getElementById(sectionId);
                    const targetButton = document.querySelector(`.nav-button[data-section="${sectionId}"]`);

                    if (targetSection) targetSection.classList.add('active');
                    else debugLog(`Section with id "${sectionId}" not found`);

                    if (targetButton) targetButton.classList.add('active');
                    else debugLog(`Button with data-section "${sectionId}" not found`);

                    try {
                        if (sectionId === 'earn') await ensureFirebaseReady(updateEarnSectionUI);
                        else if (sectionId === 'invite') await ensureFirebaseReady(updateInviteSectionUI);
                        else if (sectionId === 'top') await ensureFirebaseReady(updateTopSectionUI);
                        else if (sectionId === 'wallet') await ensureFirebaseReady(updateWalletSectionUI);
                        else if (sectionId === 'chest') await ensureFirebaseReady(updateChestSectionUI);
                    } catch (error) {
                        debugLog(`Error updating section ${sectionId}: ${error.message}`);
                    }
                }

                navButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const sectionId = button.getAttribute('data-section');
                        switchSection(sectionId);
                    });
                });

                // Set default section
                debugLog('Setting default section to Earn');
                switchSection('earn'); // Default to Earn

                if (bottomNav) {
                    bottomNav.style.display = 'flex';
                    bottomNav.style.visibility = 'visible';
                    bottomNav.style.opacity = '1';
                    bottomNav.style.position = 'fixed';
                    bottomNav.style.bottom = '0px';
                    bottomNav.style.left = '0px';
                    bottomNav.style.right = '0px';
                    bottomNav.style.height = '60px';
                    bottomNav.style.zIndex = '100000';
                    bottomNav.style.background = '#1a1a3d';
                    // debugLog('Forced bottom-nav styles applied.'); // Less verbose
                } else {
                    debugLog('ERROR: Bottom nav element not found in DOM');
                }
            } catch (error) {
                debugLog(`Navigation setup failed: ${error.message}\nStack: ${error.stack}`);
            }
        });

        // Helper to ensure Firebase is ready before running a callback
        async function ensureFirebaseReady(callback) {
            if (!firebaseInitialized || !db || !auth) {
                debugLog("Firebase not ready, attempting initialization...");
                const success = await initializeFirebase();
                if (!success) {
                    debugLog("Firebase initialization failed after retries. Cannot proceed.");
                    alert("Failed to connect to database. Please try again later.");
                    return;
                }
            }
            // Optional: Check for analytics if needed by callback
            if (callback.needsAnalytics && !analytics) {
                 debugLog("Analytics needed but not initialized. Attempting to ensure.");
                 if (!app.analytics) {
                    try {
                        await loadScript('https://www.gstatic.com/firebasejs/10.13.0/firebase-analytics-compat.js');
                        analytics = firebase.analytics();
                        debugLog("Firebase Analytics loaded dynamically for callback.");
                    } catch (error) {
                        debugLog(`Failed to load Firebase Analytics dynamically: ${error.message}`);
                    }
                 } else {
                    analytics = app.analytics();
                 }
            }

            // debugLog("Firebase ready, executing callback..."); // Less verbose
            try {
                await callback();
            } catch (error) {
                 debugLog(`Error during Firebase-dependent callback execution (${callback.name}): ${error.message}\nStack: ${error.stack}`);
            }
        }

        // User Data Management
        async function initializeUserData() {
            if (!telegramUser || !telegramUser.id) {
                debugLog("Cannot initialize user data: No valid Telegram user available");
                return;
            }
            if (!firebaseInitialized || !db) {
                debugLog("Firestore not initialized. Cannot initialize user data.");
                return;
            }
            const userIdStr = telegramUser.id.toString();
            const userDocRef = db.collection('userData').doc(userIdStr);
            const rankingDocRef = db.collection('users').doc(userIdStr);

            try {
                const doc = await userDocRef.get();
                if (!doc.exists) {
                    debugLog("New user detected. Creating initial data...");
                    const initialData = {
                        gems: 0, usdt: 0, ton: 0, referrals: 0,
                        inviteRecords: [], totalCreditsEarnedFromInvites: 0,
                        landPieces: 0, foxMedals: 0, isReferred: false,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        claimedQuests: [], adProgress: {}, walletAddress: null,
                        vipLevel: 0 // Initialize VIP Level
                    };
                    await userDocRef.set(initialData);
                    debugLog("New user data document created in userData");

                    const rankingData = {
                        username: telegramUser.username || telegramUser.first_name || `User_${userIdStr.substring(0,4)}`,
                        foxMedals: 0,
                        photoUrl: telegramUser.photo_url || 'https://via.placeholder.com/40/808080/000000?text=U'
                    };
                    await rankingDocRef.set(rankingData, { merge: true });
                    debugLog("New user data initialized in users collection for ranking");

                    if (analytics) {
                         analytics.logEvent('user_signup', { userId: userIdStr });
                         debugLog("Analytics: user_signup logged");
                    }
                } else {
                    // debugLog("Existing user data found."); // Less verbose
                    const currentData = doc.data();
                    const updates = {};
                    if (currentData.claimedQuests === undefined) updates.claimedQuests = [];
                    if (currentData.adProgress === undefined) updates.adProgress = {};
                    if (currentData.inviteRecords === undefined) updates.inviteRecords = [];
                    if (currentData.totalCreditsEarnedFromInvites === undefined) updates.totalCreditsEarnedFromInvites = 0;
                    if (currentData.vipLevel === undefined) updates.vipLevel = 0; // Add VIP level if missing

                    if (Object.keys(updates).length > 0) {
                        await userDocRef.update(updates);
                        debugLog("User data schema updated with missing fields.");
                    }
                }
                await updateUserStatsUI(); // Update UI after ensuring data exists
            } catch (error) {
                debugLog(`Error initializing/checking user data: ${error.message}\nStack: ${error.stack}`);
            }
        }

        async function updateUserStatsUI() {
            if (!telegramUser || !telegramUser.id) {
                 debugLog("Cannot update UI: No valid Telegram user.");
                 return;
            }
            if (!firebaseInitialized || !db) {
                debugLog("Firestore not initialized. Cannot update user stats UI.");
                return;
            }
            const userIdStr = telegramUser.id.toString();
            try {
                const userDoc = await db.collection('userData').doc(userIdStr).get();
                if (!userDoc.exists) {
                     debugLog("User data not found for UI update. Attempting initialization...");
                     await initializeUserData(); // Try to initialize if missing
                     return;
                }

                const data = userDoc.data();
                document.getElementById('gems').textContent = data.gems || 0;
                document.getElementById('usdt').textContent = (data.usdt || 0).toFixed(4);
                document.getElementById('ton').textContent = (data.ton || 0).toFixed(4);
                document.getElementById('wallet-usdt').textContent = (data.usdt || 0).toFixed(4);
                document.getElementById('wallet-ton').textContent = (data.ton || 0).toFixed(4);
                // debugLog("User stats UI updated successfully"); // Less verbose
            } catch (error) {
                debugLog(`Error updating user stats UI: ${error.message}\nStack: ${error.stack}`);
            }
        }

        // Fetch and Update Earn Section (Quests)
        async function updateEarnSectionUI() {
            try {
                if (!firebaseInitialized || !db) {
                    debugLog("Firebase not initialized for Earn section, ensuring readiness...");
                    await ensureFirebaseReady(()=>{}); // Ensure Firebase is ready before proceeding
                     if (!firebaseInitialized || !db) throw new Error("Firebase failed to initialize for Earn section");
                }

                let userData = {};
                if (telegramUser && telegramUser.id) {
                    const userDoc = await db.collection('userData').doc(telegramUser.id.toString()).get();
                    if (userDoc.exists) {
                         userData = userDoc.data();
                         userData.adProgress = userData.adProgress || {};
                         userData.claimedQuests = userData.claimedQuests || [];
                    } else {
                        debugLog("User data not found for Earn section. Initializing...");
                        await initializeUserData();
                        const refetchedDoc = await db.collection('userData').doc(telegramUser.id.toString()).get();
                         if (refetchedDoc.exists) userData = refetchedDoc.data();
                         userData.adProgress = userData.adProgress || {};
                         userData.claimedQuests = userData.claimedQuests || [];
                    }
                } else {
                    debugLog("Cannot fetch user data for Earn section: Invalid user or Firebase state.");
                     document.getElementById('daily-quest-list').innerHTML = '<li>Loading user data...</li>';
                     document.getElementById('basic-quest-list').innerHTML = '<li>Loading user data...</li>';
                    return;
                }

                // Fetch Daily Quests
                const dailyQuestsSnapshot = await db.collection('quests').doc('daily').get({ source: 'server' });
                const dailyQuestsRaw = dailyQuestsSnapshot.exists ? dailyQuestsSnapshot.data() : {};
                const dailyQuests = dailyQuestsRaw.tasks || [];
                const validatedDailyQuests = dailyQuests.map(quest => ({
                     id: quest.id || Math.random().toString(36).substring(7),
                     title: quest.title || "Untitled Quest",
                     icon: quest.icon || 'https://via.placeholder.com/30/FFFFFF/000000?text=Q',
                     reward: Number(quest.reward) || 0,
                     action: quest.action || 'GO',
                     link: quest.link || '',
                     type: quest.type || 'default'
                }));
                const dailyQuestList = document.getElementById('daily-quest-list');
                const dailyQuestCount = document.getElementById('daily-quest-count');
                if (!dailyQuestList || !dailyQuestCount) throw new Error("Required DOM elements missing for daily quests");
                dailyQuestCount.textContent = validatedDailyQuests.length;
                dailyQuestList.innerHTML = validatedDailyQuests.length === 0 ? `<li><p>No daily quests available</p></li>` : validatedDailyQuests.map(quest => {
                    const isClaimed = userData.claimedQuests?.includes(quest.id);
                    const buttonText = isClaimed ? 'Claimed' : quest.action;
                    const buttonClass = isClaimed ? 'claimed-button' : 'go-button';
                    const buttonStyle = isClaimed ? 'background: #ccc; cursor: default;' : 'background: linear-gradient(to right, #ff00ff, #ff6666);';
                    const rewardDisplay = quest.reward > 0 ? `
                        <img src="assets/icons/gem.png" alt="Gem">
                        <span>+${quest.reward}</span>` : '';
                    return `
                        <li class="quest-item" data-quest-id="${quest.id}" data-quest-type="${quest.type}" data-quest-reward="${quest.reward}">
                            <img src="${quest.icon}" alt="${quest.title}" onerror="this.src='https://via.placeholder.com/30/FFFFFF/000000?text=Q'">
                            <span>${quest.title}</span>
                            <div class="quest-reward">
                                ${rewardDisplay}
                                <button class="${buttonClass}" data-quest-link="${quest.link}" data-quest-title="${quest.title}" style="${buttonStyle}" ${isClaimed ? 'disabled' : ''}>${buttonText}</button>
                            </div>
                        </li>`;
                }).join('');


                 // Fetch Basic Quests
                const basicQuestsSnapshot = await db.collection('quests').doc('basic').get({ source: 'server' });
                const basicQuestsRaw = basicQuestsSnapshot.exists ? basicQuestsSnapshot.data() : {};
                const basicQuests = basicQuestsRaw.tasks || [];
                const validatedBasicQuests = basicQuests.map(quest => ({
                     id: quest.id || Math.random().toString(36).substring(7),
                     title: quest.title || "Untitled Quest",
                     icon: quest.icon || 'https://via.placeholder.com/30/FFFFFF/000000?text=Q',
                     reward: Number(quest.reward) || 0,
                     action: quest.action || 'GO',
                     link: quest.link || '',
                     type: quest.type || 'default',
                     adLimit: quest.adLimit || 0,
                     adType: quest.adType || 'rewarded_interstitial'
                }));
                const basicQuestList = document.getElementById('basic-quest-list');
                const basicQuestCount = document.getElementById('basic-quest-count');
                 if (!basicQuestList || !basicQuestCount) throw new Error("Required DOM elements missing for basic quests");
                 basicQuestCount.textContent = validatedBasicQuests.length;

                const currentTime = new Date();

                // *** UPDATED BASIC QUEST RENDERING LOGIC ***
                basicQuestList.innerHTML = validatedBasicQuests.length === 0 ? `
                    <li class="no-quests">
                        <p>No basic quests available</p>
                    </li>
                ` : validatedBasicQuests.map(quest => {
                    const isCompletedGeneral = userData.claimedQuests?.includes(quest.id);
                    let buttonText, buttonClass, buttonStyle, isDisabled = false;
                    let rewardDisplay = ''; // To hold reward/progress HTML

                    if (quest.type === 'ads' && quest.reward === 0) {
                        // --- Zero-Reward Ad Quests ---
                        if (isCompletedGeneral) {
                            buttonText = 'Completed'; buttonClass = 'claimed-button'; buttonStyle = 'background: #ccc; cursor: default;'; isDisabled = true;
                        } else {
                            buttonText = quest.action || 'Watch Ad'; buttonClass = 'go-button'; buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);'; isDisabled = false;
                        }
                        rewardDisplay = ''; // No reward shown

                    } else if (quest.type === 'ads') {
                        // --- Reward Ad Quests ---
                        const adProgress = userData.adProgress[quest.id] || { watched: 0, claimed: false, lastClaimed: null };
                        const isTaskCompleted = adProgress.watched >= quest.adLimit;
                        const isTaskClaimed = adProgress.claimed;
                        const lastClaimedTime = adProgress.lastClaimed ? new Date(adProgress.lastClaimed.seconds ? adProgress.lastClaimed.toDate() : adProgress.lastClaimed) : null; // Handle Firestore Timestamp or ISO string
                        const timeSinceLastClaim = lastClaimedTime ? currentTime.getTime() - lastClaimedTime.getTime() : Infinity;
                        const cooldownPeriod = 3600000; // 1 hour
                        let isCooldownOver = timeSinceLastClaim >= cooldownPeriod;

                        // Check for reset condition and update *local* state for rendering
                        if (isTaskClaimed && isCooldownOver) {
                            // debugLog(`Resetting reward ad quest ${quest.id} locally for UI update (cooldown over)`);
                            // NOTE: Actual Firestore reset happens in the click handler or a background job
                            adProgress.watched = 0;
                            adProgress.claimed = false;
                            isCooldownOver = true; // Ensure state reflects reset for button logic below
                            // Update local variables derived from adProgress
                            isTaskClaimed = false;
                        }

                        if (adProgress.claimed && !isCooldownOver) { // Claimed and in cooldown
                            const timeLeft = Math.ceil((cooldownPeriod - timeSinceLastClaim) / 60000);
                            buttonText = `Wait ${timeLeft}m`; buttonClass = 'claimed-button'; buttonStyle = 'background: #ccc; cursor: default;'; isDisabled = true;
                        } else if (isTaskCompleted && !adProgress.claimed) { // Watched all, not claimed
                            buttonText = 'Claim'; buttonClass = 'claim-button active'; buttonStyle = 'background: linear-gradient(to right, #00ff00, #66ff66);'; isDisabled = false;
                        } else { // Not completed watch count OR claimed+reset
                            buttonText = quest.action || 'Watch Ad'; buttonClass = 'go-button'; buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);';
                            isDisabled = adProgress.claimed && !isCooldownOver; // Should be covered by first 'if' but double-check
                        }

                        // Show reward and progress
                         rewardDisplay = `
                            <img src="assets/icons/gem.png" alt="Gem">
                            <span>+${quest.reward}</span>
                            ${quest.adLimit > 0 ? `<span class="progress">${adProgress.watched}/${quest.adLimit}</span>` : ''}
                         `;

                    } else {
                        // --- Non-Ad Quests ---
                        if (isCompletedGeneral) {
                            buttonText = 'Claimed'; buttonClass = 'claimed-button'; buttonStyle = 'background: #ccc; cursor: default;'; isDisabled = true;
                        } else {
                            buttonText = quest.action || 'GO'; buttonClass = 'go-button'; buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);'; isDisabled = false;
                        }
                        if (quest.reward > 0) {
                             rewardDisplay = `<img src="assets/icons/gem.png" alt="Gem"> <span>+${quest.reward}</span>`;
                        } else {
                             rewardDisplay = '';
                        }
                    }

                    // Construct the final list item HTML - REMOVED the problematic comments
                    return `
                        <li class="quest-item" data-quest-id="${quest.id}" data-quest-type="${quest.type}" data-ad-limit="${quest.adLimit}" data-ad-type="${quest.adType}" data-quest-reward="${quest.reward}">
                            <img src="${quest.icon}" alt="${quest.title}" onerror="this.src='https://via.placeholder.com/30/FFFFFF/000000?text=Q'">
                            <span>${quest.title}</span>
                            <div class="quest-reward">
                                ${rewardDisplay} {/* Actual reward/progress HTML generated above */}
                                <button class="${buttonClass}" data-quest-link="${quest.link}" data-quest-title="${quest.title}" style="${buttonStyle}" ${isDisabled ? 'disabled' : ''}>${buttonText}</button>
                            </div>
                        </li>
                    `;
                }).join('');
                // *** END OF UPDATED BASIC QUEST RENDERING LOGIC ***

                // debugLog("Earn section UI update completed successfully"); // Less verbose

            } catch (error) {
                debugLog(`[ERROR] Failed to update earn section UI: ${error.message}\nStack: ${error.stack}`);
                const dailyQuestList = document.getElementById('daily-quest-list');
                const basicQuestList = document.getElementById('basic-quest-list');
                const errorHtml = `<li class="error" style="color: #ffcc00;"><p>Failed to load quests. Please try again later.</p></li>`;
                if (dailyQuestList) dailyQuestList.innerHTML = errorHtml;
                if (basicQuestList) basicQuestList.innerHTML = errorHtml;
            }
        } // End of updateEarnSectionUI


        // Referral System
        function generateReferralLink() {
            if (!telegramUser || !telegramUser.id) {
                 debugLog("Cannot generate referral link: No user ID.");
                 return;
            }
            const botUsername = 'fourgobot'; // CHANGE THIS if your bot username is different
            const referralLink = `https://t.me/${botUsername}?start=ref_${telegramUser.id}`;
            const inviteButton = document.querySelector('.invite-friend');
            const copyButton = document.querySelector('.copy-link');
            if (inviteButton) inviteButton.setAttribute('data-link', referralLink);
            if (copyButton) copyButton.setAttribute('data-link', referralLink);
            // debugLog("Referral link generated: " + referralLink); // Less verbose
        }

        async function handleReferral() {
            if (!telegramUser || !telegramUser.id) {
                 debugLog("Cannot handle referral: No user ID.");
                 return;
            }
            if (!firebaseInitialized || !db) {
                debugLog("Firestore not initialized. Cannot handle referral.");
                return;
            }

            let startParam = null;
            try {
                 if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe) {
                     startParam = window.Telegram.WebApp.initDataUnsafe.start_param;
                     if(startParam) debugLog("Start parameter found: " + startParam);
                 } else {
                      debugLog("Telegram WebApp initData not available for referral check.");
                 }
            } catch (error) {
                 debugLog("Error accessing Telegram start_param: " + error.message);
                 return;
            }

            if (startParam && startParam.startsWith('ref_')) {
                const referrerId = startParam.split('_')[1];
                const currentUserId = telegramUser.id.toString();

                if (referrerId === currentUserId) {
                    debugLog("User tried to self-refer.");
                    return;
                }

                debugLog(`Handling referral: ${currentUserId} referred by ${referrerId}`);
                const userDocRef = db.collection('userData').doc(currentUserId);
                const referrerDocRef = db.collection('userData').doc(referrerId);

                try {
                    const userDoc = await userDocRef.get();
                    if (!userDoc.exists) {
                         debugLog("Current user document doesn't exist yet for referral. Initializing...");
                         await initializeUserData();
                    } else if (userDoc.data().isReferred === true) {
                         debugLog("User has already been referred.");
                         return;
                    }

                    const batch = db.batch();
                    batch.update(userDocRef, { isReferred: true });

                     const creditsPerReferral = 10;
                     const gemsPerReferral = 50;
                     const newRecord = {
                         userId: currentUserId,
                         username: telegramUser.username || telegramUser.first_name || `User_${currentUserId.substring(0,4)}`,
                         joinTime: new Date().toISOString().split('.')[0].replace('T', ' '),
                         credit: creditsPerReferral
                     };

                     // Update referrer's data: Check if referrer exists before updating
                     const referrerDoc = await referrerDocRef.get();
                     if (referrerDoc.exists) {
                         batch.update(referrerDocRef, {
                             referrals: firebase.firestore.FieldValue.increment(1),
                             gems: firebase.firestore.FieldValue.increment(gemsPerReferral),
                             totalCreditsEarnedFromInvites: firebase.firestore.FieldValue.increment(creditsPerReferral),
                             inviteRecords: firebase.firestore.FieldValue.arrayUnion(newRecord)
                         });
                         await batch.commit();
                         debugLog(`Referral handled successfully.`);
                         if (analytics) analytics.logEvent('referral_success', { referrerId: referrerId, newUserId: currentUserId });
                     } else {
                         debugLog(`Referrer (${referrerId}) document not found. Cannot award bonus, but marking user ${currentUserId} as referred.`);
                         // Commit only the user update part
                         await userDocRef.update({ isReferred: true });
                     }

                } catch (error) {
                    debugLog(`Error handling referral transaction: ${error.message}\nStack: ${error.stack}`);
                }
            }
        }


        async function updateInviteSectionUI() {
            if (!telegramUser || !telegramUser.id) {
                 debugLog("Cannot update invite UI: No valid user.");
                 return;
            }
            if (!firebaseInitialized || !db) {
                debugLog("Firestore not initialized. Cannot update invite section UI.");
                return;
            }
            const userIdStr = telegramUser.id.toString();
            try {
                const userDoc = await db.collection('userData').doc(userIdStr).get();
                 if (!userDoc.exists) {
                      debugLog("User data not found for invite section.");
                      document.getElementById('my-invite').textContent = `My Invite: 0`;
                      document.getElementById('total-credit').textContent = `Total Credit ! : 0`;
                      document.getElementById('invite-record-title').textContent = `Invite Record (0)`;
                      document.querySelector('.invite-record .record-list').innerHTML = `<div class="no-frens"><img src="assets/icons/nofrens.png" alt="No Frens"><p>Loading invites...</p></div>`;
                      return;
                 }

                const data = userDoc.data();
                const referrals = data.referrals || 0;
                const totalCredit = data.totalCreditsEarnedFromInvites || 0;
                const inviteRecords = data.inviteRecords || [];

                document.getElementById('my-invite').textContent = `My Invite: ${referrals}`;
                document.getElementById('total-credit').textContent = `Total Credit ! : ${totalCredit}`;
                document.getElementById('invite-record-title').textContent = `Invite Record (${inviteRecords.length})`;

                const recordList = document.querySelector('.invite-record .record-list');
                const claimRecordList = document.querySelector('.record-section'); // Placeholder

                if (inviteRecords.length === 0) {
                     recordList.innerHTML = `<div class="no-frens"><img src="assets/icons/nofrens.png" alt="No Frens"><p>No invites yet</p></div>`;
                 } else {
                     recordList.innerHTML = `
                         <div class="record-header">
                             <span>User</span>
                             <span>Join Time</span>
                             <span>Credit</span>
                         </div>
                         ${inviteRecords.map(record => `
                             <div class="record-item">
                                 <img src="https://via.placeholder.com/40/808080/000000?text=${(record.username || 'U')[0]}" alt="${record.username || 'User'}">
                                 <div class="user-info">
                                     <span>${record.username || 'Invited User'}</span>
                                     <small>${record.joinTime || 'N/A'}</small>
                                 </div>
                                 <span class="credit">${record.credit || 0}</span>
                             </div>`).join('')}`;
                 }

                 claimRecordList.innerHTML = `
                     <h3>Claim Record</h3>
                     <div class="no-frens">
                         <p>Claim history feature coming soon.</p> {/* Updated placeholder text */}
                     </div>`;

                const claimButton = document.querySelector('.invite-section .claim-button');
                 const creditToUsdtRate = 10000;
                 if (totalCredit >= creditToUsdtRate) {
                     claimButton.disabled = false;
                     claimButton.style.opacity = '1';
                     claimButton.textContent = 'Claim';
                 } else {
                     claimButton.disabled = true;
                     claimButton.style.opacity = '0.5';
                     claimButton.textContent = `Need ${creditToUsdtRate}`;
                 }

                // debugLog("Invite section UI updated successfully"); // Less verbose
            } catch (error) {
                debugLog(`Error updating invite section UI: ${error.message}\nStack: ${error.stack}`);
                 document.getElementById('my-invite').textContent = `My Invite: Error`;
                 document.getElementById('total-credit').textContent = `Total Credit ! : Error`;
            }
        }


        async function updateTopSectionUI() {
            if (!firebaseInitialized || !db) {
                debugLog("Firestore not initialized. Cannot update top section UI.");
                return;
            }
            const rankingList = document.getElementById('ranking-list');
            if (!rankingList) {
                debugLog("Ranking list element not found.");
                return;
            }
            rankingList.innerHTML = `<li class="no-rankings"><p>Loading rankings...</p></li>`;

            try {
                const rankingsSnapshot = await db.collection('users')
                    .orderBy('foxMedals', 'desc')
                    .limit(20)
                    .get();

                const rankings = [];
                rankingsSnapshot.forEach(doc => {
                    const data = doc.data();
                    rankings.push({
                        username: data.username || 'Anonymous',
                        foxMedals: data.foxMedals || 0,
                        photoUrl: data.photoUrl || 'https://via.placeholder.com/40/808080/000000?text=U'
                    });
                });

                if (rankings.length === 0) {
                    rankingList.innerHTML = `<li class="no-rankings"><p>No rankings available yet</p></li>`;
                } else {
                    rankingList.innerHTML = rankings.map((user, index) => `
                        <li class="ranking-item">
                             <span style="width: 30px; text-align: right; margin-right: 10px;">${index + 1}.</span>
                            <img src="${user.photoUrl}" alt="${user.username}" onerror="this.src='https://via.placeholder.com/40/808080/000000?text=U'">
                            <span>${user.username}</span>
                            <div class="medal-count">
                                <span>${user.foxMedals}</span>
                                <img src="assets/icons/fox-medal.png" alt="Fox Medal">
                            </div>
                        </li>
                    `).join('');
                }
                // debugLog("Top section UI updated successfully"); // Less verbose
            } catch (error) {
                debugLog(`Error updating top section UI: ${error.message}\nStack: ${error.stack}`);
                rankingList.innerHTML = `<li class="no-rankings" style="color: #ffcc00;"><p>Error loading rankings.</p></li>`;
            }
        }

        async function updateWalletSectionUI() {
            if (!firebaseInitialized || !db) {
                debugLog("Firestore not initialized. Cannot update wallet section UI.");
                return;
            }
             if (!telegramUser || !telegramUser.id) {
                  debugLog("Cannot update wallet UI: No valid user.");
                  return;
             }
            try {
                await updateUserStatsUI();
                await updateTransactionHistory();
                 await updateWalletUI(); // Refreshes connect button state etc.
                // debugLog("Wallet section UI updated successfully"); // Less verbose
            } catch (error) {
                debugLog(`Error updating wallet section UI: ${error.message}\nStack: ${error.stack}`);
            }
        }

        // Claim Credits Logic
        document.querySelector('.invite-section .claim-button').addEventListener('click', async () => {
            if (!telegramUser || !telegramUser.id) { alert("User not authenticated."); return; }
            if (!firebaseInitialized || !db) { alert("Database not initialized."); return; }

            const userIdStr = telegramUser.id.toString();
            const userDocRef = db.collection('userData').doc(userIdStr);
            const claimButton = document.querySelector('.invite-section .claim-button');

            claimButton.disabled = true; claimButton.textContent = 'Claiming...';
            debugLog("Attempting to claim credits...");

            let claimedAmount = 0; // Variable to store the claimed amount

            try {
                await db.runTransaction(async (transaction) => {
                    const userDoc = await transaction.get(userDocRef);
                    if (!userDoc.exists) throw new Error("User data not found.");

                    const data = userDoc.data();
                    const currentCredits = data.totalCreditsEarnedFromInvites || 0;
                    const creditToUsdtRate = 10000;

                    if (currentCredits < creditToUsdtRate) {
                        throw new Error(`Need ${creditToUsdtRate} credits (Have ${currentCredits})`);
                    }

                    const usdtToClaim = Math.floor(currentCredits / creditToUsdtRate);
                    const creditsToDeduct = usdtToClaim * creditToUsdtRate;
                    claimedAmount = usdtToClaim; // Store for success message

                    transaction.update(userDocRef, {
                        usdt: firebase.firestore.FieldValue.increment(usdtToClaim),
                        totalCreditsEarnedFromInvites: firebase.firestore.FieldValue.increment(-creditsToDeduct)
                    });
                    debugLog(`Transaction: Claiming ${usdtToClaim} USDT for ${creditsToDeduct} credits.`);
                });

                 alert(`Successfully claimed ${claimedAmount} USDT!`);
                 debugLog(`Successfully claimed ${claimedAmount} USDT.`);
                 if (analytics) {
                     analytics.logEvent('credit_claim_success', { userId: userIdStr, usdt: claimedAmount });
                     debugLog("Analytics: credit_claim_success logged");
                 }
                 await updateUserStatsUI();
                 await updateInviteSectionUI();

            } catch (error) {
                debugLog(`Error claiming credits: ${error.message}`);
                alert("Failed to claim credits: " + error.message);
                 if (analytics) {
                      analytics.logEvent('credit_claim_failed', { userId: userIdStr, error: error.message });
                      debugLog("Analytics: credit_claim_failed logged");
                 }
                 // Re-enable button state is handled by updateInviteSectionUI in finally
            } finally {
                 // Ensure UI is updated to reflect current state regardless of outcome
                 await updateInviteSectionUI();
            }
        });


        // Chest Slider Logic & Data
        const chests = [ // Example - consider fetching from Firestore
            { id: "wood", name: "Wood Chest", next: "Bronze", image: "assets/graphics/wood-chest.png", gemCost: 200, vip: 0, rewards: { usdtRange: [0.01, 0.05], landPieceChance: 0.1, foxMedalChance: 0.05 } },
            { id: "bronze", name: "Bronze Chest", next: "Silver", image: "assets/graphics/bronze-chest.png", gemCost: 500, vip: 1, rewards: { usdtRange: [0.03, 0.10], landPieceChance: 0.2, foxMedalChance: 0.1 } },
            { id: "silver", name: "Silver Chest", next: "Gold", image: "assets/graphics/silver-chest.png", gemCost: 1000, vip: 2, rewards: { usdtRange: [0.08, 0.25], landPieceChance: 0.35, foxMedalChance: 0.2 } },
            { id: "gold", name: "Gold Chest", next: "Master", image: "assets/graphics/gold-chest.png", gemCost: 2000, vip: 3, rewards: { usdtRange: [0.20, 0.60], landPieceChance: 0.5, foxMedalChance: 0.35 } },
            { id: "master", name: "Master Chest", next: "Legendary", image: "assets/graphics/master-chest.png", gemCost: 5000, vip: 4, rewards: { usdtRange: [0.50, 1.50], landPieceChance: 0.7, foxMedalChance: 0.5 } },
            { id: "legendary", name: "Legendary Chest", next: "Mythic", image: "assets/graphics/legendary-chest.png", gemCost: 10000, vip: 5, rewards: { usdtRange: [1.20, 3.00], landPieceChance: 0.9, foxMedalChance: 0.7 } },
            { id: "mythic", name: "Mythic Chest", next: "", image: "assets/graphics/mythic-chest.png", gemCost: 20000, vip: 6, rewards: { usdtRange: [2.50, 6.00], landPieceChance: 1.0, foxMedalChance: 0.9 } }
        ];

        let currentChestIndex = 0;
        const chestContainer = document.getElementById('chestContainer');
        const chestCostElement = document.getElementById('chestCost');
        const chestVipRequirementElement = document.getElementById('chestVipRequirement');
        const openChestButton = document.querySelector('.open-chest-button');

        function buildChestSlider() {
             if (!chestContainer) { debugLog("Chest container not found for building slider."); return; }
             chestContainer.innerHTML = chests.map(chest => `
                 <div class="chest-item">
                     <div class="chest-title">
                         <h2>${chest.name}</h2>
                         ${chest.next ? `<span>Next: ${chest.next}</span>` : ''}
                     </div>
                     <div class="chest-image">
                         <img src="${chest.image}" alt="${chest.name}" onerror="this.src='https://via.placeholder.com/150/1a1a3d/FFFFFF?text=Chest'">
                     </div>
                     <div class="not-enough" id="not-enough-${chest.id}" style="display: none;">
                         <span>NOT ENOUGH</span>
                         <img src="assets/icons/gem.png" alt="Gem">
                     </div>
                 </div>
             `).join('');
             ensureFirebaseReady(updateChestUI); // Initial UI update after building
        }

        async function updateChestUI() {
             if (!chestContainer || !chestCostElement || !chestVipRequirementElement || !openChestButton || chests.length === 0) return;

             const chest = chests[currentChestIndex];
             chestContainer.style.transform = `translateX(-${currentChestIndex * 100}%)`;

             chestCostElement.querySelector('span').textContent = chest.gemCost;
             if (chest.vip > 0) {
                 chestVipRequirementElement.textContent = `NEED VIP ${chest.vip}`;
                 chestVipRequirementElement.style.display = 'block';
                 chestCostElement.style.display = 'none';
             } else {
                 chestVipRequirementElement.style.display = 'none';
                 chestCostElement.style.display = 'flex';
             }

            let userGems = 0;
            let userVipLevel = 0;

             if (telegramUser && telegramUser.id && firebaseInitialized && db) {
                 try {
                     const userDoc = await db.collection('userData').doc(telegramUser.id.toString()).get();
                     if (userDoc.exists) {
                         userGems = userDoc.data().gems || 0;
                         userVipLevel = userDoc.data().vipLevel || 0;
                     }
                 } catch (error) {
                     debugLog("Error fetching user data for chest UI: " + error.message);
                 }
             }

             let canOpen = true;
             let reason = "";
             const notEnoughGemsElement = document.getElementById(`not-enough-${chest.id}`);

             if (chest.vip > userVipLevel) {
                  canOpen = false;
                  reason = `Requires VIP ${chest.vip}`;
                  chestVipRequirementElement.style.color = '#ffcc00';
                  if (notEnoughGemsElement) notEnoughGemsElement.style.display = 'none';
             } else {
                  chestVipRequirementElement.style.color = '#ccc';
                  if (userGems < chest.gemCost) {
                      canOpen = false;
                      reason = `Need ${chest.gemCost} Gems`;
                      if (notEnoughGemsElement) notEnoughGemsElement.style.display = 'flex';
                  } else {
                       if (notEnoughGemsElement) notEnoughGemsElement.style.display = 'none';
                  }
             }

             openChestButton.disabled = !canOpen;
             if (canOpen) {
                 openChestButton.textContent = `Open Chest (${chest.gemCost} Gems)`;
                 openChestButton.style.opacity = '1';
                 openChestButton.style.cursor = 'pointer';
                 openChestButton.style.background = 'linear-gradient(to right, #ff00ff, #ff6666)';
             } else {
                 openChestButton.textContent = reason || `Open Chest (${chest.gemCost} Gems)`;
                 openChestButton.style.opacity = '0.5';
                 openChestButton.style.cursor = 'not-allowed';
                 openChestButton.style.background = '#666';
             }

             document.querySelector('.nav-arrow.left').style.display = currentChestIndex === 0 ? 'none' : 'block';
             document.querySelector('.nav-arrow.right').style.display = currentChestIndex === chests.length - 1 ? 'none' : 'block';
        }

        async function updateChestSectionUI() {
             await updateChestUI();
        }

        window.nextChest = function() {
            if (currentChestIndex < chests.length - 1) {
                currentChestIndex++;
                ensureFirebaseReady(updateChestUI);
            }
        };

        window.prevChest = function() {
            if (currentChestIndex > 0) {
                currentChestIndex--;
                ensureFirebaseReady(updateChestUI);
            }
        };

        window.openChest = async function() {
            if (!telegramUser || !telegramUser.id) { alert("User not authenticated."); return; }
            if (!firebaseInitialized || !db) { alert("Database not initialized."); return; }
            if (openChestButton.disabled) { debugLog("Open chest button is disabled."); return; }

            const userIdStr = telegramUser.id.toString();
            const userDocRef = db.collection('userData').doc(userIdStr);
            const rankingDocRef = db.collection('users').doc(userIdStr);
            const chest = chests[currentChestIndex];

             openChestButton.disabled = true; openChestButton.textContent = 'Opening...';
             debugLog(`Attempting to open chest: ${chest.name}`);

            try {
                 const results = await db.runTransaction(async (transaction) => {
                     const userDoc = await transaction.get(userDocRef);
                     if (!userDoc.exists) throw new Error("User data not found.");

                     const userData = userDoc.data();
                     const currentGems = userData.gems || 0;
                     const currentVipLevel = userData.vipLevel || 0;

                     if (chest.vip > currentVipLevel) throw new Error(`Requires VIP ${chest.vip}`);
                     if (currentGems < chest.gemCost) throw new Error(`Not enough Gems (Need ${chest.gemCost})`);

                     const rewardsConfig = chest.rewards;
                     let usdtReward = 0, landPieceReward = 0, foxMedalReward = 0;

                     if (rewardsConfig.usdtRange) {
                          usdtReward = Math.random() * (rewardsConfig.usdtRange[1] - rewardsConfig.usdtRange[0]) + rewardsConfig.usdtRange[0];
                          usdtReward = parseFloat(usdtReward.toFixed(4));
                     }
                     if (rewardsConfig.landPieceChance && Math.random() < rewardsConfig.landPieceChance) landPieceReward = 1;
                     if (rewardsConfig.foxMedalChance && Math.random() < rewardsConfig.foxMedalChance) foxMedalReward = 1;

                     const updates = {
                         gems: firebase.firestore.FieldValue.increment(-chest.gemCost),
                         usdt: firebase.firestore.FieldValue.increment(usdtReward),
                         landPieces: firebase.firestore.FieldValue.increment(landPieceReward),
                         foxMedals: firebase.firestore.FieldValue.increment(foxMedalReward)
                     };
                     transaction.update(userDocRef, updates);

                      if (foxMedalReward > 0) {
                           transaction.set(rankingDocRef, {
                                foxMedals: firebase.firestore.FieldValue.increment(foxMedalReward)
                           }, { merge: true });
                      }
                     debugLog(`Transaction: Deducted ${chest.gemCost} gems. Rewards: USDT=${usdtReward}, Land=${landPieceReward}, Medal=${foxMedalReward}`);
                     return { usdt: usdtReward, land: landPieceReward, medal: foxMedalReward };
                 });

                 let rewardMessage = `Opened ${chest.name}! Rewards:`;
                 if (results.usdt > 0) rewardMessage += `\n- ${results.usdt.toFixed(4)} USDT`;
                 if (results.land > 0) rewardMessage += `\n- ${results.land} Land Piece`;
                 if (results.medal > 0) rewardMessage += `\n- ${results.medal} Fox Medal`;
                 if (results.usdt === 0 && results.land === 0 && results.medal === 0) rewardMessage += `\n- No special rewards this time.`;
                 alert(rewardMessage);
                 debugLog(`Chest opened successfully. Message: ${rewardMessage.replace('\n',' ')}`);

                 if (analytics) {
                     analytics.logEvent('chest_opened', { chestId: chest.id, chestName: chest.name, userId: userIdStr, usdtReward: results.usdt, landReward: results.land, medalReward: results.medal });
                     debugLog("Analytics: chest_opened logged");
                 }

                 await updateUserStatsUI();
                 await updateChestUI();
                 if (results.medal > 0) await updateTopSectionUI();

            } catch (error) {
                debugLog(`Error opening chest: ${error.message}\nStack: ${error.stack}`);
                alert("Failed to open chest: " + error.message);
                 // Re-enable button handled by updateChestUI in finally
            } finally {
                // Ensure button state is correct after operation
                 await updateChestUI();
            }
        };

        // Call buildChestSlider on load after DOM is ready
        document.addEventListener('DOMContentLoaded', buildChestSlider);


        // *** UPDATED CLICK EVENT LISTENER FOR QUESTS ***
        document.addEventListener('click', async (event) => {
            const button = event.target.closest('.quest-item button'); // Target button specifically
            if (!button || button.disabled) return; // Only handle enabled button clicks within quest items

            const taskItem = button.closest('.quest-item');
            if (!taskItem) return;

            const questId = taskItem.dataset.questId;
            const reward = parseInt(taskItem.dataset.questReward);
            const questType = taskItem.dataset.questType;
            const adLimit = parseInt(taskItem.dataset.adLimit) || 0;
            const adType = taskItem.dataset.adType || 'rewarded_interstitial';
            const link = button.dataset.questLink;

            if (!firebaseInitialized || !db) { alert("Database not initialized."); return; }
            if (!telegramUser || !telegramUser.id) { alert("User not identified."); return; }

            const userIdStr = telegramUser.id.toString();
            const userDocRef = db.collection('userData').doc(userIdStr);

            button.disabled = true;
            const originalButtonText = button.textContent;
            button.textContent = 'Processing...';
            debugLog(`Processing quest click: ${questId} (Type: ${questType}, Reward: ${reward})`);

            try {
                 const userDoc = await userDocRef.get();
                 if (!userDoc.exists) throw new Error("User data could not be loaded.");
                 const userData = userDoc.data();
                 userData.adProgress = userData.adProgress || {};
                 userData.claimedQuests = userData.claimedQuests || [];

                 // --- Check completion status based on latest data ---
                 const isZeroRewardAd = questType === 'ads' && reward === 0;
                 const isRewardAd = questType === 'ads' && reward > 0;
                 const isLinkQuest = questType !== 'ads';
                 const adProgress = userData.adProgress[questId] || { watched: 0, claimed: false, lastClaimed: null };
                 const lastClaimedTime = adProgress.lastClaimed ? new Date(adProgress.lastClaimed.seconds ? adProgress.lastClaimed.toDate() : adProgress.lastClaimed) : null; // Handle Timestamp or ISO string
                 const timeSinceLastClaim = lastClaimedTime ? new Date().getTime() - lastClaimedTime.getTime() : Infinity;
                 const cooldownPeriod = 3600000; // 1 hour

                 if (isZeroRewardAd && userData.claimedQuests.includes(questId)) {
                      throw new Error("Quest already completed.");
                 }
                 if (isRewardAd && adProgress.claimed && timeSinceLastClaim < cooldownPeriod) {
                     throw new Error("Quest is in cooldown.");
                 }
                 if (isLinkQuest && userData.claimedQuests.includes(questId)) {
                      throw new Error("Quest already claimed.");
                 }
                 // --- End completion check ---


                 // --- Handling Button Clicks ---

                 // 1. Claim button (Reward Ads)
                 if (button.classList.contains('claim-button') && isRewardAd) {
                     if (adProgress.watched < adLimit) throw new Error("Watch all ads first!");

                     debugLog(`Claiming reward for quest ${questId}`);
                     const currentTime = new Date(); // Capture time before update
                     await userDocRef.update({
                         gems: firebase.firestore.FieldValue.increment(reward),
                         [`adProgress.${questId}`]: {
                             watched: adProgress.watched,
                             claimed: true,
                             lastClaimed: currentTime // Store as JS Date (Firestore converts)
                         }
                     });
                     alert(`Reward claimed! +${reward} gems.`);
                     debugLog(`Reward claimed for ${questId}`);
                     if (analytics) analytics.logEvent('ads_quest_reward_claimed', { questId, userId: userIdStr, reward });

                 }
                 // 2. GO button (Ad Quests)
                 else if (button.classList.contains('go-button') && (isZeroRewardAd || isRewardAd)) {
                     const needsWatching = isZeroRewardAd || (isRewardAd && adProgress.watched < adLimit);

                     if (needsWatching) {
                         debugLog(`Attempting to show ad for quest: ${questId}, AdType: ${adType}`);

                         // --- Check if Ad SDK function exists ---
                         if (typeof window.show_9180370 !== 'function') {
                             debugLog("[AD ERROR] Ad SDK function (show_9180370) not found. Cannot show ad.");
                             alert("Ad service is unavailable. Please try again later or check for ad blockers.");
                             throw new Error("Ad SDK function not available."); // Stop processing
                         }
                         // --- End SDK check ---

                         await showAd(adType); // Trigger the ad (showAd now has better logging)

                         debugLog(`Ad function called for ${questId}. Assuming success, updating Firestore...`);
                         // --- Update Firestore based on quest type AFTER assumed ad success ---
                         if (isZeroRewardAd) {
                             await userDocRef.update({
                                 claimedQuests: firebase.firestore.FieldValue.arrayUnion(questId)
                             });
                             debugLog(`Zero-reward ad quest ${questId} marked completed.`);
                             alert(`Ad watched! Quest completed.`);
                             if (analytics) analytics.logEvent('ad_quest_watched', { questId, userId: userIdStr, reward: 0 });

                         } else { // isRewardAd
                             const newWatched = (adProgress.watched || 0) + 1; // Ensure watched is a number
                             await userDocRef.update({
                                 [`adProgress.${questId}.watched`]: newWatched
                             });
                             debugLog(`Reward ad watched for ${questId}, progress updated: ${newWatched}/${adLimit}`);
                             if (newWatched >= adLimit) {
                                 alert("All ads watched! Click 'Claim' to get your reward.");
                             } else {
                                 alert(`Ad watched! Progress: ${newWatched}/${adLimit}`);
                             }
                              if (analytics) analytics.logEvent('ad_quest_watched', { questId, userId: userIdStr, reward });
                         }
                     } else if (isRewardAd && adProgress.watched >= adLimit && !adProgress.claimed) {
                          alert("All ads watched! Click the 'Claim' button.");
                     } else {
                          debugLog(`[WARN] Unexpected state for ad quest button click: ${questId}`);
                     }

                 }
                 // 3. GO button (Link Quests)
                 else if (button.classList.contains('go-button') && isLinkQuest) {
                     debugLog(`Handling link quest: ${questId}, Link: ${link}`);
                     if (link) {
                         try {
                             Telegram.WebApp.openTelegramLink(link); // Use Telegram API
                             debugLog("Telegram link opened: " + link);
                         } catch (e) {
                             debugLog("Failed to open Telegram link automatically: " + e.message);
                             // Fallback or inform user
                             window.open(link, '_blank'); // Try standard browser open
                         }
                     } else {
                          debugLog("Link quest has no link defined: " + questId);
                     }

                     const updates = {
                         claimedQuests: firebase.firestore.FieldValue.arrayUnion(questId)
                     };
                     if (reward > 0) {
                         updates.gems = firebase.firestore.FieldValue.increment(reward);
                     }
                     await userDocRef.update(updates);
                     debugLog(`Link quest ${questId} marked completed. Reward: ${reward}`);

                     if (reward > 0) alert(`Quest completed! +${reward} gems.`);
                     else alert(`Quest completed!`);
                      if (analytics) analytics.logEvent('link_quest_completed', { questId, userId: userIdStr, reward });
                 } else {
                     debugLog(`[WARN] Unhandled button click state: ${button.classList} | Type: ${questType} | Reward: ${reward}`);
                     throw new Error("Unknown quest action.");
                 }

                 // --- Refresh UI sections AFTER successful action ---
                 await updateUserStatsUI();
                 await updateEarnSectionUI();

            } catch (error) {
                 debugLog(`[ERROR] Processing quest action (${questId}): ${error.message}\nStack: ${error.stack}`);
                 alert("Action failed: " + error.message);
                 // Restore button text BUT keep it disabled if the error wasn't just 'already claimed' or 'cooldown'
                 if (!error.message.includes("already completed") && !error.message.includes("cooldown")) {
                     button.disabled = false; // Re-enable only if it wasn't a completion/cooldown issue
                 }
                 button.textContent = originalButtonText;
                 // Optionally refresh UI again to show correct state after error if needed
                 await updateEarnSectionUI();
            }
        });
        // *** END OF UPDATED CLICK EVENT LISTENER ***


        // Invite Section Interactions
        document.querySelector('.invite-friend').addEventListener('click', () => {
            const link = document.querySelector('.invite-friend').getAttribute('data-link');
            if (link) {
                 try { Telegram.WebApp.openTelegramLink(link); } catch (e) { window.open(link, '_blank'); }
            } else {
                 alert("Could not generate invite link.");
                 generateReferralLink();
            }
        });

        document.querySelector('.copy-link').addEventListener('click', () => {
            const link = document.querySelector('.copy-link').getAttribute('data-link');
             if (link && navigator.clipboard) {
                 navigator.clipboard.writeText(link).then(() => {
                     alert("Referral link copied!");
                 }).catch(err => {
                      debugLog("Failed to copy link via clipboard API: " + err.message);
                      alert("Copy failed. Please copy manually:\n" + link);
                 });
            } else if (link) {
                 alert("Copy this link:\n" + link);
            } else {
                 alert("Could not get invite link.");
                 generateReferralLink();
            }
        });


        // *** UPDATED Function to show Monetag Ads ***
        function showAd(adType) {
            return new Promise((resolve, reject) => {
                const maxWaitTime = 10000; // 10 seconds timeout for SDK load check
                const startTime = Date.now();
                const adSdkFunction = window.show_9180370; // Check specific function

                debugLog(`[AD] Requesting ad type: ${adType}. SDK function available: ${typeof adSdkFunction === 'function'}`);

                function checkAndShow() {
                    if (typeof window.show_9180370 === 'function') { // Check again inside timeout
                        debugLog("[AD] SDK loaded. Triggering ad show_9180370...");
                        try {
                            window.show_9180370(); // Call the SDK function
                            debugLog(`[AD] SDK function show_9180370 called for ${adType}. Assuming success (no direct callback).`);
                            // Resolve after a short delay, assuming the ad will show.
                            // This is imperfect as we don't get confirmation from this specific SDK.
                            setTimeout(() => {
                                debugLog(`[AD] Assuming ad display completed for ${adType}.`);
                                resolve();
                            }, 1500); // Resolve slightly faster

                        } catch (error) {
                            debugLog(`[AD ERROR] Failed to trigger ad via SDK call: ${error.message}`);
                            alert("Could not trigger ad. Please try again."); // User feedback
                            reject(error);
                        }
                    } else if (Date.now() - startTime < maxWaitTime) {
                        // SDK not ready yet, retry
                        setTimeout(checkAndShow, 500);
                    } else {
                        // SDK failed to load within timeout
                        debugLog(`[AD ERROR] Ad SDK function (show_9180370) failed to load within ${maxWaitTime/1000}s.`);
                        alert("Ad service failed to load. Please check connection or disable ad blockers and try again."); // User feedback
                        reject(new Error("Ad SDK failed to load in time."));
                    }
                }
                checkAndShow(); // Start the check process
            });
        } // End of showAd


        // Initialize App
        async function initApp() {
            try {
                debugLog("--- Initializing App ---");
                await initializeFirebase();
                 if (!firebaseInitialized) throw new Error("Firebase could not be initialized.");

                await initializeUserData();
                await handleReferral();
                generateReferralLink();

                // Removed startup ad call

                // Initialize TON Connect and Wallet System
                tonConnectUI = await initializeTonConnect(); // Ensure this finishes
                await initWalletSystem(); // Depends on tonConnectUI

                // Initial UI refresh for the default section (Earn)
                await ensureFirebaseReady(updateEarnSectionUI);
                // buildChestSlider() is called via DOMContentLoaded listener now

                 debugLog("--- App initialization complete ---");

            } catch (error) {
                debugLog(`[CRITICAL] App initialization failed: ${error.message}\nStack: ${error.stack}`);
                alert("Failed to initialize the app. Please refresh and try again. Error: " + error.message);
                 const mainContent = document.querySelector('.main-content');
                 if (mainContent) {
                      mainContent.innerHTML = `<div style="padding: 20px; text-align: center; color: #ffcc00;"><h2>Initialization Error</h2><p>Could not start the application. Please try refreshing.</p><p><small>Details: ${error.message}</small></p></div>`;
                 }
            }
        } // End of initApp

        // Call initApp when the page loads and DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            debugLog("DOM loaded, starting initApp...");
            initApp(); // Start the main initialization sequence
        });


        // ====== TON CONNECT IMPLEMENTATION ====== //

        let tonConnectUI = null;

        // Get wallet-related DOM elements (no changes needed)
        function getWalletElements() { /* ... */ }

        // Create TON Connect UI manually (fallback - no changes needed)
        function createManualTonConnectUI() { /* ... */ }

        // Create TON Connect UI with inline script (no changes needed)
        function createInlineScriptTonConnectUI() { /* ... */ }

        // Initialize TON Connect with multiple strategies (no changes needed)
        async function initializeTonConnect() { /* ... */ }

        // Update wallet UI based on connection status (no changes needed)
        async function updateWalletUI() { /* ... */ }

        // Handle wallet connection/disconnection button click (no changes needed)
        async function handleConnectClick() { /* ... */ }

        // Initialize wallet system (no changes needed)
        async function initWalletSystem() { /* ... */ }

         // Named handler for withdraw button clicks (no changes needed)
         function withdrawButtonClickHandler(event) { /* ... */ }

        // Show withdraw modal (no changes needed)
        function showWithdrawModal(card) { /* ... */ }

        // Confirm withdrawal (Simulated TX - no changes needed)
        async function confirmWithdraw(currency, balance, fee, minWithdrawal) { /* ... */ }

        // Update transaction history (no changes needed)
        async function updateTransactionHistory() { /* ... */ }

        // --- Re-fetch necessary DOM element functions or ensure they are defined above ---
        // Example: (assuming getWalletElements is defined as before)
        function getWalletElements() {
            const elements = {
                connectButton: document.querySelector('.connect-button'),
                connectionStatus: document.getElementById('connection-status'),
                withdrawButtons: document.querySelectorAll('.withdraw-button'),
                walletSection: document.getElementById('wallet')
            };
            // debugLog(`Wallet elements check: connectButton=${!!elements.connectButton}, status=${!!elements.connectionStatus}`); // Less verbose
            return elements;
        }
        // Add other necessary functions like createManualTonConnectUI, createInlineScriptTonConnectUI etc. from the previous version here...
        // [Ensure all the TON Connect related functions provided in the previous code block are included here]
        // ... (rest of the TON connect functions as provided before) ...

    </script>
</body>
</html>
