<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4Metas Mini App</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src='//whephiwums.com/sdk.js' data-zone='9180370' data-sdk='show_9180370'></script>
    <style>
        /* Updated body structure */
        body {
            background: linear-gradient(to bottom, #330033, #000000);
            color: white;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Main content area */
        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            padding-bottom: 70px; /* Space for bottom nav */
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            position: sticky;
            top: 0;
            background: linear-gradient(to bottom, #330033, #000000);
            z-index: 1000;
        }
        header h1 {
            font-size: 24px;
            margin: 0;
        }
        .back-arrow, .menu-dots {
            font-size: 24px;
            cursor: pointer;
        }
        .user-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 0 10px;
        }
        .user-stats .logo img {
            width: 50px;
            height: 50px;
        }
        .user-stats .metric {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .user-stats .metric img {
            width: 20px;
            height: 20px;
        }
        .user-stats .profile-pic img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        .section {
            display: none; /* Sections hidden by default */
        }
        .section.active {
            display: block; /* Active section is visible */
        }
        .banner-placeholder {
            background: #1a1a3d;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            margin-bottom: 20px;
        }
        .banner-placeholder img {
            width: 100%;
            border-radius: 10px;
        }
        .quest-section h2 {
            font-size: 18px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .quest-section .badge {
            background: #ff00ff;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
        }
        .quest-list {
            list-style: none;
            padding: 0;
        }
        /* Style for error messages in lists */
        .quest-list .error p {
             color: #ffcc00; /* Yellow/Orange for errors */
             font-style: italic;
        }
        .quest-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .quest-item img {
            width: 30px;
            height: 30px;
            border-radius: 50%;
        }
        .quest-reward {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .quest-reward img {
            width: 20px;
            height: 20px;
        }
        .go-button, .claim-button, .claimed-button {
            border: none;
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
        }
        .go-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
        }
        .claim-button {
            background: linear-gradient(to right, #00ff00, #66ff66); /* Default claim button */
        }
        .claimed-button {
            background: #ccc;
            cursor: default;
        }
        .quest-item .progress {
            font-size: 12px;
            color: #ccc;
            margin-left: 10px;
        }
        .claim-button.active {
             background: linear-gradient(to right, #00ff00, #66ff66); /* Active (ready to claim) state */
        }
        .wallet-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .balance-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .balance-card img {
            width: 30px;
            height: 30px;
        }
        .balance-info span {
            display: block;
            font-size: 16px;
        }
        .balance-info small {
            font-size: 12px;
            color: #ccc;
        }
        .withdraw-button {
            background: #666; /* Default disabled color */
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
        }
         .withdraw-button:not(:disabled) {
             background: #00ff00; /* Enabled color */
         }
        .warning-button {
            background: #ffcc00;
            border: none;
            color: black;
            padding: 5px 10px;
            border-radius: 50%;
            cursor: pointer;
        }
        .connect-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 15px;
            width: 100%;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.3s ease;
        }
        .connect-button.connected {
            background: linear-gradient(to right, #00ff00, #66ff66);
        }
        .connect-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .wallet-status {
            text-align: center;
            margin: 10px 0;
        }
        .wallet-status.connected {
            color: #00ff00;
        }
        .wallet-status.disconnected {
            color: #ffcc00;
        }
        .transaction-history {
            margin-top: 20px;
        }
        .transaction-history ul {
            list-style: none;
            padding: 0;
        }
        .transaction-history li {
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-content {
            background: #1a1a3d;
            padding: 20px;
            border-radius: 10px;
            color: white;
            width: 80%;
            max-width: 400px;
        }
        .modal-content input {
            width: calc(100% - 12px); /* Adjust for padding */
            padding: 5px;
            margin: 10px 0;
            box-sizing: border-box; /* Include padding in width */
        }
        .game-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .game-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); /* Responsive grid */
            gap: 10px;
        }
        .game-item {
            background: #1a1a3d;
            border-radius: 10px;
            text-align: center;
            padding: 5px;
        }
        .game-item img {
            width: 100%;
            max-width: 80px; /* Limit image size */
            height: auto;   /* Maintain aspect ratio */
            border-radius: 10px;
        }
        .game-item p {
            margin: 5px 0;
            font-size: 12px;
        }
        .invite-section .invite-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .invite-stats .spin-info {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .action-button {
            background: linear-gradient(to right, #00ff00, #66ff66);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 15px;
            flex: 1;
            cursor: pointer;
        }
        .total-credit {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
         .total-credit .credit-info { /* Wrapper for text */
             display: flex;
             flex-direction: column; /* Stack text */
         }
        .total-credit small {
            font-size: 12px;
            color: #ccc;
            display: flex; /* Align image and text */
            align-items: center;
            gap: 3px;
        }
        .total-credit small img {
            width: 15px;
            height: 15px;
            vertical-align: middle; /* Better alignment */
        }
        .record-section h3, .invite-record h3 {
            font-size: 16px;
            margin: 10px 0;
        }
        .no-frens {
            text-align: center;
            color: #ccc;
            padding: 20px 0; /* Add some padding */
        }
        .no-frens img {
            width: 50px;
            height: 50px;
            margin-bottom: 10px; /* Space below image */
        }
        .record-header {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #ccc;
            margin-bottom: 10px;
            padding: 0 10px; /* Align with items */
        }
         .record-list { /* Container for items or no-frens message */
             /* Optional: Add styling if needed */
         }
        .record-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .record-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        .record-item .user-info {
            flex: 1;
            margin-left: 10px;
        }
        .record-item .user-info span {
             display: block; /* Ensure username is on its own line */
         }
        .record-item .user-info small {
            color: #ccc;
            font-size: 12px;
        }
        .record-item .credit {
            background: #ff00ff;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px; /* Slightly smaller */
        }
        .chest-section .chest-slider {
            position: relative;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .chest-container {
            display: flex;
            transition: transform 0.3s ease;
        }
        .chest-item {
            flex: 0 0 100%;
            text-align: center;
            padding: 10px; /* Add padding */
            box-sizing: border-box;
        }
        .chest-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 16px;
            margin-bottom: 10px; /* Space below title */
        }
        .chest-title span {
            color: #ccc;
            font-size: 14px; /* Smaller text */
        }
        .chest-image img {
            width: 150px;
            height: 150px;
            margin-bottom: 10px; /* Space below image */
        }
        .not-enough {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            color: #ffcc00;
            margin-top: 10px;
        }
        .not-enough img {
            width: 20px;
            height: 20px;
        }
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.5);
            border: none;
            color: white;
            padding: 10px;
            cursor: pointer;
            z-index: 100;
            border-radius: 50%; /* Make arrows round */
        }
        .nav-arrow.left {
            left: 5px; /* Adjust position */
        }
        .nav-arrow.right {
            right: 5px; /* Adjust position */
        }
        .rewards {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
        }
        .reward-item {
            text-align: center;
        }
        .reward-item img {
            width: 40px;
            height: 40px;
        }
        .reward-item p {
            margin: 5px 0;
            font-size: 12px;
        }
        .cost {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            margin-bottom: 10px;
            font-size: 16px; /* Make cost text larger */
        }
        .cost img {
            width: 20px;
            height: 20px;
        }
        .vip-requirement {
            text-align: center;
            color: #ffcc00;
            margin-bottom: 10px;
        }
        .open-chest-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 15px;
            width: 100%;
            cursor: pointer;
            font-size: 16px; /* Make button text larger */
        }
        .top-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .ranking-list {
            list-style: none;
            padding: 0;
        }
         .no-rankings {
             text-align: center;
             color: #ccc;
             padding: 20px 0;
         }
        .ranking-item {
            display: flex;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .ranking-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .ranking-item span {
            flex: 1;
        }
        .ranking-item .medal-count {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .ranking-item .medal-count img {
            width: 20px;
            height: 20px;
        }

        /* --- Navigation Styles --- */
        nav.bottom-nav {
            display: flex !important;
            justify-content: space-around !important;
            background: #1a1a3d !important;
            padding: 5px 0 !important; /* Adjusted padding */
            position: fixed !important;
            bottom: 0 !important; /* Use 0, handle safe area via padding/margin if needed */
            padding-bottom: env(safe-area-inset-bottom, 5px) !important; /* Add padding for safe area */
            left: 0 !important;
            right: 0 !important;
            z-index: 100000 !important;
            height: 60px !important; /* Maintain height */
            visibility: visible !important;
            opacity: 1 !important;
            border-top: 1px solid #ff00ff !important; /* Adjusted border */
            box-shadow: 0 -2px 10px rgba(100, 0, 100, 0.4) !important; /* Adjusted shadow */
        }

        nav.bottom-nav .nav-button {
            background: none !important;
            border: none !important;
            color: #ccc !important;
            display: flex !important;
            flex-direction: column !important;
            align-items: center !important;
            justify-content: center !important;
            cursor: pointer !important;
            font-size: 10px !important; /* Slightly smaller text */
            width: auto !important; /* Allow flexible width */
            flex: 1 !important; /* Distribute space equally */
            height: 100% !important;
            visibility: visible !important;
            opacity: 1 !important;
            min-height: 40px !important;
            padding: 0 2px; /* Add minimal horizontal padding */
        }

        nav.bottom-nav .nav-button.active {
            color: white !important;
        }

        nav.bottom-nav .nav-button img {
            width: 24px !important;
            height: 24px !important;
            margin-bottom: 3px !important; /* Adjusted spacing */
            display: block !important;
        }

        nav.bottom-nav .nav-button span {
            display: block !important;
            white-space: nowrap; /* Prevent text wrapping */
        }

        /* Additional styles for wallet integration */
        .error-message {
            color: #ffcc00;
            text-align: center;
            margin: 10px 0;
            display: none;
        }

        .tx-status.pending { color: #ffcc00; }
        .tx-status.completed { color: #00ff00; }
        .tx-status.failed { color: #ff0000; }

        /* Debug Console Style */
         #debugConsole {
             position: fixed;
             bottom: 70px; /* Above nav bar */
             left: 0;
             right: 0;
             background: rgba(0,0,0,0.85); /* Slightly more opaque */
             color: #0f0; /* Green text */
             padding: 10px;
             font-family: monospace;
             font-size: 10px; /* Smaller font */
             max-height: 150px; /* Adjust height */
             overflow-y: auto;
             z-index: 99999; /* Below nav bar but high */
             display: none; /* Hidden by default */
             border-top: 1px solid #0f0;
         }
         #toggleDebugButton { /* Style the toggle button */
            position: fixed;
            bottom: 80px; /* Position relative to debug console */
            right: 10px;
            z-index: 100000; /* Above debug console */
            padding: 3px 8px;
            background: #ff00ff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 10px;
            cursor: pointer;
         }

    </style>
</head>
<body>
    <header>
        <div class="back-arrow">X</div>
        <h1>4Metas</h1>
        <div class="menu-dots">â‹®</div>
    </header>

    <div class="main-content">
        <section class="user-stats">
            <div class="logo">
                <img src="assets/icons/logo.png" alt="4Metas Logo">
            </div>
            <div class="metric">
                <img src="assets/icons/gem.png" alt="Gem">
                <span id="gems">0</span>
            </div>
            <div class="metric">
                <img src="assets/icons/usdt.png" alt="USDT">
                <span id="usdt">0.0000</span>
            </div>
            <div class="metric">
                <img src="assets/icons/ton.png" alt="TON">
                <span id="ton">0.0000</span>
            </div>
            <div class="profile-pic">
                <img src="assets/icons/user-avatar.png" alt="User Profile">
            </div>
        </section>

        <section id="earn" class="section earn-section active">
            <div class="banner-placeholder">
                <img src="assets/icons/banner.png" alt="Banner">
            </div>
            <div class="quest-section">
                <h2>DAILY QUEST <span class="badge" id="daily-quest-count">0</span></h2>
                <ul class="quest-list" id="daily-quest-list">
                    <li class="no-quests">
                        <p>Loading daily quests...</p> </li>
                </ul>
            </div>
            <div class="quest-section">
                <h2>BASIC QUEST <span class="badge" id="basic-quest-count">0</span></h2>
                <ul class="quest-list" id="basic-quest-list">
                    <li class="no-quests">
                        <p>Loading basic quests...</p> </li>
                </ul>
            </div>
        </section>

        <section id="wallet" class="section wallet-section">
            <h2>Wallet</h2>
            <div class="wallet-status disconnected">
                <span id="connection-status">Disconnected</span>
            </div>
            <div class="balance-card usdt-card">
                <img src="assets/icons/usdt.png" alt="USDT Icon">
                <div class="balance-info">
                    <span id="wallet-usdt">0.0000</span>
                    <small>USDT</small>
                </div>
                <button class="withdraw-button" disabled>WITHDRAW</button>
                <button class="warning-button">!</button>
            </div>
            <div class="balance-card ton-card">
                <img src="assets/icons/ton.png" alt="TON Icon">
                <div class="balance-info">
                    <span id="wallet-ton">0.0000</span>
                    <small>TON</small>
                </div>
                <button class="withdraw-button" disabled>WITHDRAW</button>
                <button class="warning-button">!</button>
            </div>
            <p class="instruction">Connect wallet to withdraw your balance.</p>
            <button class="connect-button">CONNECT TON WALLET</button>
            <div class="transaction-history">
                <h3>Transaction History</h3>
                <ul id="transaction-list">
                    <li>No transactions yet</li>
                </ul>
            </div>
            <div id="withdraw-modal" class="modal" style="display: none;">
                <div class="modal-content">
                    <h3>Withdraw Funds</h3>
                    <label>Amount: <input type="number" id="withdraw-amount" min="0" step="0.0001"></label>
                    <p>Available: <span id="available-balance">0</span> <span id="currency"></span></p>
                    <p>Fee: <span id="withdraw-fee">0</span> <span id="fee-currency"></span></p>
                    <button id="confirm-withdraw">Confirm</button>
                    <button id="cancel-withdraw">Cancel</button>
                </div>
            </div>
        </section>

        <section id="game" class="section game-section">
            <div class="banner-placeholder">
                <img src="assets/icons/game-banner.png" alt="Game Banner">
            </div>
            <h2>Game List</h2>
            <div class="game-list">
                 <div class="game-item"><img src="https://via.placeholder.com/80/FF0000/FFFFFF?text=TG" alt="Traffic Go"><p>Traffic Go</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/00FF00/FFFFFF?text=CM" alt="Cutting Master"><p>Cutting Master</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/0000FF/FFFFFF?text=EM" alt="Element Magic"><p>Element Magic</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FFFF00/000000?text=JS" alt="Juicy Splash"><p>Juicy Splash</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FF00FF/FFFFFF?text=COR" alt="Creed of Rescue"><p>Creed of Rescue</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/00FFFF/000000?text=FJ" alt="Farm Jam"><p>Farm Jam</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FFA500/FFFFFF?text=2048" alt="2048 Blocks"><p>2048 Blocks</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/800080/FFFFFF?text=CRC" alt="Cut Rope Combo"><p>Cut Rope Combo</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/008000/FFFFFF?text=HJ" alt="Happy Jelly Jump"><p>Happy Jelly Jump</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/000080/FFFFFF?text=UTR" alt="Undersea Tunnel Race"><p>Undersea Tunnel Race</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FFC0CB/000000?text=MM" alt="Motor Master"><p>Motor Master</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FFD700/000000?text=OF" alt="Open Fire"><p>Open Fire</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/ADFF2F/000000?text=MTD" alt="Monster TD"><p>Monster TD</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FF4500/FFFFFF?text=BW" alt="Bloody Warrior"><p>Bloody Warrior</p></div>
            </div>
        </section>

        <section id="invite" class="section invite-section">
            <div class="invite-stats">
                <span id="my-invite">My Invite: 0</span>
                <div class="spin-info">
                    <span>Spin x0</span>
                    <span class="warning">!</span>
                </div>
            </div>
            <div class="action-buttons">
                <button class="action-button invite-friend">Invite Friend</button>
                <button class="action-button copy-link">Copy Link</button>
            </div>
            <div class="total-credit">
                <div class="credit-info">
                    <span id="total-credit-text">Total Credit <span class="warning">!</span> : 0</span> <small>10,000 = 1 <img src="assets/icons/usdt.png" alt="USDT"></small>
                </div>
                <button class="claim-button">Claim</button>
            </div>
            <div class="record-section">
                <h3>Claim Record</h3>
                 <div class="no-frens" id="claim-record-placeholder">
                     <img src="assets/icons/nofrens.png" alt="No Claims">
                     <p>No claim records yet</p>
                 </div>
                 <div id="claim-record-list"></div>
            </div>
            <div class="invite-record">
                <h3 id="invite-record-title">Invite Record (0)</h3>
                <div class="record-header">
                    <span>User</span>
                    <span>Join Time</span>
                    <span>Credit</span>
                </div>
                <div class="record-list" id="invite-record-list"> <div class="no-frens" id="invite-record-placeholder"> <img src="assets/icons/nofrens.png" alt="No Frens">
                        <p>No invites yet</p>
                    </div>
                     </div>
            </div>
        </section>

        <section id="chest" class="section chest-section">
             <h2>Chests</h2> <div class="chest-slider">
                <button class="nav-arrow left" onclick="prevChest()">&lt;</button>
                <div class="chest-container" id="chestContainer">
                    <div class="chest-item">
                         <div class="chest-title">
                             <h2>Wood Chest</h2>
                             <span>Bronze</span>
                         </div>
                         <div class="chest-image"><img src="assets/graphics/wood-chest.png" alt="Wood Chest"></div>
                         <div class="not-enough" style="display:none;"><img src="assets/icons/gem.png" alt="Gem"><span>NOT ENOUGH</span></div>
                     </div>
                     </div>
                <button class="nav-arrow right" onclick="nextChest()">&gt;</button>
            </div>
             <h3>Possible Rewards</h3> <div class="rewards">
                <div class="reward-item usdt"><img src="assets/icons/usdt.png" alt="USDT"><p>USDT</p></div>
                <div class="reward-item land-piece"><img src="assets/icons/land-piece.png" alt="Land Piece"><p>Land Piece</p></div>
                <div class="reward-item fox-medal"><img src="assets/icons/fox-medal.png" alt="Fox Medal"><p>Fox Medal</p></div>
            </div>
            <div class="cost" id="chestCost">
                <img src="assets/icons/gem.png" alt="Gem">
                <span id="chest-cost-amount">200</span> </div>
            <div class="vip-requirement" id="chestVipRequirement" style="display: none;">
                NEED VIP 1
            </div>
            <button class="open-chest-button" onclick="openChest()">Open Chest</button>
        </section>

        <section id="top" class="section top-section">
            <h2>Medal Ranking <span class="warning">!</span></h2>
            <ul class="ranking-list" id="ranking-list">
                <li class="no-rankings">
                    <p>Loading rankings...</p> </li>
            </ul>
        </section>
    </div>

    <nav class="bottom-nav">
        <button class="nav-button active" data-section="earn"> <img src="assets/icons/earn.png" alt="Earn">
            <span>Earn</span>
        </button>
        <button class="nav-button" data-section="wallet">
            <img src="assets/icons/wallet.png" alt="Wallet">
            <span>Wallet</span>
        </button>
        <button class="nav-button" data-section="game">
            <img src="assets/icons/game.png" alt="Game">
            <span>Game</span>
        </button>
        <button class="nav-button" data-section="invite">
            <img src="assets/icons/invite.png" alt="Invite">
            <span>Invite</span>
        </button>
        <button class="nav-button" data-section="chest">
            <img src="assets/icons/chest.png" alt="Chest">
            <span>Chest</span>
        </button>
        <button class="nav-button" data-section="top">
            <img src="assets/icons/top.png" alt="Top">
            <span>Top</span>
        </button>
    </nav>

    <div id="debugConsole"></div>
    <button id="toggleDebugButton" onclick="document.getElementById('debugConsole').style.display =
        document.getElementById('debugConsole').style.display === 'none' ? 'block' : 'none'">
        Debug
    </button>

    <script>
        console.log('[DEBUG] Script execution started.');

        // --- Global Variables ---
        let app, db, auth, storage, analytics;
        let firebaseInitialized = false;
        let telegramUser;
        let tonConnectUI = null;
        let currentChestIndex = 0; // Keep track of chest slider

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCUkEmFmJK2vr8k7M6JqYaxlcgBDf7WdJI", // WARNING: Exposing API key is insecure for production
            authDomain: "fourgo-cd98f.firebaseapp.com",
            projectId: "fourgo-cd98f",
            storageBucket: "fourgo-cd98f.firebasestorage.app",
            messagingSenderId: "511215742272",
            appId: "1:511215742272:web:04bd85a284919ae123dea5",
            measurementId: "G-DC7E6ECF2L"
        };

         // Chest Data (Consider fetching from Firestore later)
         const chests = [
             { name: "Wood Chest", next: "Bronze", image: "assets/graphics/wood-chest.png", gemCost: 200, vip: 0 },
             { name: "Bronze Chest", next: "Silver", image: "assets/graphics/bronze-chest.png", gemCost: 500, vip: 1 },
             { name: "Silver Chest", next: "Gold", image: "assets/graphics/silver-chest.png", gemCost: 1000, vip: 2 },
             { name: "Gold Chest", next: "Master", image: "assets/graphics/gold-chest.png", gemCost: 2000, vip: 3 },
             { name: "Master Chest", next: "Legendary", image: "assets/graphics/master-chest.png", gemCost: 5000, vip: 4 },
             { name: "Legendary Chest", next: "Mythic", image: "assets/graphics/legendary-chest.png", gemCost: 10000, vip: 5 },
             { name: "Mythic Chest", next: "", image: "assets/graphics/mythic-chest.png", gemCost: 20000, vip: 6 }
         ];


        // --- Utility Functions ---

        // Debug Logging Helper
        function debugLog(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[DEBUG] ${timestamp}: ${message}`, data !== null ? data : '');
            const debugConsole = document.getElementById('debugConsole');
            if (debugConsole) {
                const entry = document.createElement('div');
                entry.textContent = `${timestamp}: ${message}${data ? ` - ${JSON.stringify(data)}` : ''}`;
                debugConsole.appendChild(entry);
                // Auto-scroll to bottom
                debugConsole.scrollTop = debugConsole.scrollHeight;
            }
        }

        // Dynamically load a script and return a Promise
        function loadScript(src, retries = 3, delay = 1000) {
             debugLog(`Attempting to load script: ${src}`);
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const tryLoad = () => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.async = true;
                    script.onload = () => {
                        debugLog(`Script loaded successfully: ${src}`);
                        resolve();
                    };
                    script.onerror = () => {
                        attempts++;
                        if (attempts < retries) {
                            console.warn(`Failed to load script: ${src}. Retrying (${attempts}/${retries})...`);
                            setTimeout(tryLoad, delay);
                        } else {
                            const errorMsg = `Failed to load script after ${retries} attempts: ${src}`;
                            console.error(errorMsg);
                            debugLog(errorMsg); // Log to debug console too
                            reject(new Error(errorMsg));
                        }
                    };
                    document.head.appendChild(script);
                };
                tryLoad();
            });
        }

        // Validate Firebase Configuration
        function validateFirebaseConfig(config) {
            const requiredFields = ['apiKey', 'authDomain', 'projectId', 'storageBucket', 'messagingSenderId', 'appId'];
            for (const field of requiredFields) {
                if (!config[field]) {
                    throw new Error(`Firebase config is missing required field: ${field}`);
                }
            }
            debugLog("Firebase config validated successfully");
        }

        // --- Firebase Initialization ---
        async function initializeFirebase(maxRetries = 3) {
            debugLog("Initializing Firebase...");
            if (firebaseInitialized) {
                debugLog("Firebase already initialized.");
                return true;
            }
            if (window.firebase && window.firebase.apps && window.firebase.apps.length > 0) {
                 debugLog("Firebase detected in global scope, reusing existing instance.");
                 app = window.firebase.apps[0];
                 db = app.firestore();
                 auth = app.auth();
                 storage = app.storage();
                 try { analytics = app.analytics(); } catch (e) { console.warn("Analytics setup failed:", e.message); }
                 firebaseInitialized = true;
                 return true;
            }

            let attempts = 0;
            const scriptUrls = [
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-app-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-auth-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-storage-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-analytics-compat.js'
            ];

            while (attempts < maxRetries && !firebaseInitialized) {
                try {
                    debugLog(`Attempt ${attempts + 1}/${maxRetries} to initialize Firebase...`);
                    validateFirebaseConfig(firebaseConfig);

                    await Promise.all(scriptUrls.map(url => loadScript(url, 1))); // Try each script once per attempt
                    if (typeof firebase === 'undefined' || typeof firebase.initializeApp === 'undefined') {
                         throw new Error("Firebase SDK core not loaded correctly.");
                    }

                    // Check if already initialized within this attempt
                    if (firebase.apps.length === 0) {
                         app = firebase.initializeApp(firebaseConfig);
                         debugLog("Firebase app initialized.");
                    } else {
                         app = firebase.apps[0];
                         debugLog("Reusing existing Firebase app instance.");
                    }

                    db = firebase.firestore();
                    auth = firebase.auth();
                    storage = firebase.storage();
                    try { analytics = firebase.analytics(); } catch (e) { console.warn("Analytics setup failed:", e.message); }

                    // Test Firestore connection
                    await db.collection('internal_status').doc('init_test').set({
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        status: 'ok'
                    }, { merge: true });

                    firebaseInitialized = true;
                    debugLog("Firebase fully initialized and connected.");
                    return true;
                } catch (error) {
                    attempts++;
                    console.error(`Firebase initialization attempt ${attempts} failed:`, error);
                    debugLog(`Firebase init attempt ${attempts} failed: ${error.message}`);
                    if (attempts >= maxRetries) {
                        console.error("Max retries reached. Firebase initialization failed definitively.");
                        debugLog("Max retries reached. Firebase initialization failed definitively.");
                        alert("Error connecting to the database. Please restart the app."); // User feedback
                        return false;
                    }
                    await new Promise(resolve => setTimeout(resolve, 2000)); // Wait before retry
                }
            }
            return false;
        }

        // Helper to ensure Firebase is ready before running a callback
        async function ensureFirebaseReady(callback, callbackName = 'Unnamed Callback') {
             debugLog(`Ensuring Firebase is ready for: ${callbackName}`);
            if (!firebaseInitialized || !db) {
                debugLog("Firebase not ready, attempting initialization...");
                const success = await initializeFirebase();
                if (!success) {
                    console.error("Firebase initialization failed after retries. Cannot proceed.");
                    debugLog(`Firebase init failed, cannot execute ${callbackName}`);
                    alert("Database connection failed. Please try again later.");
                    return; // Stop execution if Firebase fails
                }
            }
             debugLog(`Firebase ready, executing: ${callbackName}`);
             try {
                 await callback();
                 debugLog(`Successfully executed: ${callbackName}`);
             } catch (error) {
                 console.error(`Error during ${callbackName}:`, error);
                 debugLog(`Error during ${callbackName}: ${error.message}`);
                 // Optionally show an error to the user
                 // alert(`An error occurred while loading data for ${callbackName}.`);
             }
         }


        // --- Telegram Web App Setup ---
        function initializeTelegram() {
             debugLog("Initializing Telegram Web App...");
            try {
                if (!window.Telegram || !window.Telegram.WebApp) {
                    throw new Error("Telegram WebApp script not loaded or available.");
                }
                window.Telegram.WebApp.ready();
                telegramUser = window.Telegram.WebApp.initDataUnsafe?.user; // Use optional chaining

                if (telegramUser) {
                    debugLog("Telegram user data found:", { id: telegramUser.id, username: telegramUser.username });
                    const profilePic = document.querySelector('.profile-pic img');
                    if (profilePic) {
                        profilePic.src = telegramUser.photo_url || 'assets/icons/user-avatar.png';
                    }
                    // document.querySelector('h1').innerText = `4Metas`; // Keep title static?
                } else {
                    console.warn("No Telegram user data available. Running in test mode.");
                    debugLog("No Telegram user data found. Using test user.");
                    // Define a fallback test user if needed for development outside Telegram
                    telegramUser = {
                        id: "test_user_" + Date.now(), // Unique test ID
                        username: "TestUser",
                        first_name: "Test",
                        photo_url: "https://via.placeholder.com/40/808080/000000?text=T"
                    };
                    const profilePic = document.querySelector('.profile-pic img');
                     if (profilePic) profilePic.src = telegramUser.photo_url;
                }
                debugLog("Telegram Web App initialized successfully.");
                return true;
            } catch (error) {
                console.error("Telegram Web App initialization failed:", error);
                debugLog(`Telegram Web App initialization failed: ${error.message}`);
                 // Define a fallback test user if Telegram fails catastrophically
                 telegramUser = {
                     id: "fallback_user_" + Date.now(),
                     username: "FallbackUser",
                     first_name: "Fallback",
                     photo_url: "https://via.placeholder.com/40/FF0000/FFFFFF?text=F" // Error indicator
                 };
                 const profilePic = document.querySelector('.profile-pic img');
                 if (profilePic) profilePic.src = telegramUser.photo_url;
                 alert("Could not initialize Telegram features. Using fallback mode.");
                return false;
            }
        }

        // --- Storage Abstraction (Firestore) ---
        const Storage = {
            getItem: async (key) => {
                 debugLog(`Storage: Getting item '${key}' for user ${telegramUser?.id}`);
                if (!firebaseInitialized || !db) {
                    console.error("Firestore not initialized. Cannot fetch item:", key);
                    debugLog(`Storage Error: Firestore not init for getItem '${key}'`);
                    return null;
                }
                if (!telegramUser || !telegramUser.id) {
                    console.error("User not identified. Cannot fetch item:", key);
                    debugLog(`Storage Error: User not identified for getItem '${key}'`);
                    return null;
                }
                try {
                    const docRef = db.collection('userData').doc(telegramUser.id.toString());
                    const doc = await docRef.get();
                    const value = doc.exists ? doc.data()[key] : null;
                     debugLog(`Storage: Got item '${key}', value:`, value);
                     return value;
                } catch (error) {
                    console.error(`Storage: Error fetching ${key}:`, error);
                    debugLog(`Storage Error: Failed fetching '${key}': ${error.message}`);
                    return null;
                }
            },
            setItem: async (key, value) => {
                 debugLog(`Storage: Setting item '${key}' for user ${telegramUser?.id}`, value);
                if (!firebaseInitialized || !db) {
                    console.error("Firestore not initialized. Cannot set item:", key);
                    debugLog(`Storage Error: Firestore not init for setItem '${key}'`);
                    return false;
                }
                 if (!telegramUser || !telegramUser.id) {
                    console.error("User not identified. Cannot set item:", key);
                     debugLog(`Storage Error: User not identified for setItem '${key}'`);
                     return false;
                 }
                try {
                    const docRef = db.collection('userData').doc(telegramUser.id.toString());
                    await docRef.set({ [key]: value }, { merge: true });
                     debugLog(`Storage: Set item '${key}' successfully.`);
                    return true;
                } catch (error) {
                    console.error(`Storage: Error setting ${key}:`, error);
                    debugLog(`Storage Error: Failed setting '${key}': ${error.message}`);
                    return false;
                }
            }
        };

        // --- Navigation Logic ---
        function setupNavigation() {
            debugLog('[NAV] Setting up navigation...');
            const sections = document.querySelectorAll('.section');
            const navButtons = document.querySelectorAll('nav.bottom-nav .nav-button');
            const bottomNav = document.querySelector('nav.bottom-nav');

            if (!bottomNav || sections.length === 0 || navButtons.length === 0) {
                console.error('[NAV ERROR] Required navigation elements not found!', {
                    bottomNavExists: !!bottomNav,
                    sectionsFound: sections.length,
                    navButtonsFound: navButtons.length
                });
                debugLog('[NAV ERROR] Required navigation elements not found!');
                alert("UI Error: Navigation could not be set up.");
                return; // Stop if essential elements are missing
            }

             debugLog(`[NAV] Found ${sections.length} sections and ${navButtons.length} nav buttons.`);

             // Log initial styles (optional, for deep debugging)
            // const computedNavStyle = window.getComputedStyle(bottomNav);
            // debugLog('[NAV] Initial computed nav styles:', { display: computedNavStyle.display, visibility: computedNavStyle.visibility, opacity: computedNavStyle.opacity });

             // Ensure nav is visible (redundant with !important styles, but safe)
             bottomNav.style.display = 'flex';
             bottomNav.style.visibility = 'visible';
             bottomNav.style.opacity = '1';

            navButtons.forEach((button, index) => {
                const sectionId = button.getAttribute('data-section');
                 debugLog(`[NAV] Setting up listener for button ${index}: ${sectionId}`);
                 if (!sectionId) {
                     console.warn(`[NAV WARN] Button ${index} is missing data-section attribute.`);
                     debugLog(`[NAV WARN] Button ${index} is missing data-section attribute.`);
                     return; // Skip buttons without data-section
                 }

                button.addEventListener('click', () => {
                    debugLog(`[NAV] Click detected on button: ${sectionId}`);
                    switchSection(sectionId);
                });

                 // Force visual styles again just in case (optional)
                 button.style.visibility = 'visible';
                 button.style.opacity = '1';
                 const img = button.querySelector('img');
                 if (img) img.onerror = () => { console.error(`[NAV ERROR] Image failed to load for button ${sectionId}: ${img.src}`); img.src='assets/icons/placeholder.png'; };
            });

            // Set default section
            const defaultSection = 'earn'; // Or read from localStorage/hash
            debugLog(`[NAV] Setting default section to: ${defaultSection}`);
            switchSection(defaultSection, true); // Pass true for initial load

            debugLog('[NAV] Navigation setup complete.');
        }

        async function switchSection(sectionId, isInitialLoad = false) {
             debugLog(`[NAV] Attempting to switch to section: ${sectionId}`);
            const sections = document.querySelectorAll('.section');
            const navButtons = document.querySelectorAll('nav.bottom-nav .nav-button');

            let foundSection = false;
            sections.forEach(section => {
                if (section.id === sectionId) {
                    if (!section.classList.contains('active')) {
                         section.classList.add('active');
                         debugLog(`[NAV] Activated section element: #${section.id}`);
                     } else {
                         debugLog(`[NAV] Section #${section.id} was already active.`);
                     }
                     foundSection = true;
                } else {
                    if (section.classList.contains('active')) {
                        section.classList.remove('active');
                         debugLog(`[NAV] Deactivated section element: #${section.id}`);
                     }
                }
            });

            if (!foundSection) {
                 console.error(`[NAV ERROR] Target section element with id "${sectionId}" not found in DOM.`);
                 debugLog(`[NAV ERROR] Target section element with id "${sectionId}" not found.`);
                 // Optional: Fallback to default section?
                 // if (!isInitialLoad) switchSection('earn');
                 return; // Stop if section doesn't exist
            }

            let foundButton = false;
            navButtons.forEach(btn => {
                 const btnSectionId = btn.getAttribute('data-section');
                 if (btnSectionId === sectionId) {
                     if (!btn.classList.contains('active')) {
                         btn.classList.add('active');
                         debugLog(`[NAV] Activated button: [data-section="${btnSectionId}"]`);
                     }
                     foundButton = true;
                 } else {
                     if (btn.classList.contains('active')) {
                         btn.classList.remove('active');
                         debugLog(`[NAV] Deactivated button: [data-section="${btnSectionId}"]`);
                     }
                 }
             });

             if (!foundButton) {
                 // This is less critical, maybe log a warning
                 console.warn(`[NAV WARN] Target button with data-section "${sectionId}" not found.`);
                 debugLog(`[NAV WARN] Target button with data-section "${sectionId}" not found.`);
             }

            // Load data for the activated section
             debugLog(`[NAV] Loading data for section: ${sectionId}`);
             try {
                 // Use ensureFirebaseReady to handle data loading for relevant sections
                 if (sectionId === 'earn') await ensureFirebaseReady(updateEarnSectionUI, 'updateEarnSectionUI');
                 else if (sectionId === 'invite') await ensureFirebaseReady(updateInviteSectionUI, 'updateInviteSectionUI');
                 else if (sectionId === 'top') await ensureFirebaseReady(updateTopSectionUI, 'updateTopSectionUI');
                 else if (sectionId === 'wallet') await ensureFirebaseReady(updateWalletSectionUI, 'updateWalletSectionUI');
                 // Add other section updates here if needed
                 // else if (sectionId === 'chest') updateChestSectionUI(); // Example
                 else {
                    debugLog(`[NAV] No specific data load function for section: ${sectionId}`);
                 }
             } catch (error) {
                 console.error(`[NAV ERROR] Error loading data for section ${sectionId}:`, error);
                 debugLog(`[NAV ERROR] Error loading data for section ${sectionId}: ${error.message}`);
                 // Show error message in the section?
             }
         }

        // --- User Data Management ---
        async function initializeUserData() {
             debugLog("Initializing user data...");
            if (!telegramUser || !telegramUser.id) {
                 console.warn("Cannot initialize user data: No Telegram user available or no ID.");
                 debugLog("User init skipped: No Telegram user ID.");
                 return;
            }
            if (!firebaseInitialized || !db) {
                console.error("Firestore not initialized. Cannot initialize user data.");
                debugLog("User init skipped: Firestore not initialized.");
                return;
            }

            const userIdStr = telegramUser.id.toString();
            const userDocRef = db.collection('userData').doc(userIdStr);
            const rankingDocRef = db.collection('users').doc(userIdStr); // Assuming 'users' for ranking

            try {
                const doc = await userDocRef.get();
                if (!doc.exists) {
                    debugLog(`User ${userIdStr} not found in userData, creating new record.`);
                    const newUser = {
                        gems: 0,
                        usdt: 0,
                        ton: 0,
                        referrals: 0,
                        referralCredits: 0, // Track credits separately?
                        inviteRecords: [],
                        claimHistory: [], // For credit claims
                        landPieces: 0,
                        foxMedals: 0,
                        isReferred: false,
                        referredBy: null,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastLogin: firebase.firestore.FieldValue.serverTimestamp(),
                        claimedQuests: [], // Store IDs of claimed non-repeatable quests
                        adProgress: {}, // { questId: { watched: 0, claimed: false, lastClaimed: null } }
                        walletAddress: null
                    };
                    await userDocRef.set(newUser);

                    // Also create ranking entry
                    const rankingEntry = {
                        username: telegramUser.username || telegramUser.first_name || `User_${userIdStr.slice(-4)}`,
                        foxMedals: 0,
                        photoUrl: telegramUser.photo_url || 'assets/icons/user-avatar.png', // Use local asset as fallback
                        userId: userIdStr // Store ID for reference
                    };
                    await rankingDocRef.set(rankingEntry, { merge: true }); // Use merge just in case

                    debugLog("New user data initialized in userData and users collections.");
                     if (analytics) analytics.logEvent('user_signup', { userId: userIdStr });
                } else {
                    debugLog(`User ${userIdStr} found. Updating last login.`);
                    await userDocRef.update({
                        lastLogin: firebase.firestore.FieldValue.serverTimestamp()
                        // Optionally update username/photoUrl from Telegram data here if needed
                    });
                     // Ensure ranking entry exists too
                     const rankDoc = await rankingDocRef.get();
                     if (!rankDoc.exists) {
                          const rankingEntry = {
                              username: telegramUser.username || telegramUser.first_name || `User_${userIdStr.slice(-4)}`,
                              foxMedals: doc.data().foxMedals || 0, // Sync medals
                              photoUrl: telegramUser.photo_url || 'assets/icons/user-avatar.png',
                              userId: userIdStr
                          };
                          await rankingDocRef.set(rankingEntry);
                          debugLog("Created missing ranking entry for existing user.");
                     }

                }
                // Always update UI after initialization/check
                await updateUserStatsUI();
            } catch (error) {
                console.error("Error initializing/checking user data:", error);
                debugLog(`Error initializing user data for ${userIdStr}: ${error.message}`);
                alert("There was a problem loading your profile.");
            }
        }

        async function updateUserStatsUI() {
             // debugLog("Updating user stats UI..."); // Can be noisy, uncomment if needed
            if (!telegramUser || !telegramUser.id) {
                 debugLog("Stats UI update skipped: No user.");
                 return;
             }
            if (!firebaseInitialized || !db) {
                 console.error("Firestore not initialized. Cannot update user stats UI.");
                 debugLog("Stats UI update skipped: Firestore not init.");
                 return;
            }
            try {
                const userDocRef = db.collection('userData').doc(telegramUser.id.toString());
                const userDoc = await userDocRef.get();

                if (!userDoc.exists) {
                    debugLog("Stats UI update skipped: User doc doesn't exist yet.");
                    // Maybe call initializeUserData again or show loading state?
                    return;
                }

                const data = userDoc.data();
                document.getElementById('gems').textContent = data.gems?.toLocaleString() || 0;
                document.getElementById('usdt').textContent = (data.usdt || 0).toFixed(4);
                document.getElementById('ton').textContent = (data.ton || 0).toFixed(4);

                // Update wallet section balances as well
                document.getElementById('wallet-usdt').textContent = (data.usdt || 0).toFixed(4);
                document.getElementById('wallet-ton').textContent = (data.ton || 0).toFixed(4);

                // debugLog("User stats UI updated successfully."); // Can be noisy
            } catch (error) {
                console.error("Error updating user stats UI:", error);
                debugLog(`Error updating stats UI: ${error.message}`);
            }
        }

        // --- Earn Section (Quests) ---
        async function updateEarnSectionUI() {
             debugLog("[QUEST DEBUG] Starting Earn section UI update...");
            const dailyQuestList = document.getElementById('daily-quest-list');
            const basicQuestList = document.getElementById('basic-quest-list');
            const dailyQuestCountEl = document.getElementById('daily-quest-count');
            const basicQuestCountEl = document.getElementById('basic-quest-count');

             if (!dailyQuestList || !basicQuestList || !dailyQuestCountEl || !basicQuestCountEl) {
                 console.error("[QUEST ERROR] Required DOM elements for quests not found!");
                 debugLog("[QUEST ERROR] Quest list or count elements missing from DOM.");
                 return;
             }

             // Set initial loading state
             dailyQuestList.innerHTML = `<li class="loading"><p>Loading daily quests...</p></li>`;
             basicQuestList.innerHTML = `<li class="loading"><p>Loading basic quests...</p></li>`;
             dailyQuestCountEl.textContent = '-';
             basicQuestCountEl.textContent = '-';

            try {
                 if (!firebaseInitialized || !db) {
                    throw new Error("Firestore not initialized for updating Earn section.");
                 }
                 let userData;
                 if (telegramUser && telegramUser.id) {
                    const userDocRef = db.collection('userData').doc(telegramUser.id.toString());
                    const userDoc = await userDocRef.get();
                    userData = userDoc.exists ? userDoc.data() : {};
                    userData.adProgress = userData.adProgress || {}; // Ensure adProgress exists
                    userData.claimedQuests = userData.claimedQuests || []; // Ensure claimedQuests exists
                    debugLog("[QUEST DEBUG] User data loaded for quest checks.");
                 } else {
                     throw new Error("User not identified for quest checks.");
                 }

                 // --- Fetch Daily Quests ---
                 debugLog("[QUEST DEBUG] Fetching daily quests...");
                 const dailyQuestsSnapshot = await db.collection('quests').doc('daily').get({ source: 'server' });
                 const dailyQuestsRaw = dailyQuestsSnapshot.exists ? dailyQuestsSnapshot.data() : {};
                 const dailyQuests = dailyQuestsRaw.tasks || [];
                 debugLog("[QUEST DEBUG] Raw Daily Quests Data:", dailyQuests);

                 dailyQuestCountEl.textContent = dailyQuests.length;
                 if (dailyQuests.length === 0) {
                     dailyQuestList.innerHTML = `<li class="no-quests"><p>No daily quests available today.</p></li>`;
                 } else {
                     dailyQuestList.innerHTML = dailyQuests.map(quest => {
                         const isClaimed = userData.claimedQuests.includes(quest.id); // Check non-repeatable claims
                         const buttonText = isClaimed ? 'Claimed' : (quest.action || 'GO');
                         const buttonClass = isClaimed ? 'claimed-button' : 'go-button'; // Daily quests likely use GO
                         const buttonDisabled = isClaimed;
                         return `
                             <li class="quest-item" data-quest-id="${quest.id}" data-quest-type="daily">
                                 <img src="${quest.icon || 'assets/icons/quest_placeholder.png'}" alt="${quest.title || 'Quest'}" onerror="this.src='assets/icons/quest_placeholder.png'">
                                 <span>${quest.title || 'Untitled Quest'}</span>
                                 <div class="quest-reward">
                                     <img src="assets/icons/gem.png" alt="Gem">
                                     <span>+${Number(quest.reward) || 0}</span>
                                     <button class="${buttonClass}"
                                             data-quest-link="${quest.link || ''}"
                                             data-quest-reward="${Number(quest.reward) || 0}"
                                             ${buttonDisabled ? 'disabled' : ''}>
                                         ${buttonText}
                                     </button>
                                 </div>
                             </li>
                         `;
                     }).join('');
                 }
                 debugLog("[QUEST DEBUG] Daily quests rendered.");


                 // --- Fetch Basic Quests ---
                 debugLog("[QUEST DEBUG] Fetching basic quests...");
                 const basicQuestsSnapshot = await db.collection('quests').doc('basic').get({ source: 'server' });
                 const basicQuestsRaw = basicQuestsSnapshot.exists ? basicQuestsSnapshot.data() : {};
                         async function updateEarnSectionUI() {
            // ... other code ...

            try {
                // ... code to get user data ...

                // --- Fetch Daily Quests ---
                // ... daily quest fetching logic ...


                // --- Fetch Basic Quests ---
                debugLog("[QUEST DEBUG] Fetching basic quests...");
                const basicQuestsSnapshot = await db.collection('quests').doc('basic').get({ source: 'server' });
                const basicQuestsRaw = basicQuestsSnapshot.exists ? basicQuestsSnapshot.data() : {}; // <-- Fetched data

                // ******** START: PASTE THE DEBUG CODE HERE ********
                debugLog("[QUEST DEBUG] Raw Basic Quests Data from Firestore:", basicQuestsRaw); // Log all raw data
                if (Array.isArray(basicQuestsRaw.tasks)) { // Check if 'tasks' is an array
                    const specificQuest = basicQuestsRaw.tasks.find(q => q.id === 'full_ad'); // Find your specific quest by ID
                    debugLog("[QUEST DEBUG] Data for 'full_ad' quest object:", specificQuest); // Log the object for that quest
                    if (specificQuest) {
                        // Log the value and type of the adLimit field specifically
                        debugLog("[QUEST DEBUG] Value and type of adLimit for 'full_ad':", specificQuest.adLimit, typeof specificQuest.adLimit);
                    } else {
                         debugLog("[QUEST DEBUG] Quest with id 'full_ad' not found in fetched tasks array.");
                    }
                } else {
                    debugLog("[QUEST DEBUG] 'tasks' field not found or is not an array in quests/basic document.");
                }
                // ******** END: PASTE THE DEBUG CODE HERE ********


                // Ensure adProgress structure is initialized for all ad quests if not present (Keep this block)
                let adProgressUpdateNeeded = false;
                const adProgressUpdate = {};
                // This loop needs basicQuestsRaw.tasks, so keep it after the debug logs accessing it
                (basicQuestsRaw.tasks || []).forEach(quest => { // Use basicQuestsRaw.tasks here safely
                   if (quest.type === 'ads' && !userData.adProgress[quest.id]) {
                       // ... existing adProgress initialization logic ...
                   }
                });
                if (adProgressUpdateNeeded) {
                   await db.collection('userData').doc(telegramUser.id.toString()).update(adProgressUpdate);
                   debugLog("[QUEST DEBUG] Updated user data with initial adProgress structures.");
                }
                // END of adProgress init logic


                const basicQuests = basicQuestsRaw.tasks || []; // <-- Assign basicQuests AFTER logging

                basicQuestCountEl.textContent = basicQuests.length;
                if (basicQuests.length === 0) {
                    basicQuestList.innerHTML = `<li class="no-quests"><p>No basic quests available right now.</p></li>`;
                } else {
                    const currentTime = new Date();
                    const cooldownPeriod = 3600 * 1000;

                    // The .map loop starts here, processing the basicQuests array
                    basicQuestList.innerHTML = basicQuests.map(quest => {
                        const questId = quest.id || `quest_${Math.random().toString(16).slice(2)}`;
                        const questType = quest.type || 'default';
                        const questTitle = quest.title || 'Untitled Quest';
                        const questIcon = quest.icon || 'assets/icons/quest_placeholder.png';
                        const questReward = Number(quest.reward) || 0;
                        const questAction = quest.action || 'GO';
                        const questLink = quest.link || '';
                        // This line uses quest.adLimit from the mapped 'quest' object
                        const adLimit = questType === 'ads' ? Math.max(1, Number(quest.adLimit) || 1) : 0;
                        const adType = quest.adType || 'rewarded_interstitial';

                        // Detailed log for each quest being processed (keep this one too)
                        debugLog(`[QUEST DEBUG] Processing Basic Quest: ${questTitle}`, {
                            id: questId, type: questType, rawAdLimit: quest.adLimit, calculatedAdLimit: adLimit, reward: questReward
                        });

                        // ... rest of the rendering logic inside map ...
                    }).join('');
                }
                debugLog("[QUEST DEBUG] Basic quests rendered.");

           } catch (error) {
               console.error("[QUEST ERROR] Failed to update Earn section UI:", error);
               // ... error handling ...
           }
       }
       
                 const basicQuests = basicQuestsRaw.tasks || [];
                 debugLog("[QUEST DEBUG] Raw Basic Quests Data:", basicQuests);

                 // Ensure adProgress structure is initialized for all ad quests if not present
                 let adProgressUpdateNeeded = false;
                 const adProgressUpdate = {};
                 basicQuests.forEach(quest => {
                    if (quest.type === 'ads' && !userData.adProgress[quest.id]) {
                        userData.adProgress[quest.id] = { watched: 0, claimed: false, lastClaimed: null };
                        adProgressUpdate[`adProgress.${quest.id}`] = userData.adProgress[quest.id];
                        adProgressUpdateNeeded = true;
                        debugLog(`[QUEST DEBUG] Initializing adProgress for new quest: ${quest.id}`);
                    }
                 });
                 if (adProgressUpdateNeeded) {
                    await db.collection('userData').doc(telegramUser.id.toString()).update(adProgressUpdate);
                    debugLog("[QUEST DEBUG] Updated user data with initial adProgress structures.");
                 }


                 basicQuestCountEl.textContent = basicQuests.length;
                 if (basicQuests.length === 0) {
                     basicQuestList.innerHTML = `<li class="no-quests"><p>No basic quests available right now.</p></li>`;
                 } else {
                     const currentTime = new Date(); // Get current time once for cooldown checks
                     const cooldownPeriod = 3600 * 1000; // 1 hour cooldown in milliseconds

                     basicQuestList.innerHTML = basicQuests.map(quest => {
                         const questId = quest.id || `quest_${Math.random().toString(16).slice(2)}`; // Ensure ID
                         const questType = quest.type || 'default';
                         const questTitle = quest.title || 'Untitled Quest';
                         const questIcon = quest.icon || 'assets/icons/quest_placeholder.png';
                         const questReward = Number(quest.reward) || 0;
                         const questAction = quest.action || 'GO';
                         const questLink = quest.link || '';
                         const adLimit = questType === 'ads' ? Math.max(1, Number(quest.adLimit) || 1) : 0;
                         const adType = quest.adType || 'rewarded_interstitial';

                         // Detailed log for each quest being processed
                         debugLog(`[QUEST DEBUG] Processing Basic Quest: ${questTitle}`, {
                             id: questId, type: questType, rawAdLimit: quest.adLimit, calculatedAdLimit: adLimit, reward: questReward
                         });

                         let buttonText = questAction;
                         let buttonClass = 'go-button';
                         let buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);'; // Default GO style
                         let buttonDisabled = false;
                         let progressText = '';

                         if (questType === 'ads') {
                             const adProgress = userData.adProgress[questId] || { watched: 0, claimed: false, lastClaimed: null };
                             progressText = `<span class="progress">${adProgress.watched}/${adLimit}</span>`;
                             const isCompleted = adProgress.watched >= adLimit;
                             const isClaimed = adProgress.claimed; // Check specific ad claim status
                             const lastClaimedTime = adProgress.lastClaimed ? new Date(adProgress.lastClaimed) : null;
                             const timeSinceLastClaim = lastClaimedTime ? currentTime - lastClaimedTime : Infinity;
                             let isCooldownOver = timeSinceLastClaim >= cooldownPeriod;

                             // --- Cooldown Reset Logic ---
                             // If claimed but cooldown is now over, reset it *before* rendering the button
                             if (isClaimed && isCooldownOver) {
                                 debugLog(`[QUEST DEBUG] Cooldown over for ad quest ${questId}. Resetting progress.`);
                                 adProgress.watched = 0;
                                 adProgress.claimed = false;
                                 adProgress.lastClaimed = null;
                                 isCooldownOver = true; // Ensure subsequent checks use the reset state

                                 // Asynchronously update Firestore, don't block rendering
                                 db.collection('userData').doc(telegramUser.id.toString()).update({
                                     [`adProgress.${questId}`]: { watched: 0, claimed: false, lastClaimed: null }
                                 }).then(() => {
                                     debugLog(`[QUEST DEBUG] Firestore updated for ${questId} reset.`);
                                 }).catch(err => {
                                     console.error(`[QUEST ERROR] Failed Firestore reset for ${questId}:`, err);
                                     debugLog(`[QUEST ERROR] Failed Firestore reset for ${questId}: ${err.message}`);
                                 });
                             }
                             // --- Button State Logic (after potential reset) ---
                            if (adProgress.claimed && !isCooldownOver) { // Still claimed and in cooldown
                                 const timeLeftMinutes = Math.ceil((cooldownPeriod - timeSinceLastClaim) / 60000);
                                 buttonText = `Wait ${timeLeftMinutes}m`;
                                 buttonClass = 'claimed-button'; // Use claimed style for waiting
                                 buttonStyle = 'background: #ccc; cursor: default;';
                                 buttonDisabled = true;
                             } else if (isCompleted && !adProgress.claimed) { // Completed, not claimed (or reset and completed again)
                                 buttonText = 'Claim';
                                 buttonClass = 'claim-button active'; // Use active claim style
                                 buttonStyle = 'background: linear-gradient(to right, #00ff00, #66ff66);';
                                 buttonDisabled = false;
                             } else { // Not completed, ready to GO (or reset and ready to GO again)
                                 buttonText = questAction;
                                 buttonClass = 'go-button';
                                 buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);';
                                 buttonDisabled = false;
                             }
                         } else { // Default quest type (e.g., visit link)
                             const isClaimed = userData.claimedQuests.includes(questId);
                             if (isClaimed) {
                                 buttonText = 'Claimed';
                                 buttonClass = 'claimed-button';
                                 buttonStyle = 'background: #ccc; cursor: default;';
                                 buttonDisabled = true;
                             }
                             // Otherwise, it keeps the default GO button state
                         }

                         return `
                             <li class="quest-item" data-quest-id="${questId}" data-quest-type="${questType}" data-ad-limit="${adLimit}" data-ad-type="${adType}">
                                 <img src="${questIcon}" alt="${questTitle}" onerror="this.src='assets/icons/quest_placeholder.png'">
                                 <span>${questTitle}</span>
                                 <div class="quest-reward">
                                     <img src="assets/icons/gem.png" alt="Gem">
                                     <span>+${questReward}</span>
                                     ${progressText}
                                     <button class="${buttonClass}"
                                             data-quest-link="${questLink}"
                                             data-quest-reward="${questReward}"
                                             style="${buttonStyle}"
                                             ${buttonDisabled ? 'disabled' : ''}>
                                         ${buttonText}
                                     </button>
                                 </div>
                             </li>
                         `;
                     }).join('');
                 }
                 debugLog("[QUEST DEBUG] Basic quests rendered.");

            } catch (error) {
                console.error("[QUEST ERROR] Failed to update Earn section UI:", error);
                debugLog(`[QUEST ERROR] Failed to update Earn section UI: ${error.message}\n${error.stack}`);
                 // Display error messages in the UI
                dailyQuestList.innerHTML = `<li class="error"><p>Failed to load daily quests. Please try again later.</p></li>`;
                basicQuestList.innerHTML = `<li class="error"><p>Failed to load basic quests. Please try again later.</p></li>`;
                dailyQuestCountEl.textContent = 'ERR';
                basicQuestCountEl.textContent = 'ERR';
            }
        }

        // --- Quest Interaction Logic ---
         // Consolidated click listener for quest buttons
         document.addEventListener('click', async (event) => {
             // Find the button that was clicked
             const button = event.target.closest('.quest-reward button');
             if (!button) return; // Exit if click wasn't on a quest button

             // Find the parent quest item
             const taskItem = button.closest('.quest-item');
             if (!taskItem) return; // Should always find if button is found

             const questId = taskItem.dataset.questId;
             const questType = taskItem.dataset.questType;
             const reward = parseInt(button.dataset.questReward || '0');
             const link = button.dataset.questLink || '';
             const adLimit = parseInt(taskItem.dataset.adLimit || '0');
             const adType = taskItem.dataset.adType || 'rewarded_interstitial';

             debugLog(`[QUEST ACTION] Button clicked for quest: ${questId}`, { type: questType, reward, link: link || 'N/A', adLimit, adType });

             if (!firebaseInitialized || !db) {
                 alert("Database not ready. Please wait and try again.");
                 debugLog("[QUEST ACTION ERROR] Firestore not ready.");
                 return;
             }
             if (!telegramUser || !telegramUser.id) {
                 alert("Cannot perform action: User not identified.");
                 debugLog("[QUEST ACTION ERROR] User not identified.");
                 return;
             }

             const userDocRef = db.collection('userData').doc(telegramUser.id.toString());
             let userData;
             try {
                 const userDoc = await userDocRef.get();
                 if (!userDoc.exists) throw new Error("User data not found.");
                 userData = userDoc.data();
                 userData.adProgress = userData.adProgress || {};
                 userData.claimedQuests = userData.claimedQuests || [];
             } catch (error) {
                 console.error("Failed to get user data for quest action:", error);
                 debugLog(`[QUEST ACTION ERROR] Failed get user data: ${error.message}`);
                 alert("Failed to load your data. Please try again.");
                 return;
             }

             // --- Handle CLAIM button clicks (specifically for completed ad quests) ---
             if (button.classList.contains('claim-button') && questType === 'ads') {
                 debugLog(`[QUEST ACTION] Handling CLAIM for ad quest: ${questId}`);
                 const adProgress = userData.adProgress[questId] || { watched: 0, claimed: false, lastClaimed: null };

                 if (adProgress.watched < adLimit) {
                     alert(`You need to watch ${adLimit} ads first! (${adProgress.watched}/${adLimit})`);
                     debugLog(`[QUEST ACTION] Claim aborted: Ads not fully watched for ${questId}`);
                     return;
                 }
                 if (adProgress.claimed) {
                     alert("This reward has already been claimed and is on cooldown.");
                     debugLog(`[QUEST ACTION] Claim aborted: Already claimed/on cooldown for ${questId}`);
                     return;
                 }

                 // Prevent double clicks
                 button.disabled = true;
                 button.textContent = 'Claiming...';

                 try {
                     const currentTimeISO = new Date().toISOString();
                     await userDocRef.update({
                         gems: firebase.firestore.FieldValue.increment(reward),
                         // claimedQuests: firebase.firestore.FieldValue.arrayUnion(questId), // Don't add to general claimed, use adProgress
                         [`adProgress.${questId}`]: {
                             watched: adProgress.watched, // Keep watched count
                             claimed: true,               // Mark as claimed
                             lastClaimed: currentTimeISO  // Record claim time for cooldown
                         }
                     });

                     debugLog(`[QUEST ACTION] Ad quest ${questId} claimed successfully. Awarded ${reward} gems.`);
                     if (analytics) analytics.logEvent('ads_quest_claimed', { userId: telegramUser.id, questId, reward });

                     alert(`Reward claimed! You earned ${reward} gems.`);
                     await updateUserStatsUI();
                     await updateEarnSectionUI(); // Refresh the quest list UI immediately

                 } catch (error) {
                     console.error("[QUEST ERROR] Error claiming ad reward:", error);
                     debugLog(`[QUEST ERROR] Error claiming ad reward for ${questId}: ${error.message}`);
                     alert("Failed to claim reward. Please try again.");
                     // Re-enable button if claim failed
                     button.disabled = false;
                     button.textContent = 'Claim';
                 }
             }
             // --- Handle GO button clicks ---
             else if (button.classList.contains('go-button')) {
                 debugLog(`[QUEST ACTION] Handling GO for quest: ${questId}`);

                 // --- GO for Ad Quests ---
                 if (questType === 'ads') {
                     const adProgress = userData.adProgress[questId] || { watched: 0, claimed: false, lastClaimed: null };
                     if (adProgress.watched >= adLimit) {
                         alert("Youâ€™ve watched all required ads. Please CLAIM your reward!");
                         debugLog(`[QUEST ACTION] GO aborted: Ads already watched for ${questId}. Needs claim.`);
                         return;
                     }
                     if (adProgress.claimed) {
                          alert("This reward is claimed and on cooldown.");
                          debugLog(`[QUEST ACTION] GO aborted: Ad quest ${questId} is on cooldown.`);
                          return;
                     }


                     debugLog(`[QUEST ACTION] Attempting to show ad (${adType}) for quest: ${questId}`);
                     // Prevent double clicks while ad is showing
                     button.disabled = true;
                     button.textContent = 'Loading Ad...';

                     try {
                         await showAd(adType); // Show the ad and wait for completion/close
                         debugLog(`[QUEST ACTION] Ad shown successfully for quest: ${questId}`);

                         // --- IMPORTANT: Re-fetch user data AFTER ad to prevent race conditions ---
                         const updatedUserDoc = await userDocRef.get();
                         if (!updatedUserDoc.exists) throw new Error("User data disappeared after ad.");
                         const updatedUserData = updatedUserDoc.data();
                         const currentAdProgress = updatedUserData.adProgress?.[questId] || { watched: 0, claimed: false, lastClaimed: null };
                         // ---

                         const newWatchedCount = currentAdProgress.watched + 1;
                         await userDocRef.update({
                             [`adProgress.${questId}`]: {
                                 watched: newWatchedCount,
                                 claimed: currentAdProgress.claimed, // Keep existing claimed status
                                 lastClaimed: currentAdProgress.lastClaimed // Keep existing claim time
                             }
                         });

                         debugLog(`[QUEST ACTION] Ad progress updated for ${questId}: ${newWatchedCount}/${adLimit}`);
                         if (analytics) analytics.logEvent('ads_quest_watch', { userId: telegramUser.id, questId, adType });

                         if (newWatchedCount >= adLimit) {
                             alert(`Ad watched! (${newWatchedCount}/${adLimit}) You can now claim your reward.`);
                         } else {
                             alert(`Ad watched! Progress: ${newWatchedCount}/${adLimit}`);
                         }
                         await updateEarnSectionUI(); // Refresh UI to show new progress/claim button

                     } catch (error) {
                         console.error("[QUEST ERROR] Failed to show ad or update progress:", error);
                         debugLog(`[QUEST ERROR] Failed showing ad/updating progress for ${questId}: ${error.message}`);
                         alert("Failed to show ad. Please try again.");
                         // Refresh UI to reset button state if ad failed
                         await updateEarnSectionUI();
                     }
                 }
                 // --- GO for Daily/Default Link Quests ---
                 else { // Assumes daily or other 'go' types are non-repeatable link quests
                     if (userData.claimedQuests.includes(questId)) {
                         alert("This quest has already been completed!");
                         debugLog(`[QUEST ACTION] GO aborted: Quest ${questId} already in claimedQuests.`);
                         return;
                     }

                     if (!link) {
                         alert("No link associated with this quest.");
                         debugLog(`[QUEST ACTION ERROR] No link found for default quest ${questId}.`);
                         return;
                     }

                     debugLog(`[QUEST ACTION] Opening link for quest ${questId}: ${link}`);
                     // Prevent double clicks
                     button.disabled = true;
                     button.textContent = 'Claiming...';

                     try {
                          // --- Award reward and mark claimed BEFORE opening link ---
                          // This assumes completion upon clicking GO for these types
                         await userDocRef.update({
                             gems: firebase.firestore.FieldValue.increment(reward),
                             claimedQuests: firebase.firestore.FieldValue.arrayUnion(questId) // Add to general claimed list
                         });

                         debugLog(`[QUEST ACTION] Default quest ${questId} marked complete. Awarded ${reward} gems.`);
                         if (analytics) analytics.logEvent('quest_completed', { userId: telegramUser.id, questId, reward });

                         // Open the link in Telegram context
                         if (window.Telegram && window.Telegram.WebApp) {
                            window.Telegram.WebApp.openTelegramLink(link);
                         } else {
                            window.open(link, '_blank'); // Fallback for browser testing
                            debugLog("[QUEST ACTION WARN] Not in Telegram context, opening link in new tab.");
                         }


                         alert(`Quest completed! You earned ${reward} gems.`);
                         await updateUserStatsUI();
                         await updateEarnSectionUI(); // Refresh UI to show 'Claimed'

                     } catch (error) {
                         console.error("[QUEST ERROR] Error completing default quest:", error);
                         debugLog(`[QUEST ERROR] Error completing default quest ${questId}: ${error.message}`);
                         alert("Failed to complete quest. Please try again.");
                         // Re-enable button if failed
                         button.disabled = false;
                         button.textContent = 'GO';
                     }
                 }
             }
             // Ignore clicks on 'Claimed' or disabled buttons silently
             else if (button.classList.contains('claimed-button') || button.disabled) {
                 debugLog(`[QUEST ACTION] Click ignored on disabled/claimed button for quest: ${questId}`);
             }
             // Add handling for other potential button types if needed
         });


        // --- Ad Logic ---
        function showAd(adType) {
            debugLog(`[AD] Attempting to show ad of type: ${adType}`);
            return new Promise((resolve, reject) => {
                const maxWaitTime = 20000; // Increased timeout slightly to 20 seconds

                // Check if SDK function exists
                if (typeof window.show_9180370 !== 'function') {
                    console.warn("[AD WARN] Monetag SDK function 'show_9180370' not found. Simulating ad success after delay.");
                    debugLog("[AD WARN] Monetag SDK function not found. Simulating success.");
                    setTimeout(() => {
                        debugLog("[AD] Simulated ad finished.");
                        resolve(); // Simulate success
                    }, 3000);
                    return;
                }

                let adPromise = null; // Variable to hold the promise returned by the SDK
                let adTriggered = false; // Flag to track if an ad call was made
                let requiresPromiseHandling = false; // Flag for types expected to return a promise

                // --- Timeout Logic ---
                // We set a timeout that will reject the promise if the ad takes too long
                // or if the SDK doesn't resolve/reject properly.
                const timeoutId = setTimeout(() => {
                    console.warn(`[AD WARN] Ad timed out after ${maxWaitTime / 1000}s (${adType}). Rejecting.`);
                    debugLog(`[AD WARN] Ad timed out: ${adType}`);
                    // Ensure rejection happens only once
                    reject(new Error(`Ad timed out or failed to close (${adType})`));
                }, maxWaitTime);

                // Function to clear the timeout and potentially resolve/reject
                const cleanup = (success, error = null) => {
                    clearTimeout(timeoutId); // Always clear the timeout
                    if (success) {
                        resolve();
                    } else {
                        reject(error || new Error(`Ad failed or was closed early (${adType})`));
                    }
                };

                try {
                    debugLog(`[AD] Calling Monetag SDK for ad type: ${adType}`);

                    // --- Trigger Ad Based on Type ---
                    if (adType === 'rewarded_popup') {
                        // show_9180370('pop') returns a promise
                        adPromise = window.show_9180370('pop');
                        adTriggered = true;
                        requiresPromiseHandling = true;
                    } else if (adType === 'rewarded_interstitial') {
                        // show_9180370() returns a promise
                        adPromise = window.show_9180370();
                        adTriggered = true;
                        requiresPromiseHandling = true;
                    } else if (adType === 'inApp') {
                        // show_9180370({ type: 'inApp' }) - Assuming no reliable promise return
                        window.show_9180370({ type: 'inApp' });
                        adTriggered = true;
                        requiresPromiseHandling = false; // Assume no promise to handle here
                        // For inApp, we might need to rely on the timeout or assume success earlier.
                        // Let's resolve heuristically after a short delay, assuming the user saw it.
                        // Adjust this timing or logic if the SDK provides specific callbacks for inApp.
                        debugLog("[AD] InApp ad triggered. Resolving heuristically after short delay.");
                        setTimeout(() => cleanup(true), 1500); // Resolve after 1.5s assuming display worked

                    } else {
                        // Handle unknown or default ad type
                        console.warn(`[AD WARN] Unsupported or default adType: ${adType}. Falling back to standard interstitial.`);
                        adPromise = window.show_9180370(); // Fallback
                        adTriggered = true;
                        requiresPromiseHandling = true;
                    }

                    // --- Handle Promise (if applicable) ---
                    if (requiresPromiseHandling && adPromise && typeof adPromise.then === 'function') {
                        debugLog(`[AD] SDK returned a Promise for type ${adType}. Waiting for resolution...`);
                        adPromise.then(() => {
                            debugLog(`[AD] SDK Promise resolved successfully for type: ${adType}. Ad likely watched/closed.`);
                            cleanup(true); // Resolve the outer promise on success
                        }).catch(e => {
                            console.error(`[AD ERROR] SDK Promise rejected for type ${adType}:`, e);
                            debugLog(`[AD ERROR] SDK Promise rejected for ${adType}: ${e?.message || e}`);
                            cleanup(false, new Error(`Ad failed or was closed early (${adType})`)); // Reject the outer promise on failure
                        });
                    } else if (adTriggered && !requiresPromiseHandling) {
                         // This block is mainly for 'inApp' or future types without promises
                         debugLog(`[AD] Ad type ${adType} triggered, no standard promise handling needed or done heuristically.`);
                    } else if (adTriggered) {
                         // Safety net if adPromise wasn't a promise but was expected to be
                         console.warn(`[AD WARN] SDK call for ${adType} was triggered but did not return a standard promise. Relying on timeout.`);
                         // The timeout will handle rejection if needed.
                    }

                } catch (error) {
                    // Catch immediate errors from calling show_9180370 itself
                    console.error("[AD ERROR] Failed to trigger Monetag ad:", error);
                    debugLog(`[AD ERROR] Failed to trigger ad ${adType}: ${error.message}`);
                    cleanup(false, error); // Reject the outer promise if the call fails immediately
                }
            });
        }



        // --- Referral System ---
        function generateReferralLink() {
             debugLog("Generating referral link...");
            if (!telegramUser || !telegramUser.id) {
                 debugLog("Referral link generation skipped: No user ID.");
                 return;
            }
            // Replace with your actual bot username
            const botUsername = 'fourgobot'; // Replace with your bot's username
            const referralLink = `https://t.me/${botUsername}?start=ref_${telegramUser.id}`;

            const inviteButton = document.querySelector('.invite-friend');
            const copyButton = document.querySelector('.copy-link');

            if (inviteButton) inviteButton.setAttribute('data-link', referralLink);
            if (copyButton) copyButton.setAttribute('data-link', referralLink);

            debugLog("Referral link generated:", referralLink);
        }

        async function handleReferral() {
             debugLog("Checking for referral parameter...");
             if (!telegramUser || !telegramUser.id) {
                 debugLog("Referral handling skipped: No user ID.");
                 return; // Need current user ID
             }
             if (!firebaseInitialized || !db) {
                 debugLog("Referral handling skipped: Firestore not ready.");
                 return; // Need DB
             }

             let startParam = null;
             try {
                 // Access initData safely
                 startParam = window.Telegram?.WebApp?.initDataUnsafe?.start_param;
             } catch (e) {
                 console.error("Error accessing Telegram start_param:", e);
                 debugLog(`Error accessing start_param: ${e.message}`);
                 return;
             }


             if (startParam && startParam.startsWith('ref_')) {
                 const referrerId = startParam.split('_')[1];
                 debugLog(`Referral parameter found: ref_${referrerId}`);

                 if (!referrerId) {
                      debugLog("Referral handling skipped: Invalid referrer ID in start_param.");
                      return;
                 }
                 // Prevent self-referral
                 if (referrerId === telegramUser.id.toString()) {
                     debugLog("Referral handling skipped: User referred themselves.");
                     return;
                 }

                 const currentUserRef = db.collection('userData').doc(telegramUser.id.toString());
                 const referrerRef = db.collection('userData').doc(referrerId);

                 try {
                     const userDoc = await currentUserRef.get();
                     // Ensure user data exists (should have been created by initializeUserData)
                     if (!userDoc.exists) {
                          debugLog("Referral handling warning: Current user data doesn't exist yet. Deferring.");
                          // Optionally, retry later or ensure initializeUserData runs first
                          return;
                     }
                     const userData = userDoc.data();

                     // Check if user has already been marked as referred
                     if (userData.isReferred) {
                         debugLog(`Referral handling skipped: User ${telegramUser.id} already referred (by ${userData.referredBy || 'unknown'}).`);
                         return;
                     }

                      // --- Process the referral ---
                     debugLog(`Processing referral: User ${telegramUser.id} referred by ${referrerId}`);

                     // 1. Mark current user as referred
                     await currentUserRef.update({
                         isReferred: true,
                         referredBy: referrerId
                     });

                     // 2. Update referrer's data
                     const referrerDoc = await referrerRef.get();
                     if (referrerDoc.exists) {
                         const referralCreditAmount = 10; // Credits per referral
                         const referralGemAmount = 50;   // Gems per referral

                         const newRecord = {
                             userId: telegramUser.id.toString(),
                             username: telegramUser.username || telegramUser.first_name || `User_${telegramUser.id.toString().slice(-4)}`,
                             joinTime: new Date().toISOString(), // Use ISO string for consistency
                             creditAwarded: referralCreditAmount, // Record awarded credit
                             // Add other info if needed
                         };

                         await referrerRef.update({
                             referrals: firebase.firestore.FieldValue.increment(1),
                             // gems: firebase.firestore.FieldValue.increment(referralGemAmount), // Decide if referrer gets gems too
                             referralCredits: firebase.firestore.FieldValue.increment(referralCreditAmount), // Update credit balance
                             inviteRecords: firebase.firestore.FieldValue.arrayUnion(newRecord)
                         });
                         debugLog(`Updated referrer ${referrerId} data: +1 referral, +${referralCreditAmount} credits.`);
                     } else {
                         debugLog(`Referral handling warning: Referrer ${referrerId} document not found.`);
                     }

                      if (analytics) analytics.logEvent('referral_success', { userId: telegramUser.id, referrerId });
                     debugLog("Referral handled successfully.");

                 } catch (error) {
                     console.error("Error processing referral:", error);
                     debugLog(`Error processing referral: ${error.message}`);
                 }
             } else {
                 debugLog("No referral parameter found or not in 'ref_' format.");
             }
         }

        // --- Invite Section UI & Logic ---
        async function updateInviteSectionUI() {
            debugLog("Updating Invite section UI...");
             const myInviteEl = document.getElementById('my-invite');
             const totalCreditEl = document.getElementById('total-credit-text'); // Use updated ID
             const inviteRecordTitleEl = document.getElementById('invite-record-title');
             const recordListContainer = document.getElementById('invite-record-list');
             const invitePlaceholder = document.getElementById('invite-record-placeholder');
             const claimRecordListContainer = document.getElementById('claim-record-list');
             const claimPlaceholder = document.getElementById('claim-record-placeholder');

             if (!myInviteEl || !totalCreditEl || !inviteRecordTitleEl || !recordListContainer || !invitePlaceholder || !claimRecordListContainer || !claimPlaceholder) {
                 console.error("[INVITE ERROR] Invite section UI elements missing!");
                 debugLog("[INVITE ERROR] Invite section UI elements missing!");
                 return;
             }

             // Set loading state
             myInviteEl.textContent = `My Invite: ...`;
             totalCreditEl.textContent = `Total Credit ! : ...`;
             inviteRecordTitleEl.textContent = `Invite Record (...)`;
             recordListContainer.innerHTML = ''; // Clear previous list
             invitePlaceholder.style.display = 'block';
             invitePlaceholder.querySelector('p').textContent = 'Loading invites...';
             claimRecordListContainer.innerHTML = ''; // Clear previous list
             claimPlaceholder.style.display = 'block';
             claimPlaceholder.querySelector('p').textContent = 'Loading claim history...';


             if (!telegramUser || !telegramUser.id) {
                 debugLog("Invite UI update skipped: No user ID.");
                 // Show appropriate message in UI
                 myInviteEl.textContent = `My Invite: N/A`;
                 totalCreditEl.textContent = `Total Credit ! : N/A`;
                 invitePlaceholder.querySelector('p').textContent = 'Cannot load data (no user)';
                 claimPlaceholder.querySelector('p').textContent = 'Cannot load data (no user)';
                 return;
             }

             try {
                 const userDocRef = db.collection('userData').doc(telegramUser.id.toString());
                 const userDoc = await userDocRef.get();
                 if (!userDoc.exists) {
                     debugLog("Invite UI update: User data not found.");
                     // Show appropriate message
                     myInviteEl.textContent = `My Invite: 0`;
                     totalCreditEl.textContent = `Total Credit ! : 0`;
                     invitePlaceholder.querySelector('p').textContent = 'No invites yet';
                     claimPlaceholder.querySelector('p').textContent = 'No claim records yet';
                     return;
                 }

                 const data = userDoc.data();
                 const referrals = data.referrals || 0;
                 const totalCredit = data.referralCredits || 0; // Use separate credit field
                 const inviteRecords = data.inviteRecords || [];
                 const claimHistory = data.claimHistory || [];

                 // Update stats
                 myInviteEl.textContent = `My Invite: ${referrals}`;
                 totalCreditEl.textContent = `Total Credit ! : ${totalCredit.toLocaleString()}`;
                 inviteRecordTitleEl.textContent = `Invite Record (${referrals})`;

                 // Populate Invite Records
                 if (inviteRecords.length === 0) {
                     recordListContainer.innerHTML = '';
                     invitePlaceholder.style.display = 'block';
                     invitePlaceholder.querySelector('p').textContent = 'No invites yet';
                 } else {
                     invitePlaceholder.style.display = 'none';
                     recordListContainer.innerHTML = inviteRecords.sort((a, b) => new Date(b.joinTime) - new Date(a.joinTime)) // Sort newest first
                         .map(record => `
                             <div class="record-item">
                                 <img src="https://via.placeholder.com/40/808080/FFFFFF?text=${(record.username || 'U')[0].toUpperCase()}" alt="${record.username || 'User'}">
                                 <div class="user-info">
                                     <span>${record.username || 'Unknown User'}</span>
                                     <small>${new Date(record.joinTime).toLocaleString()}</small>
                                 </div>
                                 <span class="credit">+${record.creditAwarded || 0}</span>
                             </div>
                         `).join('');
                 }

                 // Populate Claim Records
                 if (claimHistory.length === 0) {
                     claimRecordListContainer.innerHTML = '';
                     claimPlaceholder.style.display = 'block';
                     claimPlaceholder.querySelector('p').textContent = 'No claim records yet';
                 } else {
                     claimPlaceholder.style.display = 'none';
                     claimRecordListContainer.innerHTML = claimHistory.sort((a, b) => new Date(b.claimTime) - new Date(a.claimTime)) // Sort newest first
                         .map(record => `
                             <div class="record-item">
                                 <img src="assets/icons/usdt.png" alt="USDT Claim" style="border-radius: 0;"> <div class="user-info">
                                     <span>Claimed ${record.usdtAmount?.toFixed(4) || '?'} USDT</span>
                                     <small>${new Date(record.claimTime).toLocaleString()}</small>
                                 </div>
                                 <span class="credit" style="background: #00cc00;">-${record.creditsSpent?.toLocaleString() || '?'} C</span> </div>
                         `).join('');
                 }

                 debugLog("Invite section UI updated successfully.");

             } catch (error) {
                 console.error("Error updating invite section UI:", error);
                 debugLog(`Error updating invite section UI: ${error.message}`);
                 // Show error state in UI
                 myInviteEl.textContent = `My Invite: ERR`;
                 totalCreditEl.textContent = `Total Credit ! : ERR`;
                 invitePlaceholder.style.display = 'block';
                 invitePlaceholder.querySelector('p').textContent = 'Error loading invites';
                 claimPlaceholder.style.display = 'block';
                 claimPlaceholder.querySelector('p').textContent = 'Error loading claims';
             }
         }

        // Claim Credits Logic
         document.querySelector('.invite-section .claim-button').addEventListener('click', async () => {
             debugLog("[CREDIT CLAIM] Claim button clicked.");
             if (!telegramUser || !telegramUser.id) {
                 alert("User not authenticated. Please try again.");
                 debugLog("[CREDIT CLAIM ERROR] User not identified.");
                 return;
             }
             if (!firebaseInitialized || !db) {
                 console.error("Firestore not initialized. Cannot claim credits.");
                 debugLog("[CREDIT CLAIM ERROR] Firestore not init.");
                 alert("Database not initialized. Please try again later.");
                 return;
             }

             const claimButton = document.querySelector('.invite-section .claim-button');
             claimButton.disabled = true; // Prevent double-clicks
             claimButton.textContent = 'Checking...';

             const userDocRef = db.collection('userData').doc(telegramUser.id.toString());
             try {
                 const userDoc = await userDocRef.get();
                 if (!userDoc.exists) throw new Error("User data not found for claim.");

                 const data = userDoc.data();
                 const currentCredits = data.referralCredits || 0;
                 const conversionRate = 10000; // 10,000 credits per USDT
                 const minimumClaim = 10000; // Minimum credits to claim

                 debugLog(`[CREDIT CLAIM] Current credits: ${currentCredits}`);

                 if (currentCredits < minimumClaim) {
                     alert(`You need at least ${minimumClaim.toLocaleString()} credits to claim 1 USDT. You have ${currentCredits.toLocaleString()}.`);
                     debugLog(`[CREDIT CLAIM] Insufficient credits.`);
                     claimButton.disabled = false;
                     claimButton.textContent = 'Claim';
                     return;
                 }

                 const usdtToClaim = Math.floor(currentCredits / conversionRate);
                 const creditsToSpend = usdtToClaim * conversionRate;

                 debugLog(`[CREDIT CLAIM] Attempting to claim ${usdtToClaim} USDT for ${creditsToSpend} credits.`);
                 claimButton.textContent = 'Claiming...';

                 const claimRecord = {
                     claimTime: new Date().toISOString(),
                     usdtAmount: usdtToClaim,
                     creditsSpent: creditsToSpend,
                     rate: conversionRate
                 };

                 // Update user data
                 await userDocRef.update({
                     usdt: firebase.firestore.FieldValue.increment(usdtToClaim),
                     referralCredits: firebase.firestore.FieldValue.increment(-creditsToSpend),
                     claimHistory: firebase.firestore.FieldValue.arrayUnion(claimRecord)
                 });

                 debugLog(`[CREDIT CLAIM] Successfully claimed ${usdtToClaim} USDT. Deducted ${creditsToSpend} credits.`);
                 if (analytics) analytics.logEvent('credit_claim', { userId: telegramUser.id, usdt: usdtToClaim, credits: creditsToSpend });

                 alert(`Successfully claimed ${usdtToClaim} USDT!`);

                 // Update UI immediately
                 await updateUserStatsUI();
                 await updateInviteSectionUI();

             } catch (error) {
                 console.error("[CREDIT CLAIM ERROR] Error claiming credits:", error);
                 debugLog(`[CREDIT CLAIM ERROR] ${error.message}`);
                 alert("Failed to claim credits. Please try again.");
             } finally {
                 // Re-enable button
                 claimButton.disabled = false;
                 claimButton.textContent = 'Claim';
             }
         });

        // Invite Button Actions
         document.querySelector('.invite-friend').addEventListener('click', () => {
             const link = document.querySelector('.invite-friend').getAttribute('data-link');
             if (link && window.Telegram && window.Telegram.WebApp) {
                 debugLog("Opening invite link via Telegram...");
                 window.Telegram.WebApp.openTelegramLink(link);
             } else if (link) {
                 debugLog("Cannot open invite link via Telegram, copying instead.");
                 navigator.clipboard.writeText(link).then(() => {
                     alert("Referral link copied! (Could not open directly)");
                 }).catch(err => {
                     alert("Failed to copy link.");
                     console.error("Failed to copy referral link:", err);
                 });
             } else {
                 alert("Referral link not available yet.");
                 debugLog("Invite Friend click failed: No link available.");
             }
         });

         document.querySelector('.copy-link').addEventListener('click', () => {
             const link = document.querySelector('.copy-link').getAttribute('data-link');
             if (link && navigator.clipboard) {
                 navigator.clipboard.writeText(link).then(() => {
                     debugLog("Referral link copied to clipboard.");
                     alert("Referral link copied to clipboard!");
                 }).catch(err => {
                     console.error("Failed to copy referral link:", err);
                     debugLog("Failed to copy referral link:", err);
                     alert("Could not copy link to clipboard.");
                 });
             } else if (link) {
                  alert("Clipboard not available. Cannot copy link.");
                  debugLog("Copy link failed: Clipboard API not available.");
             } else {
                  alert("Referral link not available yet.");
                  debugLog("Copy link failed: No link available.");
             }
         });


        // --- Top Section (Ranking) ---
        async function updateTopSectionUI() {
             debugLog("Updating Top section UI (Ranking)...");
            const rankingList = document.getElementById('ranking-list');
             if (!rankingList) {
                 console.error("[RANKING ERROR] Ranking list element not found!");
                 debugLog("[RANKING ERROR] Ranking list element not found!");
                 return;
             }

             rankingList.innerHTML = `<li class="loading"><p>Loading rankings...</p></li>`; // Loading state

             if (!firebaseInitialized || !db) {
                 debugLog("Ranking update skipped: Firestore not ready.");
                 rankingList.innerHTML = `<li class="error"><p>Database connection failed.</p></li>`;
                 return;
             }

             try {
                 const rankingsSnapshot = await db.collection('users') // Use 'users' collection
                     .orderBy('foxMedals', 'desc')
                     .limit(30) // Fetch top 30
                     .get();

                 const rankings = [];
                 rankingsSnapshot.forEach(doc => {
                     const data = doc.data();
                     rankings.push({
                         id: doc.id, // Include user ID
                         username: data.username || 'Anonymous',
                         foxMedals: data.foxMedals || 0,
                         photoUrl: data.photoUrl || 'assets/icons/user-avatar.png' // Use local fallback
                     });
                 });
                 debugLog(`Workspaceed ${rankings.length} ranking entries.`);

                 if (rankings.length === 0) {
                     rankingList.innerHTML = `<li class="no-rankings"><p>The ranking is empty right now.</p></li>`;
                 } else {
                     rankingList.innerHTML = rankings.map((user, index) => `
                         <li class="ranking-item">
                             <span class="rank-number">${index + 1}.</span> <img src="${user.photoUrl}" alt="${user.username}" onerror="this.src='assets/icons/user-avatar.png'">
                             <span class="rank-username">${user.username}</span>
                             <div class="medal-count">
                                 <span>${user.foxMedals.toLocaleString()}</span>
                                 <img src="assets/icons/fox-medal.png" alt="Fox Medal">
                             </div>
                         </li>
                     `).join('');
                     // Add basic styling for rank number/username if needed in CSS
                     // e.g., .rank-number { margin-right: 10px; font-weight: bold; }
                     // e.g., .rank-username { flex-grow: 1; margin-left: 5px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
                 }
                 debugLog("Top section UI updated successfully.");
             } catch (error) {
                 console.error("Error updating top section UI:", error);
                 debugLog(`Error updating ranking UI: ${error.message}`);
                 rankingList.innerHTML = `<li class="error"><p>Failed to load rankings. Please try again.</p></li>`;
             }
         }


        // --- Wallet Section UI & TON Connect ---
        async function updateWalletSectionUI() {
             debugLog("Updating Wallet section UI...");
             // Update balances first (might depend on updateUserStatsUI)
             await updateUserStatsUI();
             // Then update connection status and history
             await updateWalletConnectionStatusUI();
             await updateTransactionHistory(); // Fetch history
             debugLog("Wallet section UI update complete.");
         }

         // Update only connection-dependent parts
         async function updateWalletConnectionStatusUI() {
             debugLog("Updating Wallet Connection Status UI...");
             const elements = getWalletElements();
             if (!elements.connectButton || !elements.connectionStatus) {
                 debugLog("[WALLET UI ERROR] Connect button or status element not found.");
                 return;
             }

             const isConnected = tonConnectUI && tonConnectUI.connected;
             debugLog(`Wallet connection status: ${isConnected}`);

             if (isConnected) {
                 elements.connectionStatus.textContent = 'Connected';
                 elements.connectionStatus.className = 'wallet-status connected';
                 elements.connectButton.textContent = 'DISCONNECT';
                 elements.connectButton.classList.add('connected');
                 elements.withdrawButtons.forEach(btn => {
                     btn.disabled = false;
                     // Style is handled by :not(:disabled) CSS rule
                 });

                 // Ensure wallet address is stored
                 const walletAddress = tonConnectUI.account?.address;
                 if (walletAddress) {
                     await Storage.setItem('walletAddress', walletAddress);
                     debugLog(`Wallet connected: Address ${walletAddress} stored.`);
                 } else {
                      debugLog("Wallet connected, but address not immediately available from tonConnectUI.account.");
                     // Maybe retrieve from storage if needed immediately
                     const storedAddress = await Storage.getItem('walletAddress');
                     debugLog(`Stored wallet address: ${storedAddress}`);
                 }

             } else {
                 elements.connectionStatus.textContent = 'Disconnected';
                 elements.connectionStatus.className = 'wallet-status disconnected';
                 elements.connectButton.textContent = 'CONNECT TON WALLET';
                 elements.connectButton.classList.remove('connected');
                 elements.withdrawButtons.forEach(btn => {
                     btn.disabled = true;
                 });
                 debugLog("Wallet disconnected state UI updated.");
             }
         }

         // Get wallet-related DOM elements safely
         function getWalletElements() {
            const elements = {
                 connectButton: document.querySelector('.connect-button'),
                 connectionStatus: document.getElementById('connection-status'),
                 withdrawButtons: document.querySelectorAll('.withdraw-button'),
                 walletSection: document.getElementById('wallet'),
                 transactionList: document.getElementById('transaction-list') // Added for history
             };
             // Log if any essential elements are missing
             // if (!elements.connectButton) debugLog("[WALLET UI WARN] Connect Button not found.");
             // if (!elements.connectionStatus) debugLog("[WALLET UI WARN] Connection Status element not found.");
             // if (!elements.transactionList) debugLog("[WALLET UI WARN] Transaction List element not found.");
             return elements;
         }

         // Initialize TON Connect with multiple strategies
         async function initializeTonConnect() {
             debugLog("Initializing TON Connect...");
             try {
                 // Strategy 1: Check if already available (e.g., script loaded separately)
                 if (window.TonConnectUI) {
                     debugLog("TON Connect UI found in window scope.");
                 } else {
                     // Strategy 2: Try loading from CDN
                     const cdnUrl = 'https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js'; // Use latest
                     // const cdnUrl = 'https://unpkg.com/@tonconnect/ui@0.0.14/dist/tonconnect-ui.min.js'; // Or specific version if needed
                     debugLog("Attempting to load TON Connect UI from CDN:", cdnUrl);
                     try {
                          await loadScript(cdnUrl);
                          if (!window.TonConnectUI) throw new Error("Loaded from CDN, but TonConnectUI not defined.");
                          debugLog("TON Connect UI loaded successfully from CDN.");
                     } catch (cdnError) {
                         debugLog(`CDN load failed: ${cdnError.message}. Falling back.`);
                         // Strategy 3: Add fallback or manual implementation if CDN fails reliably
                         console.error("TON Connect UI could not be loaded.", cdnError);
                         throw new Error("TON Connect library failed to load."); // Fail initialization if library missing
                     }
                 }

                 // Create instance
                 tonConnectUI = new TonConnectUI({
                     manifestUrl: 'https://fourgo.app/tonconnect-manifest.json', // Ensure this manifest is valid and accessible
                     buttonRootId: null // Let the library manage its button/modal, don't tie to specific element
                 });
                 debugLog("TON Connect UI instance created.");
                 return tonConnectUI;

             } catch (error) {
                 console.error(`TON Connect initialization failed: ${error.message}`);
                 debugLog(`TON Connect initialization failed: ${error.message}`);
                 alert("Wallet connection features are unavailable.");
                 // Return a dummy object to prevent errors later, but features won't work
                 return {
                     connected: false,
                     account: null,
                     connectWallet: async () => { alert("Wallet connection unavailable."); },
                     disconnect: async () => {},
                     onStatusChange: () => {}
                 };
             }
         }

         // Handle wallet connection/disconnection clicks
         async function handleConnectClick() {
             debugLog("[WALLET ACTION] Connect/Disconnect button clicked.");
             const elements = getWalletElements();
             if (!elements.connectButton || !tonConnectUI) {
                 debugLog("[WALLET ACTION ERROR] Button or TON Connect UI missing.");
                 return;
             }

             elements.connectButton.disabled = true; // Disable during action
             elements.connectButton.textContent = 'Processing...';

             try {
                 if (tonConnectUI.connected) {
                     debugLog("Disconnecting wallet...");
                     await tonConnectUI.disconnect();
                     debugLog("Wallet disconnect initiated.");
                     // UI update will be triggered by onStatusChange
                 } else {
                     debugLog("Connecting wallet...");
                     // The library handles opening the modal/wallet selection
                     await tonConnectUI.connectWallet();
                     debugLog("Wallet connection process initiated.");
                     // UI update will be triggered by onStatusChange
                 }
             } catch (error) {
                 console.error(`Wallet connection/disconnection error: ${error.message}`);
                 debugLog(`Wallet connect/disconnect error: ${error.message}`);
                 alert(`Wallet action failed: ${error.message}`);
                 // Re-enable button and update UI on error
                 elements.connectButton.disabled = false;
                 await updateWalletConnectionStatusUI(); // Reset UI based on actual state
             } finally {
                 // Re-enable button after a short delay unless handled by status change
                 // setTimeout(() => {
                 //     if (elements.connectButton) elements.connectButton.disabled = false;
                 // }, 500);
                 // Let onStatusChange handle the final button state
             }
         }

         // Initialize the wallet system (TON Connect listeners, button handlers)
         async function initWalletSystem() {
             debugLog("Initializing wallet system...");
             if (!tonConnectUI) {
                 debugLog("Wallet system init skipped: TON Connect UI not available.");
                 return; // Don't proceed if TON Connect failed to init
             }
             const elements = getWalletElements();
             if (!elements.connectButton) {
                 debugLog("Wallet system init skipped: Connect button not found.");
                 return;
             }

             try {
                 // Setup TON Connect status change listener
                 tonConnectUI.onStatusChange(async (walletInfo) => {
                     // walletInfo is null if disconnected, or object with account info if connected
                     debugLog(`[WALLET STATUS CHANGE] Wallet status changed. Connected: ${!!walletInfo}`, walletInfo ? { address: walletInfo.account.address, chain: walletInfo.account.chain } : null);
                     await updateWalletConnectionStatusUI(); // Update UI based on new status
                     // Re-enable connect button after status change completes
                     if (elements.connectButton) elements.connectButton.disabled = false;
                 }, (error) => {
                      // Handle errors from the status change listener itself
                      console.error("[WALLET STATUS CHANGE ERROR]", error);
                      debugLog(`[WALLET STATUS CHANGE ERROR] ${error.message}`);
                      // Optionally update UI to show an error state
                 });

                 // Add connect/disconnect button listener
                 elements.connectButton.removeEventListener('click', handleConnectClick); // Remove previous if any
                 elements.connectButton.addEventListener('click', handleConnectClick);

                 // Initial UI update based on current state (if any)
                 await updateWalletConnectionStatusUI();

                 // Setup withdraw button listeners
                 elements.withdrawButtons.forEach(button => {
                     // Remove previous listener first to prevent duplicates
                     const card = button.closest('.balance-card');
                     const newButton = button.cloneNode(true); // Clone to easily remove listeners
                     button.parentNode.replaceChild(newButton, button);
                     if (card) {
                         newButton.addEventListener('click', () => showWithdrawModal(card));
                     } else {
                         debugLog("[WALLET WARN] Could not find parent card for a withdraw button.");
                     }
                 });

                 // Setup warning button listeners (if they do anything)
                 // document.querySelectorAll('.warning-button').forEach(button => { ... });

                 debugLog("Wallet system initialized successfully.");
             } catch (error) {
                 console.error(`Wallet system init failed: ${error.message}`);
                 debugLog(`Wallet system init failed: ${error.message}`);
             }
         }

         // Show withdraw modal
         function showWithdrawModal(cardElement) {
             debugLog("Showing withdraw modal...");
             const modal = document.getElementById('withdraw-modal');
             const amountInput = document.getElementById('withdraw-amount');
             const availableBalanceEl = document.getElementById('available-balance');
             const currencySpan = document.getElementById('currency');
             const feeSpan = document.getElementById('withdraw-fee');
             const feeCurrencySpan = document.getElementById('fee-currency');

             if (!modal || !amountInput || !availableBalanceEl || !currencySpan || !feeSpan || !feeCurrencySpan) {
                 console.error("Withdraw modal elements missing!");
                 debugLog("[WITHDRAW ERROR] Modal elements missing.");
                 alert("Withdrawal component error.");
                 return;
             }

             const isUsdt = cardElement.classList.contains('usdt-card');
             const currency = isUsdt ? 'USDT' : 'TON';
             const balance = parseFloat(cardElement.querySelector('.balance-info span')?.textContent || '0'); // Use optional chaining
             const fee = isUsdt ? 0.01 : 0.005; // Example fees - fetch from config/Firestore ideally

             availableBalanceEl.textContent = balance.toFixed(4);
             currencySpan.textContent = currency;
             feeSpan.textContent = fee.toFixed(isUsdt ? 2 : 3); // Show fee precision
             feeCurrencySpan.textContent = currency;
             amountInput.value = '';
             amountInput.max = Math.max(0, balance - fee).toFixed(4); // Set max withdrawable amount
             amountInput.step = isUsdt ? "0.0001" : "0.001"; // Set appropriate step

             // Remove previous listeners and add new ones
             const confirmButton = document.getElementById('confirm-withdraw');
             const cancelButton = document.getElementById('cancel-withdraw');
             const newConfirmButton = confirmButton.cloneNode(true);
             const newCancelButton = cancelButton.cloneNode(true);
             confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
             cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);

             newConfirmButton.onclick = () => confirmWithdraw(currency, balance, fee);
             newCancelButton.onclick = () => { modal.style.display = 'none'; debugLog("Withdraw modal cancelled."); };

             modal.style.display = 'flex';
             debugLog(`Withdraw modal shown for ${currency}. Balance: ${balance}, Fee: ${fee}`);
         }

         // Confirm withdrawal (Simulation - No actual blockchain TX)
         async function confirmWithdraw(currency, balance, fee) {
             debugLog(`[WITHDRAW ACTION] Confirming withdrawal for ${currency}...`);
             const modal = document.getElementById('withdraw-modal');
             const amountInput = document.getElementById('withdraw-amount');
             const amount = parseFloat(amountInput.value);

             const confirmButton = document.getElementById('confirm-withdraw');
             confirmButton.disabled = true;
             confirmButton.textContent = 'Processing...';

             if (isNaN(amount) || amount <= 0) {
                 alert("Invalid amount entered.");
                 debugLog("[WITHDRAW ERROR] Invalid amount.");
                 confirmButton.disabled = false;
                 confirmButton.textContent = 'Confirm';
                 return;
             }
             if (amount + fee > balance) {
                 alert("Insufficient balance to cover amount and fee.");
                 debugLog("[WITHDRAW ERROR] Insufficient balance.");
                 confirmButton.disabled = false;
                 confirmButton.textContent = 'Confirm';
                 return;
             }

             if (!tonConnectUI || !tonConnectUI.connected || !tonConnectUI.account?.address) {
                 alert("Wallet not connected. Please connect your wallet first.");
                 debugLog("[WITHDRAW ERROR] Wallet not connected.");
                 confirmButton.disabled = false;
                 confirmButton.textContent = 'Confirm';
                 modal.style.display = 'none'; // Close modal if wallet disconnected
                 return;
             }
             const destinationAddress = tonConnectUI.account.address;

             try {
                 const userDocRef = db.collection('userData').doc(telegramUser.id.toString());
                 const totalDeduction = amount + fee;
                 const balanceField = currency.toLowerCase(); // 'usdt' or 'ton'

                 // --- Simulation Start ---
                 debugLog(`[WITHDRAW SIMULATION] Initiating withdrawal: ${amount} ${currency} to ${destinationAddress} (Fee: ${fee} ${currency})`);

                 // 1. Create Transaction Record (Pending)
                 const transaction = {
                     txId: `sim_tx_${Date.now()}`, // Simulated TX ID
                     userId: telegramUser.id.toString(),
                     amount: amount,
                     currency: currency,
                     fee: fee,
                     totalDeducted: totalDeduction,
                     destination: destinationAddress,
                     status: 'pending', // Initial status
                     timestamp: firebase.firestore.FieldValue.serverTimestamp(), // Use server timestamp
                     type: 'withdrawal'
                 };
                 // Save to a general transactions collection or user subcollection
                 // Using user subcollection here:
                 const txRef = db.collection('userData').doc(telegramUser.id.toString())
                                 .collection('transactions').doc(transaction.txId);
                 await txRef.set(transaction);
                 debugLog(`[WITHDRAW SIMULATION] Pending transaction record created: ${transaction.txId}`);

                 // 2. Deduct Balance from User Data
                 await userDocRef.update({
                     [balanceField]: firebase.firestore.FieldValue.increment(-totalDeduction)
                 });
                 debugLog(`[WITHDRAW SIMULATION] User balance deducted: -${totalDeduction} ${currency}`);

                 // 3. Simulate Processing Delay & Completion
                 setTimeout(async () => {
                     try {
                         await txRef.update({ status: 'completed' }); // Update status to completed
                         debugLog(`[WITHDRAW SIMULATION] Transaction ${transaction.txId} marked as completed.`);
                         await updateTransactionHistory(); // Refresh history UI
                     } catch (simError) {
                          console.error("Error updating simulated transaction status:", simError);
                          debugLog(`[WITHDRAW SIMULATION ERROR] Failed updating tx ${transaction.txId} status: ${simError.message}`);
                          // Optionally try to revert balance or mark TX as failed
                          await txRef.update({ status: 'failed', failureReason: simError.message });
                     }
                 }, 5000); // 5-second delay simulation

                 // --- Simulation End ---

                 if (analytics) analytics.logEvent('withdrawal_initiated', { userId: telegramUser.id, currency, amount, fee });

                 modal.style.display = 'none'; // Close modal on initiation
                 await updateUserStatsUI(); // Update main balance UI
                 await updateTransactionHistory(); // Show pending transaction
                 alert(`Withdrawal of ${amount.toFixed(4)} ${currency} initiated (Fee: ${fee.toFixed(4)} ${currency}). It may take a few moments to confirm.`);

             } catch (error) {
                 console.error(`Withdrawal error: ${error.message}`);
                 debugLog(`[WITHDRAW ERROR] ${error.message}`);
                 alert(`Withdrawal failed: ${error.message}`);
             } finally {
                  // Ensure button is re-enabled if modal somehow stays open
                  confirmButton.disabled = false;
                  confirmButton.textContent = 'Confirm';
             }
         }

         // Update transaction history display
         async function updateTransactionHistory() {
             debugLog("Updating transaction history...");
             const elements = getWalletElements();
             if (!elements.transactionList) {
                 debugLog("Transaction history list element not found.");
                 return;
             }

             elements.transactionList.innerHTML = '<li>Loading history...</li>'; // Loading state

             if (!firebaseInitialized || !db || !telegramUser || !telegramUser.id) {
                 debugLog("Transaction history skipped: Firestore or User not ready.");
                 elements.transactionList.innerHTML = '<li>Could not load history (Auth/DB error).</li>';
                 return;
             }

             try {
                 const txCollectionRef = db.collection('userData').doc(telegramUser.id.toString())
                                         .collection('transactions');
                 const snapshot = await txCollectionRef
                     .orderBy('timestamp', 'desc')
                     .limit(15) // Show last 15 transactions
                     .get();

                 if (snapshot.empty) {
                     debugLog("No transaction history found.");
                     elements.transactionList.innerHTML = '<li>No transactions yet</li>';
                     return;
                 }

                 debugLog(`Workspaceed ${snapshot.docs.length} transaction history entries.`);
                 elements.transactionList.innerHTML = snapshot.docs.map(doc => {
                     const tx = doc.data();
                     const txTime = tx.timestamp?.toDate ? tx.timestamp.toDate().toLocaleString() : 'Invalid date'; // Handle timestamp object
                     let detail = '';
                      if (tx.type === 'withdrawal') {
                          detail = `Withdraw ${tx.amount?.toFixed(4)} ${tx.currency} (Fee: ${tx.fee?.toFixed(4)})`;
                      } else if (tx.type === 'credit_claim') { // Assuming you log claims this way
                          detail = `Claimed ${tx.usdtAmount?.toFixed(4)} USDT (${tx.creditsSpent?.toLocaleString()} C)`;
                      } else {
                          detail = `Type: ${tx.type || 'Unknown'}`; // Fallback
                      }

                     return `
                         <li>
                             ${detail} -
                             <span class="tx-status ${tx.status || 'unknown'}">${tx.status || 'unknown'}</span> -
                             ${txTime}
                         </li>
                     `;
                 }).join('');
             } catch (error) {
                 console.error(`Error updating transaction history: ${error.message}`);
                 debugLog(`Error updating transaction history: ${error.message}`);
                 elements.transactionList.innerHTML = `<li>Error loading history.</li>`;
             }
         }


        // --- Chest Section Logic ---
        function renderChests() {
            debugLog("[CHEST] Rendering chests...");
            const container = document.getElementById('chestContainer');
            if (!container) {
                debugLog("[CHEST ERROR] Chest container not found.");
                return;
            }
            container.innerHTML = chests.map((chest, index) => `
                <div class="chest-item" data-index="${index}">
                    <div class="chest-title">
                        <h2>${chest.name}</h2>
                        <span>${chest.next ? `Next: ${chest.next}` : 'Max Level'}</span>
                    </div>
                    <div class="chest-image">
                        <img src="${chest.image}" alt="${chest.name}" onerror="this.src='assets/icons/chest_placeholder.png'">
                    </div>
                     <div class="chest-cost-display" style="margin-top: 10px;"></div>
                     <div class="chest-vip-display" style="display: none; color: #ffcc00; margin-top: 10px;"></div>
                     <div class="chest-not-enough-display" style="display: none; color: #ffcc00; margin-top: 10px;">
                         <img src="assets/icons/gem.png" alt="Gem" style="width: 16px; height: 16px; vertical-align: middle;">
                         <span>NOT ENOUGH</span>
                     </div>
                </div>
            `).join('');
             debugLog(`[CHEST] Rendered ${chests.length} chests.`);
             updateChestUI(); // Initial UI update for the first chest
         }

        function updateChestUI() {
            const chest = chests[currentChestIndex];
             debugLog(`[CHEST] Updating UI for Chest index: ${currentChestIndex} (${chest.name})`);
            const container = document.getElementById('chestContainer');
            const costDisplay = document.querySelector(`#chestContainer .chest-item[data-index="${currentChestIndex}"] .chest-cost-display`);
            const vipDisplay = document.querySelector(`#chestContainer .chest-item[data-index="${currentChestIndex}"] .chest-vip-display`);
            const notEnoughDisplay = document.querySelector(`#chestContainer .chest-item[data-index="${currentChestIndex}"] .chest-not-enough-display`);
            const openButton = document.querySelector('.open-chest-button');

            if (!container || !costDisplay || !vipDisplay || !notEnoughDisplay || !openButton) {
                debugLog("[CHEST UI ERROR] Elements needed for chest UI update not found.");
                return;
            }

            // --- Update Slider Position ---
            container.style.transform = `translateX(-${currentChestIndex * 100}%)`;

            // --- Update Cost/VIP Requirement Display ---
             costDisplay.style.display = 'none'; // Hide all initially
             vipDisplay.style.display = 'none';
             notEnoughDisplay.style.display = 'none';
             openButton.disabled = false; // Enable button by default

             // Check VIP requirement first
             // Assume vipLevel is stored in userData (needs fetching or global var)
             let userVipLevel = 0; // Replace with actual user VIP level later
             if (chest.vip > userVipLevel) {
                 vipDisplay.textContent = `NEED VIP ${chest.vip}`;
                 vipDisplay.style.display = 'block';
                 openButton.disabled = true;
                 openButton.textContent = `VIP ${chest.vip} Required`;
                 debugLog(`[CHEST] VIP ${chest.vip} required, user has ${userVipLevel}. Button disabled.`);
             } else {
                  // Show cost if VIP level is met
                  costDisplay.innerHTML = `
                      <img src="assets/icons/gem.png" alt="Gem" style="width: 20px; height: 20px; vertical-align: middle;">
                      <span>${chest.gemCost.toLocaleString()}</span>
                  `;
                  costDisplay.style.display = 'flex'; // Use flex to align icon and text
                  costDisplay.style.justifyContent = 'center';
                  costDisplay.style.alignItems = 'center';
                  costDisplay.style.gap = '5px';
                  openButton.textContent = 'Open Chest';

                  // Check if user has enough gems (needs user data)
                  const userGems = parseInt(document.getElementById('gems')?.textContent?.replace(/,/g, '') || '0');
                  if (userGems < chest.gemCost) {
                       notEnoughDisplay.style.display = 'flex'; // Use flex
                       notEnoughDisplay.style.justifyContent = 'center';
                       notEnoughDisplay.style.alignItems = 'center';
                       notEnoughDisplay.style.gap = '5px';
                       openButton.disabled = true;
                       debugLog(`[CHEST] Insufficient gems. Need ${chest.gemCost}, user has ${userGems}. Button disabled.`);
                  } else {
                      debugLog(`[CHEST] User meets VIP and Gem requirements. Button enabled.`);
                  }
             }


            // --- Update Navigation Arrows ---
            document.querySelector('.nav-arrow.left').style.display = currentChestIndex === 0 ? 'none' : 'block';
            document.querySelector('.nav-arrow.right').style.display = currentChestIndex === chests.length - 1 ? 'none' : 'block';
        }

        window.nextChest = function() {
            if (currentChestIndex < chests.length - 1) {
                currentChestIndex++;
                debugLog(`[CHEST] Next button clicked. New index: ${currentChestIndex}`);
                updateChestUI();
            }
        };

        window.prevChest = function() {
            if (currentChestIndex > 0) {
                currentChestIndex--;
                debugLog(`[CHEST] Previous button clicked. New index: ${currentChestIndex}`);
                updateChestUI();
            }
        };

        window.openChest = async function() {
             const chest = chests[currentChestIndex];
             debugLog(`[CHEST ACTION] Attempting to open chest: ${chest.name}`);
             const openButton = document.querySelector('.open-chest-button');
             openButton.disabled = true; // Prevent double clicks
             openButton.textContent = 'Opening...';


             if (!telegramUser || !telegramUser.id) {
                 alert("User not authenticated. Please try again.");
                 debugLog("[CHEST ERROR] User not identified.");
                 openButton.disabled = false; openButton.textContent = 'Open Chest';
                 return;
             }
             if (!firebaseInitialized || !db) {
                 console.error("Firestore not initialized. Cannot open chest.");
                 debugLog("[CHEST ERROR] Firestore not init.");
                 alert("Database not initialized. Please try again later.");
                 openButton.disabled = false; openButton.textContent = 'Open Chest';
                 return;
             }

             const userDocRef = db.collection('userData').doc(telegramUser.id.toString());
             const rankingDocRef = db.collection('users').doc(telegramUser.id.toString()); // For updating medals

             try {
                 const userDoc = await userDocRef.get();
                 if (!userDoc.exists) throw new Error("User data not found to open chest.");

                 const userData = userDoc.data();
                 const currentGems = userData.gems || 0;

                 // Final check for VIP (if applicable) and Gems
                 let userVipLevel = 0; // Fetch actual VIP level if implemented
                 if (chest.vip > userVipLevel) {
                      throw new Error(`VIP Level ${chest.vip} required.`);
                 }
                 if (currentGems < chest.gemCost) {
                     throw new Error(`Insufficient gems. Need ${chest.gemCost}, have ${currentGems}.`);
                 }

                 // --- Simulate Reward Calculation ---
                 // Replace with actual server-side logic or more complex client-side odds
                 const rewards = {
                     usdt: parseFloat((Math.random() * (chest.gemCost / 4000) + (chest.gemCost / 10000)).toFixed(4)), // USDT scales slightly with cost
                     landPiece: Math.random() < 0.1 ? 1 : 0, // 10% chance for land piece?
                     foxMedal: Math.floor(Math.random() * (currentChestIndex + 1)) + 1 // More medals for better chests
                 };
                 debugLog("[CHEST ACTION] Calculated rewards:", rewards);

                 // --- Update Firestore ---
                 await userDocRef.update({
                     gems: firebase.firestore.FieldValue.increment(-chest.gemCost),
                     usdt: firebase.firestore.FieldValue.increment(rewards.usdt),
                     landPieces: firebase.firestore.FieldValue.increment(rewards.landPiece),
                     foxMedals: firebase.firestore.FieldValue.increment(rewards.foxMedal)
                 });
                 // Also update ranking collection if medals were awarded
                 if (rewards.foxMedal > 0) {
                      await rankingDocRef.set({ // Use set with merge to create if missing
                          foxMedals: firebase.firestore.FieldValue.increment(rewards.foxMedal)
                      }, { merge: true });
                 }
                 debugLog(`[CHEST ACTION] Firestore updated. Deducted ${chest.gemCost} gems. Added rewards.`);

                 if (analytics) analytics.logEvent('chest_opened', { userId: telegramUser.id, chestName: chest.name, cost: chest.gemCost, rewards });

                 // --- Show Rewards (Simple Alert for now) ---
                 let rewardString = `Opened ${chest.name}! Rewards:\n`;
                 if (rewards.usdt > 0) rewardString += `- ${rewards.usdt.toFixed(4)} USDT\n`;
                 if (rewards.landPiece > 0) rewardString += `- ${rewards.landPiece} Land Piece\n`;
                 if (rewards.foxMedal > 0) rewardString += `- ${rewards.foxMedal} Fox Medal\n`;
                 alert(rewardString);

                 // Update UI
                 await updateUserStatsUI();
                 updateChestUI(); // Re-check requirements/costs after opening

             } catch (error) {
                 console.error("Error opening chest:", error);
                 debugLog(`[CHEST ERROR] ${error.message}`);
                 alert(`Failed to open chest: ${error.message}`);
             } finally {
                 // Re-enable button
                 openButton.disabled = false;
                 // updateChestUI should set the correct text, but set a default here
                 openButton.textContent = 'Open Chest';
                 // Update UI again just in case something failed mid-way
                 updateChestUI();
             }
         };


        // --- App Initialization ---
        async function initApp() {
            debugLog("--- App Initialization Sequence Start ---");

             // 1. Initialize Telegram Interface
            initializeTelegram(); // Run this first to get user info if possible

             // 2. Initialize Firebase
            const firebaseSuccess = await initializeFirebase();
            if (!firebaseSuccess) {
                debugLog("App Init Failed: Firebase could not be initialized.");
                // Optionally hide main content and show an error message overlay
                return; // Stop initialization if Firebase fails
            }

            // 3. Initialize User Data (Create if new, update if existing)
             await ensureFirebaseReady(initializeUserData, 'initializeUserData');

            // 4. Handle Incoming Referrals
             await ensureFirebaseReady(handleReferral, 'handleReferral');

             // 5. Generate User's Referral Link
            generateReferralLink();

             // 6. Initialize TON Connect
            tonConnectUI = await initializeTonConnect(); // Initialize wallet library

             // 7. Setup Wallet System Listeners & UI
             await initWalletSystem(); // Setup listeners AFTER tonConnectUI is ready

            // 8. Render Dynamic Components (Chests)
            renderChests(); // Render chest items

            // 9. Setup Main Navigation
            setupNavigation(); // Setup listeners and default section AFTER basic structure is ready

            // 10. Initial Data Load for Default Section (handled by setupNavigation/switchSection)

            debugLog("--- App Initialization Sequence Finished ---");

             // Removed automatic ad showing on launch
             // try { showMonetagAd(); } catch(e){ debugLog("Initial ad failed", e); }
         }

        // --- DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log('[DEBUG] DOMContentLoaded event fired.');
            debugLog("DOMContentLoaded event fired. Starting App Initialization.");
            initApp(); // Start the main application logic
        });

    </script>
</body>
</html>
