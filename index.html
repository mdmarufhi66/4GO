<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4Metas Mini App</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src='//whephiwums.com/sdk.js' data-zone='9180370' data-sdk='show_9180370'></script>
    <style>
        /* Updated body structure */
        body {
            background: linear-gradient(to bottom, #330033, #000000);
            color: white;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Main content area */
        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            padding-bottom: 70px; /* Space for bottom nav */
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            position: sticky;
            top: 0;
            background: linear-gradient(to bottom, #330033, #000000);
            z-index: 1000;
        }
        header h1 {
            font-size: 24px;
            margin: 0;
        }
        .back-arrow, .menu-dots {
            font-size: 24px;
            cursor: pointer;
        }
        .user-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 0 10px;
        }
        .user-stats .logo img {
            width: 50px;
            height: 50px;
        }
        .user-stats .metric {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .user-stats .metric img {
            width: 20px;
            height: 20px;
        }
        .user-stats .profile-pic img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        .section {
            display: none; /* Sections hidden by default */
        }
        .section.active {
            display: block; /* Active section is visible */
        }
        .banner-placeholder {
            background: #1a1a3d;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            margin-bottom: 20px;
        }
        .banner-placeholder img {
            width: 100%;
            border-radius: 10px;
        }
        .quest-section h2 {
            font-size: 18px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .quest-section .badge {
            background: #ff00ff;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
        }
        .quest-list {
            list-style: none;
            padding: 0;
        }
        /* Style for error messages in lists */
        .quest-list .error p {
             color: #ffcc00; /* Yellow/Orange for errors */
             font-style: italic;
        }
        .quest-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .quest-item img {
            width: 30px;
            height: 30px;
            border-radius: 50%;
        }
        .quest-reward {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .quest-reward img {
            width: 20px;
            height: 20px;
        }
        .go-button, .claim-button, .claimed-button {
            border: none;
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
        }
        .go-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
        }
        .claim-button {
            background: linear-gradient(to right, #00ff00, #66ff66); /* Default claim button */
        }
        .claimed-button {
            background: #ccc;
            cursor: default;
        }
        .quest-item .progress {
            font-size: 12px;
            color: #ccc;
            margin-left: 10px;
        }
        .claim-button.active {
             background: linear-gradient(to right, #00ff00, #66ff66); /* Active (ready to claim) state */
        }
        .wallet-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .balance-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .balance-card img {
            width: 30px;
            height: 30px;
        }
        .balance-info span {
            display: block;
            font-size: 16px;
        }
        .balance-info small {
            font-size: 12px;
            color: #ccc;
        }
        .withdraw-button {
            background: #666; /* Default disabled color */
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
        }
         .withdraw-button:not(:disabled) {
             background: #00ff00; /* Enabled color */
         }
        .warning-button {
            background: #ffcc00;
            border: none;
            color: black;
            padding: 5px 10px;
            border-radius: 50%;
            cursor: pointer;
        }
        .connect-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 15px;
            width: 100%;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.3s ease;
        }
        .connect-button.connected {
            background: linear-gradient(to right, #00ff00, #66ff66);
        }
        .connect-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .wallet-status {
            text-align: center;
            margin: 10px 0;
        }
        .wallet-status.connected {
            color: #00ff00;
        }
        .wallet-status.disconnected {
            color: #ffcc00;
        }
        .transaction-history {
            margin-top: 20px;
        }
        .transaction-history ul {
            list-style: none;
            padding: 0;
        }
        .transaction-history li {
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-content {
            background: #1a1a3d;
            padding: 20px;
            border-radius: 10px;
            color: white;
            width: 80%;
            max-width: 400px;
        }
        .modal-content input {
            width: calc(100% - 12px); /* Adjust for padding */
            padding: 5px;
            margin: 10px 0;
            box-sizing: border-box; /* Include padding in width */
        }
        .game-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .game-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); /* Responsive grid */
            gap: 10px;
        }
        .game-item {
            background: #1a1a3d;
            border-radius: 10px;
            text-align: center;
            padding: 5px;
        }
        .game-item img {
            width: 100%;
            max-width: 80px; /* Limit image size */
            height: auto;   /* Maintain aspect ratio */
            border-radius: 10px;
        }
        .game-item p {
            margin: 5px 0;
            font-size: 12px;
        }
        .invite-section .invite-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .invite-stats .spin-info {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .action-button {
            background: linear-gradient(to right, #00ff00, #66ff66);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 15px;
            flex: 1;
            cursor: pointer;
        }
        .total-credit {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
         .total-credit .credit-info { /* Wrapper for text */
             display: flex;
             flex-direction: column; /* Stack text */
         }
        .total-credit small {
            font-size: 12px;
            color: #ccc;
            display: flex; /* Align image and text */
            align-items: center;
            gap: 3px;
        }
        .total-credit small img {
            width: 15px;
            height: 15px;
            vertical-align: middle; /* Better alignment */
        }
        .record-section h3, .invite-record h3 {
            font-size: 16px;
            margin: 10px 0;
        }
        .no-frens {
            text-align: center;
            color: #ccc;
            padding: 20px 0; /* Add some padding */
        }
        .no-frens img {
            width: 50px;
            height: 50px;
            margin-bottom: 10px; /* Space below image */
        }
        .record-header {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #ccc;
            margin-bottom: 10px;
            padding: 0 10px; /* Align with items */
        }
         .record-list { /* Container for items or no-frens message */
             /* Optional: Add styling if needed */
         }
        .record-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .record-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        .record-item .user-info {
            flex: 1;
            margin-left: 10px;
        }
        .record-item .user-info span {
             display: block; /* Ensure username is on its own line */
         }
        .record-item .user-info small {
            color: #ccc;
            font-size: 12px;
        }
        .record-item .credit {
            background: #ff00ff;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px; /* Slightly smaller */
        }
        .chest-section .chest-slider {
            position: relative;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .chest-container {
            display: flex;
            transition: transform 0.3s ease;
        }
        .chest-item {
            flex: 0 0 100%;
            text-align: center;
            padding: 10px; /* Add padding */
            box-sizing: border-box;
        }
        .chest-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 16px;
            margin-bottom: 10px; /* Space below title */
        }
        .chest-title span {
            color: #ccc;
            font-size: 14px; /* Smaller text */
        }
        .chest-image img {
            width: 150px;
            height: 150px;
            margin-bottom: 10px; /* Space below image */
        }
        .not-enough {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            color: #ffcc00;
            margin-top: 10px;
        }
        .not-enough img {
            width: 20px;
            height: 20px;
        }
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.5);
            border: none;
            color: white;
            padding: 10px;
            cursor: pointer;
            z-index: 100;
            border-radius: 50%; /* Make arrows round */
        }
        .nav-arrow.left {
            left: 5px; /* Adjust position */
        }
        .nav-arrow.right {
            right: 5px; /* Adjust position */
        }
        .rewards {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
        }
        .reward-item {
            text-align: center;
        }
        .reward-item img {
            width: 40px;
            height: 40px;
        }
        .reward-item p {
            margin: 5px 0;
            font-size: 12px;
        }
        .cost {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            margin-bottom: 10px;
            font-size: 16px; /* Make cost text larger */
        }
        .cost img {
            width: 20px;
            height: 20px;
        }
        .vip-requirement {
            text-align: center;
            color: #ffcc00;
            margin-bottom: 10px;
        }
        .open-chest-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 15px;
            width: 100%;
            cursor: pointer;
            font-size: 16px; /* Make button text larger */
        }
        .top-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .ranking-list {
            list-style: none;
            padding: 0;
        }
         .no-rankings {
             text-align: center;
             color: #ccc;
             padding: 20px 0;
         }
        .ranking-item {
            display: flex;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .ranking-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .ranking-item span {
            flex: 1;
        }
        .ranking-item .medal-count {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .ranking-item .medal-count img {
            width: 20px;
            height: 20px;
        }

        /* --- Navigation Styles --- */
        nav.bottom-nav {
            display: flex !important;
            justify-content: space-around !important;
            background: #1a1a3d !important;
            padding: 5px 0 !important; /* Adjusted padding */
            position: fixed !important;
            bottom: 0 !important; /* Use 0, handle safe area via padding/margin if needed */
            padding-bottom: env(safe-area-inset-bottom, 5px) !important; /* Add padding for safe area */
            left: 0 !important;
            right: 0 !important;
            z-index: 100000 !important;
            height: 60px !important; /* Maintain height */
            visibility: visible !important;
            opacity: 1 !important;
            border-top: 1px solid #ff00ff !important; /* Adjusted border */
            box-shadow: 0 -2px 10px rgba(100, 0, 100, 0.4) !important; /* Adjusted shadow */
        }

        nav.bottom-nav .nav-button {
            background: none !important;
            border: none !important;
            color: #ccc !important;
            display: flex !important;
            flex-direction: column !important;
            align-items: center !important;
            justify-content: center !important;
            cursor: pointer !important;
            font-size: 10px !important; /* Slightly smaller text */
            width: auto !important; /* Allow flexible width */
            flex: 1 !important; /* Distribute space equally */
            height: 100% !important;
            visibility: visible !important;
            opacity: 1 !important;
            min-height: 40px !important;
            padding: 0 2px; /* Add minimal horizontal padding */
        }

        nav.bottom-nav .nav-button.active {
            color: white !important;
        }

        nav.bottom-nav .nav-button img {
            width: 24px !important;
            height: 24px !important;
            margin-bottom: 3px !important; /* Adjusted spacing */
            display: block !important;
        }

        nav.bottom-nav .nav-button span {
            display: block !important;
            white-space: nowrap; /* Prevent text wrapping */
        }

        /* Additional styles for wallet integration */
        .error-message {
            color: #ffcc00;
            text-align: center;
            margin: 10px 0;
            display: none;
        }

        .tx-status.pending { color: #ffcc00; }
        .tx-status.completed { color: #00ff00; }
        .tx-status.failed { color: #ff0000; }

        /* Debug Console Style */
         #debugConsole {
             position: fixed;
             bottom: 70px; /* Above nav bar */
             left: 0;
             right: 0;
             background: rgba(0,0,0,0.85); /* Slightly more opaque */
             color: #0f0; /* Green text */
             padding: 10px;
             font-family: monospace;
             font-size: 10px; /* Smaller font */
             max-height: 150px; /* Adjust height */
             overflow-y: auto;
             z-index: 99999; /* Below nav bar but high */
             display: none; /* Hidden by default */
             border-top: 1px solid #0f0;
         }
         #toggleDebugButton { /* Style the toggle button */
            position: fixed;
            bottom: 80px; /* Position relative to debug console */
            right: 10px;
            z-index: 100000; /* Above debug console */
            padding: 3px 8px;
            background: #ff00ff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 10px;
            cursor: pointer;
         }

    </style>
</head>
<body>
    <header>
        <div class="back-arrow">X</div>
        <h1>4Metas</h1>
        <div class="menu-dots">⋮</div>
    </header>

    <div class="main-content">
        <section class="user-stats">
            <div class="logo">
                <img src="assets/icons/logo.png" alt="4Metas Logo">
            </div>
            <div class="metric">
                <img src="assets/icons/gem.png" alt="Gem">
                <span id="gems">0</span>
            </div>
            <div class="metric">
                <img src="assets/icons/usdt.png" alt="USDT">
                <span id="usdt">0.0000</span>
            </div>
            <div class="metric">
                <img src="assets/icons/ton.png" alt="TON">
                <span id="ton">0.0000</span>
            </div>
            <div class="profile-pic">
                <img src="assets/icons/user-avatar.png" alt="User Profile">
            </div>
        </section>

        <section id="earn" class="section earn-section active">
            <div class="banner-placeholder">
                <img src="assets/icons/banner.png" alt="Banner">
            </div>
            <div class="quest-section">
                <h2>DAILY QUEST <span class="badge" id="daily-quest-count">0</span></h2>
                <ul class="quest-list" id="daily-quest-list">
                    <li class="no-quests">
                        <p>Loading daily quests...</p> </li>
                </ul>
            </div>
            <div class="quest-section">
                <h2>BASIC QUEST <span class="badge" id="basic-quest-count">0</span></h2>
                <ul class="quest-list" id="basic-quest-list">
                    <li class="no-quests">
                        <p>Loading basic quests...</p> </li>
                </ul>
            </div>
        </section>

        <section id="wallet" class="section wallet-section">
            <h2>Wallet</h2>
            <div class="wallet-status disconnected">
                <span id="connection-status">Disconnected</span>
            </div>
            <div class="balance-card usdt-card">
                <img src="assets/icons/usdt.png" alt="USDT Icon">
                <div class="balance-info">
                    <span id="wallet-usdt">0.0000</span>
                    <small>USDT</small>
                </div>
                <button class="withdraw-button" disabled>WITHDRAW</button>
                <button class="warning-button">!</button>
            </div>
            <div class="balance-card ton-card">
                <img src="assets/icons/ton.png" alt="TON Icon">
                <div class="balance-info">
                    <span id="wallet-ton">0.0000</span>
                    <small>TON</small>
                </div>
                <button class="withdraw-button" disabled>WITHDRAW</button>
                <button class="warning-button">!</button>
            </div>
            <p class="instruction">Connect wallet to withdraw your balance.</p>
            <button class="connect-button">CONNECT TON WALLET</button>
            <div class="transaction-history">
                <h3>Transaction History</h3>
                <ul id="transaction-list">
                    <li>No transactions yet</li>
                </ul>
            </div>
            <div id="withdraw-modal" class="modal" style="display: none;">
                <div class="modal-content">
                    <h3>Withdraw Funds</h3>
                    <label>Amount: <input type="number" id="withdraw-amount" min="0" step="0.0001"></label>
                    <p>Available: <span id="available-balance">0</span> <span id="currency"></span></p>
                    <p>Fee: <span id="withdraw-fee">0</span> <span id="fee-currency"></span></p>
                    <button id="confirm-withdraw">Confirm</button>
                    <button id="cancel-withdraw">Cancel</button>
                </div>
            </div>
        </section>

        <section id="game" class="section game-section">
            <div class="banner-placeholder">
                <img src="assets/icons/game-banner.png" alt="Game Banner">
            </div>
            <h2>Game List</h2>
            <div class="game-list">
                 <div class="game-item"><img src="https://via.placeholder.com/80/FF0000/FFFFFF?text=TG" alt="Traffic Go"><p>Traffic Go</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/00FF00/FFFFFF?text=CM" alt="Cutting Master"><p>Cutting Master</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/0000FF/FFFFFF?text=EM" alt="Element Magic"><p>Element Magic</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FFFF00/000000?text=JS" alt="Juicy Splash"><p>Juicy Splash</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FF00FF/FFFFFF?text=COR" alt="Creed of Rescue"><p>Creed of Rescue</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/00FFFF/000000?text=FJ" alt="Farm Jam"><p>Farm Jam</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FFA500/FFFFFF?text=2048" alt="2048 Blocks"><p>2048 Blocks</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/800080/FFFFFF?text=CRC" alt="Cut Rope Combo"><p>Cut Rope Combo</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/008000/FFFFFF?text=HJ" alt="Happy Jelly Jump"><p>Happy Jelly Jump</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/000080/FFFFFF?text=UTR" alt="Undersea Tunnel Race"><p>Undersea Tunnel Race</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FFC0CB/000000?text=MM" alt="Motor Master"><p>Motor Master</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FFD700/000000?text=OF" alt="Open Fire"><p>Open Fire</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/ADFF2F/000000?text=MTD" alt="Monster TD"><p>Monster TD</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FF4500/FFFFFF?text=BW" alt="Bloody Warrior"><p>Bloody Warrior</p></div>
            </div>
        </section>

        <section id="invite" class="section invite-section">
            <div class="invite-stats">
                <span id="my-invite">My Invite: 0</span>
                <div class="spin-info">
                    <span>Spin x0</span>
                    <span class="warning">!</span>
                </div>
            </div>
            <div class="action-buttons">
                <button class="action-button invite-friend">Invite Friend</button>
                <button class="action-button copy-link">Copy Link</button>
            </div>
            <div class="total-credit">
                <div class="credit-info">
                    <span id="total-credit-text">Total Credit <span class="warning">!</span> : 0</span> <small>10,000 = 1 <img src="assets/icons/usdt.png" alt="USDT"></small>
                </div>
                <button class="claim-button">Claim</button>
            </div>
            <div class="record-section">
                <h3>Claim Record</h3>
                 <div class="no-frens" id="claim-record-placeholder">
                     <img src="assets/icons/nofrens.png" alt="No Claims">
                     <p>No claim records yet</p>
                 </div>
                 <div id="claim-record-list"></div>
            </div>
            <div class="invite-record">
                <h3 id="invite-record-title">Invite Record (0)</h3>
                <div class="record-header">
                    <span>User</span>
                    <span>Join Time</span>
                    <span>Credit</span>
                </div>
                <div class="record-list" id="invite-record-list"> <div class="no-frens" id="invite-record-placeholder"> <img src="assets/icons/nofrens.png" alt="No Frens">
                        <p>No invites yet</p>
                    </div>
                     </div>
            </div>
        </section>

        <section id="chest" class="section chest-section">
             <h2>Chests</h2> <div class="chest-slider">
                <button class="nav-arrow left" onclick="prevChest()">&lt;</button>
                <div class="chest-container" id="chestContainer">
                    <div class="chest-item"> <div class="chest-title">
                             <h2>Loading...</h2>
                             <span>...</span>
                         </div>
                         <div class="chest-image"><img src="assets/icons/chest_placeholder.png" alt="Loading Chest"></div>
                     </div>
                 </div>
                <button class="nav-arrow right" onclick="nextChest()">&gt;</button>
            </div>
             <h3>Possible Rewards</h3> <div class="rewards">
                <div class="reward-item usdt"><img src="assets/icons/usdt.png" alt="USDT"><p>USDT</p></div>
                <div class="reward-item land-piece"><img src="assets/icons/land-piece.png" alt="Land Piece"><p>Land Piece</p></div>
                <div class="reward-item fox-medal"><img src="assets/icons/fox-medal.png" alt="Fox Medal"><p>Fox Medal</p></div>
            </div>
            <div class="cost" id="chestCost"> <img src="assets/icons/gem.png" alt="Gem">
                <span id="chest-cost-amount">...</span> </div>
            <div class="vip-requirement" id="chestVipRequirement" style="display: none;">
                NEED VIP X
            </div>
            <button class="open-chest-button" onclick="openChest()">Open Chest</button>
        </section>

        <section id="top" class="section top-section">
            <h2>Medal Ranking <span class="warning">!</span></h2>
            <ul class="ranking-list" id="ranking-list">
                <li class="no-rankings">
                    <p>Loading rankings...</p> </li>
            </ul>
        </section>
    </div>

    <nav class="bottom-nav">
        <button class="nav-button active" data-section="earn"> <img src="assets/icons/earn.png" alt="Earn">
            <span>Earn</span>
        </button>
        <button class="nav-button" data-section="wallet">
            <img src="assets/icons/wallet.png" alt="Wallet">
            <span>Wallet</span>
        </button>
        <button class="nav-button" data-section="game">
            <img src="assets/icons/game.png" alt="Game">
            <span>Game</span>
        </button>
        <button class="nav-button" data-section="invite">
            <img src="assets/icons/invite.png" alt="Invite">
            <span>Invite</span>
        </button>
        <button class="nav-button" data-section="chest">
            <img src="assets/icons/chest.png" alt="Chest">
            <span>Chest</span>
        </button>
        <button class="nav-button" data-section="top">
            <img src="assets/icons/top.png" alt="Top">
            <span>Top</span>
        </button>
    </nav>

    <div id="debugConsole"></div>
    <button id="toggleDebugButton" onclick="document.getElementById('debugConsole').style.display =
        document.getElementById('debugConsole').style.display === 'none' ? 'block' : 'none'">
        Debug
    </button>

    <script>
        console.log('[DEBUG] Script execution started.');

        // --- Global Variables ---
        let app, db, auth, storage, analytics;
        let firebaseInitialized = false;
        let telegramUser;
        let tonConnectUI = null;
        let currentChestIndex = 0; // Keep track of chest slider

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCUkEmFmJK2vr8k7M6JqYaxlcgBDf7WdJI", // WARNING: Exposing API key is insecure for production
            authDomain: "fourgo-cd98f.firebaseapp.com",
            projectId: "fourgo-cd98f",
            storageBucket: "fourgo-cd98f.firebasestorage.app",
            messagingSenderId: "511215742272",
            appId: "1:511215742272:web:04bd85a284919ae123dea5",
            measurementId: "G-DC7E6ECF2L"
        };

         // Chest Data (Consider fetching from Firestore later)
         const chests = [
             { name: "Wood Chest", next: "Bronze", image: "assets/graphics/wood-chest.png", gemCost: 200, vip: 0 },
             { name: "Bronze Chest", next: "Silver", image: "assets/graphics/bronze-chest.png", gemCost: 500, vip: 1 },
             { name: "Silver Chest", next: "Gold", image: "assets/graphics/silver-chest.png", gemCost: 1000, vip: 2 },
             { name: "Gold Chest", next: "Master", image: "assets/graphics/gold-chest.png", gemCost: 2000, vip: 3 },
             { name: "Master Chest", next: "Legendary", image: "assets/graphics/master-chest.png", gemCost: 5000, vip: 4 },
             { name: "Legendary Chest", next: "Mythic", image: "assets/graphics/legendary-chest.png", gemCost: 10000, vip: 5 },
             { name: "Mythic Chest", next: "", image: "assets/graphics/mythic-chest.png", gemCost: 20000, vip: 6 }
         ];


        // --- Utility Functions ---

        // Debug Logging Helper
        function debugLog(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[DEBUG] ${timestamp}: ${message}`, data !== null ? data : '');
            const debugConsole = document.getElementById('debugConsole');
            if (debugConsole) {
                const entry = document.createElement('div');
                entry.textContent = `${timestamp}: ${message}${data ? ` - ${JSON.stringify(data)}` : ''}`;
                debugConsole.appendChild(entry);
                // Auto-scroll to bottom
                debugConsole.scrollTop = debugConsole.scrollHeight;
            }
        }

        // Dynamically load a script and return a Promise
        function loadScript(src, retries = 3, delay = 1000) {
             debugLog(`Attempting to load script: ${src}`);
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const tryLoad = () => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.async = true;
                    script.onload = () => {
                        debugLog(`Script loaded successfully: ${src}`);
                        resolve();
                    };
                    script.onerror = () => {
                        attempts++;
                        if (attempts < retries) {
                            console.warn(`Failed to load script: ${src}. Retrying (${attempts}/${retries})...`);
                            setTimeout(tryLoad, delay);
                        } else {
                            const errorMsg = `Failed to load script after ${retries} attempts: ${src}`;
                            console.error(errorMsg);
                            debugLog(errorMsg); // Log to debug console too
                            reject(new Error(errorMsg));
                        }
                    };
                    document.head.appendChild(script);
                };
                tryLoad();
            });
        }

        // Validate Firebase Configuration
        function validateFirebaseConfig(config) {
            const requiredFields = ['apiKey', 'authDomain', 'projectId', 'storageBucket', 'messagingSenderId', 'appId'];
            for (const field of requiredFields) {
                if (!config[field]) {
                    throw new Error(`Firebase config is missing required field: ${field}`);
                }
            }
            debugLog("Firebase config validated successfully");
        }

        // --- Firebase Initialization ---
        async function initializeFirebase(maxRetries = 3) {
            debugLog("Initializing Firebase...");
            if (firebaseInitialized) {
                debugLog("Firebase already initialized.");
                return true;
            }
            if (window.firebase && window.firebase.apps && window.firebase.apps.length > 0) {
                 debugLog("Firebase detected in global scope, reusing existing instance.");
                 app = window.firebase.apps[0];
                 db = app.firestore();
                 auth = app.auth();
                 storage = app.storage();
                 try { analytics = app.analytics(); } catch (e) { console.warn("Analytics setup failed:", e.message); }
                 firebaseInitialized = true;
                 return true;
            }

            let attempts = 0;
            const scriptUrls = [
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-app-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-auth-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-storage-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-analytics-compat.js'
            ];

            while (attempts < maxRetries && !firebaseInitialized) {
                try {
                    debugLog(`Attempt ${attempts + 1}/${maxRetries} to initialize Firebase...`);
                    validateFirebaseConfig(firebaseConfig);

                    await Promise.all(scriptUrls.map(url => loadScript(url, 1))); // Try each script once per attempt
                    if (typeof firebase === 'undefined' || typeof firebase.initializeApp === 'undefined') {
                         throw new Error("Firebase SDK core not loaded correctly.");
                    }

                    // Check if already initialized within this attempt
                    if (firebase.apps.length === 0) {
                         app = firebase.initializeApp(firebaseConfig);
                         debugLog("Firebase app initialized.");
                    } else {
                         app = firebase.apps[0];
                         debugLog("Reusing existing Firebase app instance.");
                    }

                    db = firebase.firestore();
                    auth = firebase.auth();
                    storage = firebase.storage();
                    try { analytics = firebase.analytics(); } catch (e) { console.warn("Analytics setup failed:", e.message); }

                    // Test Firestore connection
                    await db.collection('internal_status').doc('init_test').set({
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        status: 'ok'
                    }, { merge: true });

                    firebaseInitialized = true;
                    debugLog("Firebase fully initialized and connected.");
                    return true;
                } catch (error) {
                    attempts++;
                    console.error(`Firebase initialization attempt ${attempts} failed:`, error);
                    debugLog(`Firebase init attempt ${attempts} failed: ${error.message}`);
                    if (attempts >= maxRetries) {
                        console.error("Max retries reached. Firebase initialization failed definitively.");
                        debugLog("Max retries reached. Firebase initialization failed definitively.");
                        alert("Error connecting to the database. Please restart the app."); // User feedback
                        return false;
                    }
                    await new Promise(resolve => setTimeout(resolve, 2000)); // Wait before retry
                }
            }
            return false;
        }

        // Helper to ensure Firebase is ready before running a callback
        async function ensureFirebaseReady(callback, callbackName = 'Unnamed Callback') {
             debugLog(`Ensuring Firebase is ready for: ${callbackName}`);
            if (!firebaseInitialized || !db) {
                debugLog("Firebase not ready, attempting initialization...");
                const success = await initializeFirebase();
                if (!success) {
                    console.error("Firebase initialization failed after retries. Cannot proceed.");
                    debugLog(`Firebase init failed, cannot execute ${callbackName}`);
                    alert("Database connection failed. Please try again later.");
                    return; // Stop execution if Firebase fails
                }
            }
             debugLog(`Firebase ready, executing: ${callbackName}`);
             try {
                 await callback();
                 debugLog(`Successfully executed: ${callbackName}`);
             } catch (error) {
                 console.error(`Error during ${callbackName}:`, error);
                 debugLog(`Error during ${callbackName}: ${error.message}`);
                 // Optionally show an error to the user
                 // alert(`An error occurred while loading data for ${callbackName}.`);
             }
         }


        // --- Telegram Web App Setup ---
        function initializeTelegram() {
             debugLog("Initializing Telegram Web App...");
            try {
                if (!window.Telegram || !window.Telegram.WebApp) {
                    throw new Error("Telegram WebApp script not loaded or available.");
                }
                window.Telegram.WebApp.ready();
                telegramUser = window.Telegram.WebApp.initDataUnsafe?.user; // Use optional chaining

                if (telegramUser) {
                    debugLog("Telegram user data found:", { id: telegramUser.id, username: telegramUser.username });
                    const profilePic = document.querySelector('.profile-pic img');
                    if (profilePic) {
                        // Use try-catch for fetching user profile photos as they might fail
                        try {
                            // Attempt to use photo_url if available
                           profilePic.src = telegramUser.photo_url || 'assets/icons/user-avatar.png';
                        } catch (imgError) {
                            console.warn("Failed to load Telegram profile picture:", imgError);
                            profilePic.src = 'assets/icons/user-avatar.png'; // Fallback
                        }
                    }
                    // document.querySelector('h1').innerText = `4Metas`; // Keep title static?
                } else {
                    console.warn("No Telegram user data available. Running in test mode.");
                    debugLog("No Telegram user data found. Using test user.");
                    // Define a fallback test user if needed for development outside Telegram
                    telegramUser = {
                        id: "test_user_" + Date.now(), // Unique test ID
                        username: "TestUser",
                        first_name: "Test",
                        photo_url: "https://via.placeholder.com/40/808080/000000?text=T"
                    };
                    const profilePic = document.querySelector('.profile-pic img');
                     if (profilePic) profilePic.src = telegramUser.photo_url;
                }
                debugLog("Telegram Web App initialized successfully.");
                return true;
            } catch (error) {
                console.error("Telegram Web App initialization failed:", error);
                debugLog(`Telegram Web App initialization failed: ${error.message}`);
                 // Define a fallback test user if Telegram fails catastrophically
                 telegramUser = {
                     id: "fallback_user_" + Date.now(),
                     username: "FallbackUser",
                     first_name: "Fallback",
                     photo_url: "https://via.placeholder.com/40/FF0000/FFFFFF?text=F" // Error indicator
                 };
                 const profilePic = document.querySelector('.profile-pic img');
                 if (profilePic) profilePic.src = telegramUser.photo_url;
                 alert("Could not initialize Telegram features. Using fallback mode.");
                return false;
            }
        }

        // --- Storage Abstraction (Firestore) ---
        const Storage = {
            getItem: async (key) => {
                 debugLog(`Storage: Getting item '${key}' for user ${telegramUser?.id}`);
                if (!firebaseInitialized || !db) {
                    console.error("Firestore not initialized. Cannot fetch item:", key);
                    debugLog(`Storage Error: Firestore not init for getItem '${key}'`);
                    return null;
                }
                if (!telegramUser || !telegramUser.id) {
                    console.error("User not identified. Cannot fetch item:", key);
                    debugLog(`Storage Error: User not identified for getItem '${key}'`);
                    return null;
                }
                try {
                    const docRef = db.collection('userData').doc(telegramUser.id.toString());
                    const doc = await docRef.get();
                    const value = doc.exists ? doc.data()[key] : null;
                     debugLog(`Storage: Got item '${key}', value:`, value);
                     return value;
                } catch (error) {
                    console.error(`Storage: Error fetching ${key}:`, error);
                    debugLog(`Storage Error: Failed fetching '${key}': ${error.message}`);
                    return null;
                }
            },
            setItem: async (key, value) => {
                 debugLog(`Storage: Setting item '${key}' for user ${telegramUser?.id}`, value);
                if (!firebaseInitialized || !db) {
                    console.error("Firestore not initialized. Cannot set item:", key);
                    debugLog(`Storage Error: Firestore not init for setItem '${key}'`);
                    return false;
                }
                 if (!telegramUser || !telegramUser.id) {
                    console.error("User not identified. Cannot set item:", key);
                     debugLog(`Storage Error: User not identified for setItem '${key}'`);
                     return false;
                 }
                try {
                    const docRef = db.collection('userData').doc(telegramUser.id.toString());
                    await docRef.set({ [key]: value }, { merge: true });
                     debugLog(`Storage: Set item '${key}' successfully.`);
                    return true;
                } catch (error) {
                    console.error(`Storage: Error setting ${key}:`, error);
                    debugLog(`Storage Error: Failed setting '${key}': ${error.message}`);
                    return false;
                }
            }
        };

        // --- Navigation Logic ---
        function setupNavigation() {
            debugLog('[NAV] Setting up navigation...');
            const sections = document.querySelectorAll('.section');
            const navButtons = document.querySelectorAll('nav.bottom-nav .nav-button');
            const bottomNav = document.querySelector('nav.bottom-nav');

            if (!bottomNav || sections.length === 0 || navButtons.length === 0) {
                console.error('[NAV ERROR] Required navigation elements not found!', {
                    bottomNavExists: !!bottomNav,
                    sectionsFound: sections.length,
                    navButtonsFound: navButtons.length
                });
                debugLog('[NAV ERROR] Required navigation elements not found!');
                alert("UI Error: Navigation could not be set up.");
                return; // Stop if essential elements are missing
            }

             debugLog(`[NAV] Found ${sections.length} sections and ${navButtons.length} nav buttons.`);

             // Ensure nav is visible (redundant with !important styles, but safe)
             bottomNav.style.display = 'flex';
             bottomNav.style.visibility = 'visible';
             bottomNav.style.opacity = '1';

            navButtons.forEach((button, index) => {
                const sectionId = button.getAttribute('data-section');
                 debugLog(`[NAV] Setting up listener for button ${index}: ${sectionId}`);
                 if (!sectionId) {
                     console.warn(`[NAV WARN] Button ${index} is missing data-section attribute.`);
                     debugLog(`[NAV WARN] Button ${index} is missing data-section attribute.`);
                     return; // Skip buttons without data-section
                 }

                button.addEventListener('click', () => {
                    debugLog(`[NAV] Click detected on button: ${sectionId}`);
                    switchSection(sectionId); // Switch section on click
                });

                 // Force visual styles again just in case (optional)
                 button.style.visibility = 'visible';
                 button.style.opacity = '1';
                 const img = button.querySelector('img');
                 if (img) img.onerror = () => { console.error(`[NAV ERROR] Image failed to load for button ${sectionId}: ${img.src}`); img.src='assets/icons/placeholder.png'; };
            });

            // Set default section
            const defaultSection = 'earn'; // Or read from localStorage/hash
            debugLog(`[NAV] Setting default section to: ${defaultSection}`);
            switchSection(defaultSection, true); // Pass true for initial load

            debugLog('[NAV] Navigation setup complete.');
        }

        async function switchSection(sectionId, isInitialLoad = false) {
             debugLog(`[NAV] Attempting to switch to section: ${sectionId}`);
            const sections = document.querySelectorAll('.section');
            const navButtons = document.querySelectorAll('nav.bottom-nav .nav-button');

            let foundSection = false;
            sections.forEach(section => {
                if (section.id === sectionId) {
                    if (!section.classList.contains('active')) {
                         section.classList.add('active');
                         debugLog(`[NAV] Activated section element: #${section.id}`);
                     } else {
                         debugLog(`[NAV] Section #${section.id} was already active.`);
                     }
                     foundSection = true;
                } else {
                    if (section.classList.contains('active')) {
                        section.classList.remove('active');
                         debugLog(`[NAV] Deactivated section element: #${section.id}`);
                     }
                }
            });

            if (!foundSection) {
                 console.error(`[NAV ERROR] Target section element with id "${sectionId}" not found in DOM.`);
                 debugLog(`[NAV ERROR] Target section element with id "${sectionId}" not found.`);
                 return; // Stop if section doesn't exist
            }

            let foundButton = false;
            navButtons.forEach(btn => {
                 const btnSectionId = btn.getAttribute('data-section');
                 if (btnSectionId === sectionId) {
                     if (!btn.classList.contains('active')) {
                         btn.classList.add('active');
                         debugLog(`[NAV] Activated button: [data-section="${btnSectionId}"]`);
                     }
                     foundButton = true;
                 } else {
                     if (btn.classList.contains('active')) {
                         btn.classList.remove('active');
                         debugLog(`[NAV] Deactivated button: [data-section="${btnSectionId}"]`);
                     }
                 }
             });

             if (!foundButton) {
                 console.warn(`[NAV WARN] Target button with data-section "${sectionId}" not found.`);
                 debugLog(`[NAV WARN] Target button with data-section "${sectionId}" not found.`);
             }

            // Load data for the activated section
             debugLog(`[NAV] Loading data for section: ${sectionId}`);
             try {
                 // Use ensureFirebaseReady to handle data loading for relevant sections
                 if (sectionId === 'earn') await ensureFirebaseReady(updateEarnSectionUI, 'updateEarnSectionUI');
                 else if (sectionId === 'invite') await ensureFirebaseReady(updateInviteSectionUI, 'updateInviteSectionUI');
                 else if (sectionId === 'top') await ensureFirebaseReady(updateTopSectionUI, 'updateTopSectionUI');
                 else if (sectionId === 'wallet') await ensureFirebaseReady(updateWalletSectionUI, 'updateWalletSectionUI');
                 else if (sectionId === 'chest') await ensureFirebaseReady(updateUserStatsUI, 'updateChestUserStats'); // Update stats before chest UI checks gems
                 // Add other section updates here if needed
                 else {
                    debugLog(`[NAV] No specific data load function for section: ${sectionId}`);
                 }

                 // Update Chest UI specifically after navigating to it or potentially after stats update
                 if (sectionId === 'chest') {
                     updateChestUI(); // Ensure chest UI reflects current stats/index
                 }

             } catch (error) {
                 console.error(`[NAV ERROR] Error loading data for section ${sectionId}:`, error);
                 debugLog(`[NAV ERROR] Error loading data for section ${sectionId}: ${error.message}`);
             }
         }

        // --- User Data Management ---
        async function initializeUserData() {
             debugLog("Initializing user data...");
            if (!telegramUser || !telegramUser.id) {
                 console.warn("Cannot initialize user data: No Telegram user available or no ID.");
                 debugLog("User init skipped: No Telegram user ID.");
                 return;
            }
            if (!firebaseInitialized || !db) {
                console.error("Firestore not initialized. Cannot initialize user data.");
                debugLog("User init skipped: Firestore not initialized.");
                return;
            }

            const userIdStr = telegramUser.id.toString();
            const userDocRef = db.collection('userData').doc(userIdStr);
            const rankingDocRef = db.collection('users').doc(userIdStr); // Assuming 'users' for ranking

            try {
                const doc = await userDocRef.get();
                if (!doc.exists) {
                    debugLog(`User ${userIdStr} not found in userData, creating new record.`);
                    const newUser = {
                        gems: 0,
                        usdt: 0,
                        ton: 0,
                        referrals: 0,
                        referralCredits: 0, // Track credits separately
                        inviteRecords: [],
                        claimHistory: [], // For credit claims
                        landPieces: 0,
                        foxMedals: 0,
                        vipLevel: 0, // Initialize VIP level
                        isReferred: false,
                        referredBy: null,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastLogin: firebase.firestore.FieldValue.serverTimestamp(),
                        claimedQuests: [], // Store IDs of claimed non-repeatable quests
                        adProgress: {}, // { questId: { watched: 0, claimed: false, lastClaimed: null } }
                        walletAddress: null,
                        transactions: [] // Consider subcollection instead later for scale
                    };
                    await userDocRef.set(newUser);

                    // Also create ranking entry
                    const rankingEntry = {
                        username: telegramUser.username || telegramUser.first_name || `User_${userIdStr.slice(-4)}`,
                        foxMedals: 0,
                        photoUrl: telegramUser.photo_url || 'assets/icons/user-avatar.png', // Use local asset as fallback
                        userId: userIdStr // Store ID for reference
                    };
                    await rankingDocRef.set(rankingEntry, { merge: true }); // Use merge just in case

                    debugLog("New user data initialized in userData and users collections.");
                     if (analytics) analytics.logEvent('user_signup', { userId: userIdStr });
                } else {
                    debugLog(`User ${userIdStr} found. Updating last login.`);
                    // Ensure essential fields exist if user doc was created before fields were added
                    const updates = {
                        lastLogin: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    const userData = doc.data();
                    if (userData.vipLevel === undefined) updates.vipLevel = 0;
                    if (userData.adProgress === undefined) updates.adProgress = {};
                    if (userData.claimedQuests === undefined) updates.claimedQuests = [];
                    // Add other checks as needed

                    await userDocRef.update(updates);

                     // Ensure ranking entry exists too
                     const rankDoc = await rankingDocRef.get();
                     if (!rankDoc.exists) {
                          const rankingEntry = {
                              username: telegramUser.username || telegramUser.first_name || `User_${userIdStr.slice(-4)}`,
                              foxMedals: userData.foxMedals || 0, // Sync medals
                              photoUrl: telegramUser.photo_url || 'assets/icons/user-avatar.png',
                              userId: userIdStr
                          };
                          await rankingDocRef.set(rankingEntry);
                          debugLog("Created missing ranking entry for existing user.");
                     } else {
                         // Optionally update username/photo in ranking if changed in Telegram
                         const rankData = rankDoc.data();
                         const currentPhoto = telegramUser.photo_url || 'assets/icons/user-avatar.png';
                         const currentUsername = telegramUser.username || telegramUser.first_name || `User_${userIdStr.slice(-4)}`;
                         if (rankData.photoUrl !== currentPhoto || rankData.username !== currentUsername) {
                              await rankingDocRef.update({
                                   photoUrl: currentPhoto,
                                   username: currentUsername
                              });
                              debugLog("Updated ranking entry username/photo.");
                         }
                     }
                }
                // Always update UI after initialization/check
                await updateUserStatsUI();
            } catch (error) {
                console.error("Error initializing/checking user data:", error);
                debugLog(`Error initializing user data for ${userIdStr}: ${error.message}`);
                alert("There was a problem loading your profile.");
            }
        }

        // Global variable to store fetched user data to reduce reads
        let currentUserData = null;

        async function fetchAndUpdateUserData() {
            // debugLog("Fetching and updating user data..."); // Can be noisy
            if (!telegramUser || !telegramUser.id || !firebaseInitialized || !db) {
                debugLog("User data fetch skipped: Conditions not met.");
                currentUserData = null; // Reset cache
                return null;
            }
            try {
                const userDocRef = db.collection('userData').doc(telegramUser.id.toString());
                const userDoc = await userDocRef.get();
                if (!userDoc.exists) {
                    debugLog("User doc not found during fetch.");
                    currentUserData = null; // Reset cache
                    // Optionally re-run initialization logic?
                    // await initializeUserData();
                    return null;
                }
                currentUserData = userDoc.data(); // Update cache
                // debugLog("User data fetched and cached.");
                return currentUserData;
            } catch (error) {
                console.error("Error fetching user data:", error);
                debugLog(`Error fetching user data: ${error.message}`);
                currentUserData = null; // Reset cache on error
                return null;
            }
        }


        async function updateUserStatsUI() {
             // debugLog("Updating user stats UI..."); // Can be noisy
             const data = currentUserData || await fetchAndUpdateUserData(); // Use cache or fetch

             if (!data) {
                  debugLog("Stats UI update skipped: No user data available.");
                  // Set UI to defaults or loading state
                  document.getElementById('gems').textContent = 0;
                  document.getElementById('usdt').textContent = '0.0000';
                  document.getElementById('ton').textContent = '0.0000';
                  document.getElementById('wallet-usdt').textContent = '0.0000';
                  document.getElementById('wallet-ton').textContent = '0.0000';
                  return;
             }

            try {
                document.getElementById('gems').textContent = data.gems?.toLocaleString() || 0;
                document.getElementById('usdt').textContent = (data.usdt || 0).toFixed(4);
                document.getElementById('ton').textContent = (data.ton || 0).toFixed(4);

                // Update wallet section balances as well
                document.getElementById('wallet-usdt').textContent = (data.usdt || 0).toFixed(4);
                document.getElementById('wallet-ton').textContent = (data.ton || 0).toFixed(4);

                // debugLog("User stats UI updated successfully."); // Can be noisy
            } catch (error) {
                console.error("Error updating user stats UI:", error);
                debugLog(`Error updating stats UI: ${error.message}`);
            }
        }

        // --- Earn Section (Quests) ---
        async function updateEarnSectionUI() {
             debugLog("[QUEST DEBUG] Starting Earn section UI update...");
            const dailyQuestList = document.getElementById('daily-quest-list');
            const basicQuestList = document.getElementById('basic-quest-list');
            const dailyQuestCountEl = document.getElementById('daily-quest-count');
            const basicQuestCountEl = document.getElementById('basic-quest-count');

             if (!dailyQuestList || !basicQuestList || !dailyQuestCountEl || !basicQuestCountEl) {
                 console.error("[QUEST ERROR] Required DOM elements for quests not found!");
                 debugLog("[QUEST ERROR] Quest list or count elements missing from DOM.");
                 return;
             }

             // Set initial loading state
             dailyQuestList.innerHTML = `<li class="loading"><p>Loading daily quests...</p></li>`;
             basicQuestList.innerHTML = `<li class="loading"><p>Loading basic quests...</p></li>`;
             dailyQuestCountEl.textContent = '-';
             basicQuestCountEl.textContent = '-';

            try {
                 if (!firebaseInitialized || !db) {
                    throw new Error("Firestore not initialized for updating Earn section.");
                 }
                 // Use cached or fetch fresh user data
                 let userData = currentUserData || await fetchAndUpdateUserData();

                 if (!userData) {
                      throw new Error("User data not available for quest checks.");
                 }
                 // Ensure sub-objects exist
                 userData.adProgress = userData.adProgress || {};
                 userData.claimedQuests = userData.claimedQuests || [];
                 debugLog("[QUEST DEBUG] User data loaded for quest checks.");


                 // --- Fetch Daily Quests ---
                 debugLog("[QUEST DEBUG] Fetching daily quests...");
                 const dailyQuestsSnapshot = await db.collection('quests').doc('daily').get({ source: 'server' });
                 const dailyQuestsRaw = dailyQuestsSnapshot.exists ? dailyQuestsSnapshot.data() : {};
                 const dailyQuests = dailyQuestsRaw.tasks || [];
                 // debugLog("[QUEST DEBUG] Raw Daily Quests Data:", dailyQuests); // Can be verbose

                 dailyQuestCountEl.textContent = dailyQuests.length;
                 if (dailyQuests.length === 0) {
                     dailyQuestList.innerHTML = `<li class="no-quests"><p>No daily quests available today.</p></li>`;
                 } else {
                     dailyQuestList.innerHTML = dailyQuests.map(quest => {
                         const isClaimed = userData.claimedQuests.includes(quest.id); // Check non-repeatable claims
                         const buttonText = isClaimed ? 'Claimed' : (quest.action || 'GO');
                         const buttonClass = isClaimed ? 'claimed-button' : 'go-button'; // Daily quests likely use GO
                         const buttonDisabled = isClaimed;
                         return `
                             <li class="quest-item" data-quest-id="${quest.id}" data-quest-type="daily">
                                 <img src="${quest.icon || 'assets/icons/quest_placeholder.png'}" alt="${quest.title || 'Quest'}" onerror="this.src='assets/icons/quest_placeholder.png'">
                                 <span>${quest.title || 'Untitled Quest'}</span>
                                 <div class="quest-reward">
                                     <img src="assets/icons/gem.png" alt="Gem">
                                     <span>+${Number(quest.reward) || 0}</span>
                                     <button class="${buttonClass}"
                                             data-quest-link="${quest.link || ''}"
                                             data-quest-reward="${Number(quest.reward) || 0}"
                                             ${buttonDisabled ? 'disabled' : ''}>
                                         ${buttonText}
                                     </button>
                                 </div>
                             </li>
                         `;
                     }).join('');
                 }
                 debugLog("[QUEST DEBUG] Daily quests rendered.");


                 // --- Fetch Basic Quests ---
                 debugLog("[QUEST DEBUG] Fetching basic quests...");
                 const basicQuestsSnapshot = await db.collection('quests').doc('basic').get({ source: 'server' });
                 const basicQuestsRaw = basicQuestsSnapshot.exists ? basicQuestsSnapshot.data() : {};

                 // ***** Log raw data before processing *****
                 debugLog("[QUEST DEBUG] Raw Basic Quests Data from Firestore:", basicQuestsRaw);
                 if (Array.isArray(basicQuestsRaw.tasks)) {
                     const specificQuest = basicQuestsRaw.tasks.find(q => q.id === 'full_ad'); // Example check
                     debugLog("[QUEST DEBUG] Data for 'full_ad' quest object (if found):", specificQuest);
                     if (specificQuest) {
                         debugLog("[QUEST DEBUG] Value and type of adLimit for 'full_ad':", specificQuest.adLimit, typeof specificQuest.adLimit);
                     }
                 } else {
                     debugLog("[QUEST DEBUG] 'tasks' field not found or is not an array in quests/basic document.");
                 }
                 // ***** End log *****

                 // Ensure adProgress structure is initialized for all ad quests if not present
                 let adProgressUpdateNeeded = false;
                 const adProgressUpdate = {};
                 (basicQuestsRaw.tasks || []).forEach(quest => { // Use raw data here
                    if (quest.type === 'ads' && quest.id && !userData.adProgress[quest.id]) { // Check quest.id exists
                        userData.adProgress[quest.id] = { watched: 0, claimed: false, lastClaimed: null };
                        adProgressUpdate[`adProgress.${quest.id}`] = userData.adProgress[quest.id];
                        adProgressUpdateNeeded = true;
                        debugLog(`[QUEST DEBUG] Initializing adProgress for new quest: ${quest.id}`);
                    }
                 });
                 if (adProgressUpdateNeeded) {
                    await db.collection('userData').doc(telegramUser.id.toString()).update(adProgressUpdate);
                    debugLog("[QUEST DEBUG] Updated user data with initial adProgress structures.");
                    // Re-fetch user data or merge update locally if needed immediately
                    userData = currentUserData || await fetchAndUpdateUserData(); // Refresh data after update
                    if (!userData) throw new Error("User data unavailable after adProgress init.");
                 }


                 const basicQuests = basicQuestsRaw.tasks || []; // Assign after checks

                 basicQuestCountEl.textContent = basicQuests.length;
                 if (basicQuests.length === 0) {
                     basicQuestList.innerHTML = `<li class="no-quests"><p>No basic quests available right now.</p></li>`;
                 } else {
                     const currentTime = new Date(); // Get current time once for cooldown checks
                     const cooldownPeriod = 3600 * 1000; // 1 hour cooldown in milliseconds

                      // Inside updateEarnSectionUI, before mapping basic quests
                      if (userData && userData.adProgress) {
                          debugLog("[QUEST DEBUG] Data used for rendering basic quests:", JSON.stringify(userData.adProgress));
                      }

                     basicQuestList.innerHTML = basicQuests.map(quest => {
                         // Ensure quest object and id are valid before proceeding
                         if (!quest || !quest.id) {
                            console.warn("[QUEST WARN] Skipping rendering of invalid quest object:", quest);
                            return ''; // Return empty string to skip rendering this item
                         }

                         const questId = quest.id; // Already checked it exists
                         const questType = quest.type || 'default';
                         const questTitle = quest.title || 'Untitled Quest';
                         const questIcon = quest.icon || 'assets/icons/quest_placeholder.png';
                         const questReward = Number(quest.reward) || 0;
                         const questAction = quest.action || 'GO';
                         const questLink = quest.link || '';
                         // Ensure adLimit is read correctly (check for trailing spaces if issue persists)
                         const adLimit = questType === 'ads' ? Math.max(1, Number(quest.adLimit) || 1) : 0;
                         const adType = quest.adType || 'rewarded_interstitial'; // Default if not specified

                         // Skip rendering quests meant for automatic ads if necessary
                         // if (adType === 'inApp') {
                         //     debugLog(`[QUEST DEBUG] Skipping rendering of manual quest for automatic adType 'inApp': ${questId}`);
                         //     return ''; // Don't render this quest item
                         // }

                         // Detailed log for each quest being processed
                         debugLog(`[QUEST DEBUG] Processing Basic Quest: ${questTitle}`, {
                             id: questId, type: questType, rawAdLimit: quest.adLimit, calculatedAdLimit: adLimit, reward: questReward, adType: adType
                         });

                         let buttonText = questAction;
                         let buttonClass = 'go-button';
                         let buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);'; // Default GO style
                         let buttonDisabled = false;
                         let progressText = '';

                         if (questType === 'ads') {
                             // Use the potentially updated userData from the start of the function
                             const adProgress = userData.adProgress[questId] || { watched: 0, claimed: false, lastClaimed: null };
                             progressText = `<span class="progress">${adProgress.watched}/${adLimit}</span>`;
                             const isCompleted = adProgress.watched >= adLimit;
                             const isClaimed = adProgress.claimed;
                             const lastClaimedTime = adProgress.lastClaimed ? new Date(adProgress.lastClaimed) : null;
                             const timeSinceLastClaim = lastClaimedTime ? currentTime - lastClaimedTime : Infinity;
                             let isCooldownOver = timeSinceLastClaim >= cooldownPeriod;

                             // Cooldown Reset Logic
                             if (isClaimed && isCooldownOver) {
                                 debugLog(`[QUEST DEBUG] Cooldown over for ad quest ${questId}. Resetting progress.`);
                                 // Prepare local state for immediate rendering update
                                 adProgress.watched = 0;
                                 adProgress.claimed = false;
                                 adProgress.lastClaimed = null;
                                 // Asynchronously update Firestore (don't necessarily need to wait here for UI rendering)
                                 db.collection('userData').doc(telegramUser.id.toString()).update({
                                     [`adProgress.${questId}`]: { watched: 0, claimed: false, lastClaimed: null }
                                 }).then(() => {
                                     debugLog(`[QUEST DEBUG] Firestore updated asynchronously for ${questId} reset.`);
                                     // Optionally refresh user data cache if needed elsewhere: fetchAndUpdateUserData();
                                 }).catch(err => {
                                     console.error(`[QUEST ERROR] Failed async Firestore reset for ${questId}:`, err);
                                     debugLog(`[QUEST ERROR] Failed async Firestore reset for ${questId}: ${err.message}`);
                                 });
                                 // Update local state immediately for correct button rendering THIS RENDER CYCLE
                                 isCooldownOver = true; // Ensure subsequent checks use the reset state
                                 // Update the main userData cache if necessary (might be redundant if fetched fresh at start)
                                 if(currentUserData?.adProgress?.[questId]) {
                                     currentUserData.adProgress[questId] = { watched: 0, claimed: false, lastClaimed: null };
                                 }
                             }

                             // Button State Logic (using potentially reset adProgress)
                             if (adProgress.claimed && !isCooldownOver) {
                                 const timeLeftMinutes = Math.ceil((cooldownPeriod - timeSinceLastClaim) / 60000);
                                 buttonText = `Wait ${timeLeftMinutes}m`;
                                 buttonClass = 'claimed-button';
                                 buttonStyle = 'background: #ccc; cursor: default;';
                                 buttonDisabled = true;
                             } else if (isCompleted && !adProgress.claimed) {
                                 buttonText = 'Claim';
                                 buttonClass = 'claim-button active';
                                 buttonStyle = 'background: linear-gradient(to right, #00ff00, #66ff66);';
                                 buttonDisabled = false;
                             } else { // Not completed or reset
                                 buttonText = questAction;
                                 buttonClass = 'go-button';
                                 buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);';
                                 buttonDisabled = false;
                             }
                         } else { // Default quest type (e.g., visit link)
                             const isClaimed = userData.claimedQuests.includes(questId);
                             if (isClaimed) {
                                 buttonText = 'Claimed';
                                 buttonClass = 'claimed-button';
                                 buttonStyle = 'background: #ccc; cursor: default;';
                                 buttonDisabled = true;
                             }
                         }

                         return `
                             <li class="quest-item" data-quest-id="${questId}" data-quest-type="${questType}" data-ad-limit="${adLimit}" data-ad-type="${adType}">
                                 <img src="${questIcon}" alt="${questTitle}" onerror="this.src='assets/icons/quest_placeholder.png'">
                                 <span>${questTitle}</span>
                                 <div class="quest-reward">
                                     <img src="assets/icons/gem.png" alt="Gem">
                                     <span>+${questReward}</span>
                                     ${progressText}
                                     <button class="${buttonClass}"
                                             data-quest-link="${questLink}"
                                             data-quest-reward="${questReward}"
                                             style="${buttonStyle}"
                                             ${buttonDisabled ? 'disabled' : ''}>
                                         ${buttonText}
                                     </button>
                                 </div>
                             </li>
                         `;
                     }).join('');
                 }
                 debugLog("[QUEST DEBUG] Basic quests rendered.");

            } catch (error) {
                console.error("[QUEST ERROR] Failed to update Earn section UI:", error);
                debugLog(`[QUEST ERROR] Failed to update Earn section UI: ${error.message}\n${error.stack}`);
                 // Display error messages in the UI
                dailyQuestList.innerHTML = `<li class="error"><p>Failed to load daily quests. Please try again later.</p></li>`;
                basicQuestList.innerHTML = `<li class="error"><p>Failed to load basic quests. Please try again later.</p></li>`;
                dailyQuestCountEl.textContent = 'ERR';
                basicQuestCountEl.textContent = 'ERR';
            }
        }

        // --- Quest Interaction Logic ---
         document.addEventListener('click', async (event) => {
             const button = event.target.closest('.quest-reward button');
             if (!button) return;
             const taskItem = button.closest('.quest-item');
             if (!taskItem) return;

             const questId = taskItem.dataset.questId;
             const questType = taskItem.dataset.questType;
             const reward = parseInt(button.dataset.questReward || '0');
             const link = button.dataset.questLink || '';
             const adLimit = parseInt(taskItem.dataset.adLimit || '0');
             const adType = taskItem.dataset.adType || 'rewarded_interstitial'; // Get adType for showAd

             debugLog(`[QUEST ACTION] Button clicked for quest: ${questId}`, { type: questType, reward, link: link || 'N/A', adLimit, adType });

             if (!firebaseInitialized || !db) { /* ... error handling ... */ return; }
             if (!telegramUser || !telegramUser.id) { /* ... error handling ... */ return; }

             const userDocRef = db.collection('userData').doc(telegramUser.id.toString());
             let userData = currentUserData || await fetchAndUpdateUserData(); // Use cache or fetch
             if (!userData) { /* ... error handling ... */ return; }
             // Ensure sub-objects exist
             userData.adProgress = userData.adProgress || {};
             userData.claimedQuests = userData.claimedQuests || [];


             // --- Handle CLAIM button clicks (specifically for completed ad quests) ---
             if (button.classList.contains('claim-button') && questType === 'ads') {
                 debugLog(`[QUEST ACTION] Handling CLAIM for ad quest: ${questId}`);
                 const adProgress = userData.adProgress[questId] || { watched: 0, claimed: false, lastClaimed: null };

                 if (adProgress.watched < adLimit) { /* ... error handling ... */ return; }
                 if (adProgress.claimed) { /* ... error handling ... */ return; }

                 button.disabled = true; button.textContent = 'Claiming...';
                 try {
                     const currentTimeISO = new Date().toISOString();
                     await userDocRef.update({
                         gems: firebase.firestore.FieldValue.increment(reward),
                         [`adProgress.${questId}`]: { watched: adProgress.watched, claimed: true, lastClaimed: currentTimeISO }
                     });
                     debugLog(`[QUEST ACTION] Ad quest ${questId} claimed successfully. Awarded ${reward} gems.`);
                     if (analytics) analytics.logEvent('ads_quest_claimed', { userId: telegramUser.id, questId, reward });
                     alert(`Reward claimed! You earned ${reward} gems.`);
                     await fetchAndUpdateUserData(); // Refresh user data cache
                     await updateUserStatsUI();
                     await updateEarnSectionUI();
                 } catch (error) {
                      console.error("[QUEST ERROR] Error claiming ad reward:", error);
                      debugLog(`[QUEST ERROR] Error claiming ad reward for ${questId}: ${error.message}`);
                      alert("Failed to claim reward. Please try again.");
                      button.disabled = false; button.textContent = 'Claim'; // Re-enable on failure
                 }
             }
             // --- Handle GO button clicks ---
             else if (button.classList.contains('go-button')) {
                 debugLog(`[QUEST ACTION] Handling GO for quest: ${questId}`);

                 // --- GO for Ad Quests (Manual Trigger) ---
                 if (questType === 'ads') {
                     const initialAdProgressCheck = userData.adProgress[questId] || { watched: 0, claimed: false, lastClaimed: null }; // Check before showing ad
                     if (initialAdProgressCheck.watched >= adLimit) {
                         debugLog(`[QUEST ACTION] Ad quest ${questId} already completed (${initialAdProgressCheck.watched}/${adLimit}). Ignoring GO click.`);
                         alert("You have already watched the required ads for this quest.");
                         return;
                      }
                     if (initialAdProgressCheck.claimed) {
                         debugLog(`[QUEST ACTION] Ad quest ${questId} already claimed. Ignoring GO click.`);
                         // Maybe check cooldown here too if needed? Button state should handle it though.
                         return;
                     }

                     // Check if the adType is 'inApp' - if so, it shouldn't be triggered manually now
                     if (adType === 'inApp') {
                         debugLog("[QUEST ACTION] Manual trigger attempted for 'inApp' ad type. This type is now automatic.");
                         alert("This ad type is handled automatically elsewhere.");
                         return; // Prevent manual trigger
                     }


                     debugLog(`[QUEST ACTION] Attempting to show ad (${adType}) for quest: ${questId}`);
                     button.disabled = true; button.textContent = 'Loading Ad...';

                     try {
                         await showAd(adType); // Show the ad (this now rejects 'inApp')
                         debugLog(`[QUEST ACTION] Ad shown successfully (or closed) for quest: ${questId}`);

                         // --- IMPORTANT: Re-fetch user data BEFORE update to get current state ---
                         // This ensures we increment correctly if multiple rapid clicks happened (though unlikely now button is disabled)
                         const userDataBeforeUpdate = await fetchAndUpdateUserData();
                         if (!userDataBeforeUpdate) throw new Error("User data disappeared after ad.");
                         // Use the LATEST known progress before applying the increment
                         const currentAdProgress = userDataBeforeUpdate.adProgress?.[questId] || { watched: 0, claimed: false, lastClaimed: null };
                         // ---

                         const newWatchedCount = currentAdProgress.watched + 1;
                         // --- Update Firestore ---
                         await userDocRef.update({
                             [`adProgress.${questId}`]: {
                                 watched: newWatchedCount,
                                 claimed: currentAdProgress.claimed, // Keep existing claimed status
                                 lastClaimed: currentAdProgress.lastClaimed // Keep existing lastClaimed status
                             }
                         });
                         debugLog(`[QUEST ACTION] Ad progress updated in Firestore for ${questId}: ${newWatchedCount}/${adLimit}`);

                         // *** === THIS IS THE FIX === ***
                         // Explicitly refresh the local cache AFTER the successful update
                         await fetchAndUpdateUserData();
                         debugLog(`[QUEST ACTION] Refreshed local user data cache after update.`);
                         // *** ======================== ***

                         if (analytics) analytics.logEvent('ads_quest_watch', { userId: telegramUser.id, questId, adType });

                         // Show alert based on the new count
                         if (newWatchedCount >= adLimit) {
                             alert(`Ad watched! (${newWatchedCount}/${adLimit}) You can now claim your reward.`);
                         } else {
                             alert(`Ad watched! Progress: ${newWatchedCount}/${adLimit}`);
                         }

                         // --- Update UI (Now uses the refreshed cache) ---
                         await updateEarnSectionUI();

                     } catch (error) {
                         console.error("[QUEST ERROR] Failed to show ad or update progress:", error);
                         debugLog(`[QUEST ERROR] Failed showing ad/updating progress for ${questId}: ${error.message}`);
                         alert(`Failed to show ad. ${error.message}`); // Show error message to user
                         // Refresh UI to reset button state if ad failed
                         await updateEarnSectionUI();
                     }
                     // No finally block needed as updateEarnSectionUI is called in both try and catch
                 }
                 // --- GO for Daily/Default Link Quests ---
                 else {
                     if (userData.claimedQuests.includes(questId)) { /* ... alert user ... */ return; }
                     if (!link) { /* ... alert user ... */ return; }

                     debugLog(`[QUEST ACTION] Opening link for quest ${questId}: ${link}`);
                     button.disabled = true; button.textContent = 'Claiming...';
                     try {
                         await userDocRef.update({
                             gems: firebase.firestore.FieldValue.increment(reward),
                             claimedQuests: firebase.firestore.FieldValue.arrayUnion(questId)
                         });
                         debugLog(`[QUEST ACTION] Default quest ${questId} marked complete. Awarded ${reward} gems.`);
                         if (analytics) analytics.logEvent('quest_completed', { userId: telegramUser.id, questId, reward });

                         if (window.Telegram && window.Telegram.WebApp) {
                            window.Telegram.WebApp.openTelegramLink(link);
                         } else {
                            window.open(link, '_blank');
                            debugLog("[QUEST ACTION WARN] Not in Telegram context, opening link in new tab.");
                         }

                         alert(`Quest completed! You earned ${reward} gems.`);
                         await fetchAndUpdateUserData(); // Refresh cache
                         await updateUserStatsUI();
                         await updateEarnSectionUI();

                     } catch (error) {
                         console.error("[QUEST ERROR] Error completing default quest:", error);
                         debugLog(`[QUEST ERROR] Error completing default quest ${questId}: ${error.message}`);
                         alert("Failed to complete quest. Please try again.");
                         button.disabled = false; button.textContent = 'GO'; // Re-enable on failure
                     }
                 }
             }
             // Ignore clicks on 'Claimed' or disabled buttons silently
             else if (button.classList.contains('claimed-button') || button.disabled) {
                 debugLog(`[QUEST ACTION] Click ignored on disabled/claimed button for quest: ${questId}`);
             }
         });


        // --- Ad Logic ---
        // Updated showAd function to reject manual 'inApp' triggers
        function showAd(adType) {
            debugLog(`[AD] Attempting to show ad of type: ${adType} via manual trigger.`);
            return new Promise((resolve, reject) => {

                // --- REJECT MANUAL 'inApp' TRIGGERS ---
                // Automatic 'inApp' ads are initialized in initApp now.
                if (adType === 'inApp') {
                    const errorMsg = "In-App ads are shown automatically, not via manual quest trigger.";
                    debugLog(`[AD WARN] ${errorMsg}`);
                    return reject(new Error(errorMsg));
                }
                // --- END REJECTION ---

                const maxWaitTime = 20000; // Increased timeout slightly

                // Check if SDK function exists
                if (typeof window.show_9180370 !== 'function') {
                    console.warn("[AD WARN] Monetag SDK function 'show_9180370' not found. Simulating ad success after delay.");
                    debugLog("[AD WARN] Monetag SDK function not found. Simulating success.");
                    setTimeout(() => {
                        debugLog("[AD] Simulated ad finished.");
                        resolve(); // Simulate success
                    }, 3000);
                    return;
                }

                let adPromise = null;
                let adTriggered = false;
                let requiresPromiseHandling = false;

                // Cleanup function
                const cleanup = (success, error = null) => {
                    clearTimeout(timeoutId);
                    if (success) {
                        resolve();
                    } else {
                        reject(error || new Error(`Ad failed or was closed early (${adType})`));
                    }
                };

                // Timeout Logic
                const timeoutId = setTimeout(() => {
                    console.warn(`[AD WARN] Ad timed out after ${maxWaitTime / 1000}s (${adType}). Rejecting.`);
                    debugLog(`[AD WARN] Ad timed out: ${adType}`);
                    cleanup(false, new Error(`Ad timed out or failed to close (${adType})`));
                }, maxWaitTime);

                try {
                    debugLog(`[AD] Calling Monetag SDK for ad type: ${adType}`);

                    // --- Trigger Ad Based on Type (excluding 'inApp') ---
                    if (adType === 'rewarded_popup') {
                        adPromise = window.show_9180370('pop');
                        adTriggered = true;
                        requiresPromiseHandling = true;
                    } else if (adType === 'rewarded_interstitial') {
                        adPromise = window.show_9180370();
                        adTriggered = true;
                        requiresPromiseHandling = true;
                    }
                    // Note: 'inApp' case is handled by the rejection at the start of the function.
                    else {
                        // Handle unknown or default ad type for manual triggers
                        console.warn(`[AD WARN] Unsupported or default adType: ${adType} for manual trigger. Falling back to standard interstitial.`);
                        adPromise = window.show_9180370(); // Fallback
                        adTriggered = true;
                        requiresPromiseHandling = true;
                    }

                    // --- Handle Promise (if applicable) ---
                    if (requiresPromiseHandling && adPromise && typeof adPromise.then === 'function') {
                        debugLog(`[AD] SDK returned a Promise for type ${adType}. Waiting for resolution...`);
                        adPromise.then(() => {
                            debugLog(`[AD] SDK Promise resolved successfully for type: ${adType}. Ad likely watched/closed.`);
                            cleanup(true); // Resolve the outer promise on success
                        }).catch(e => {
                            console.error(`[AD ERROR] SDK Promise rejected for type ${adType}:`, e);
                            debugLog(`[AD ERROR] SDK Promise rejected for ${adType}: ${e?.message || e}`);
                            cleanup(false, new Error(`Ad failed or was closed early (${adType})`)); // Reject the outer promise on failure
                        });
                    } else if (adTriggered) {
                         // Safety net if adPromise wasn't a promise but was expected to be
                         console.warn(`[AD WARN] SDK call for ${adType} was triggered but did not return a standard promise. Relying on timeout.`);
                    }

                } catch (error) {
                    // Catch immediate errors from calling show_9180370 itself
                    console.error("[AD ERROR] Failed to trigger Monetag ad:", error);
                    debugLog(`[AD ERROR] Failed to trigger ad ${adType}: ${error.message}`);
                    cleanup(false, error); // Reject the outer promise if the call fails immediately
                }
            });
        }


        // --- Referral System ---
        function generateReferralLink() {
             debugLog("Generating referral link...");
            if (!telegramUser || !telegramUser.id) {
                 debugLog("Referral link generation skipped: No user ID.");
                 return;
            }
            // Replace with your actual bot username
            const botUsername = 'fourgobot'; // !!! REPLACE with your bot's username !!!
            const referralLink = `https://t.me/${botUsername}?start=ref_${telegramUser.id}`;

            const inviteButton = document.querySelector('.invite-friend');
            const copyButton = document.querySelector('.copy-link');

            if (inviteButton) inviteButton.setAttribute('data-link', referralLink);
            if (copyButton) copyButton.setAttribute('data-link', referralLink);

            debugLog("Referral link generated:", referralLink);
        }

        async function handleReferral() {
             debugLog("Checking for referral parameter...");
             if (!telegramUser || !telegramUser.id) { /* ... */ return; }
             if (!firebaseInitialized || !db) { /* ... */ return; }

             let startParam = null;
             try {
                 startParam = window.Telegram?.WebApp?.initDataUnsafe?.start_param;
             } catch (e) { /* ... error handling ... */ return; }


             if (startParam && startParam.startsWith('ref_')) {
                 const referrerId = startParam.split('_')[1];
                 debugLog(`Referral parameter found: ref_${referrerId}`);

                 if (!referrerId || referrerId === telegramUser.id.toString()) { /* ... */ return; }

                 const currentUserRef = db.collection('userData').doc(telegramUser.id.toString());
                 const referrerRef = db.collection('userData').doc(referrerId);

                 try {
                     const userDoc = await currentUserRef.get();
                     if (!userDoc.exists) { /* ... */ return; }
                     const userData = userDoc.data();

                     if (userData.isReferred) { /* ... */ return; }

                     debugLog(`Processing referral: User ${telegramUser.id} referred by ${referrerId}`);
                     await currentUserRef.update({ isReferred: true, referredBy: referrerId });

                     const referrerDoc = await referrerRef.get();
                     if (referrerDoc.exists) {
                         const referralCreditAmount = 10; // Credits per referral
                         const referralGemAmount = 50;   // Gems per referral (Currently unused)

                         const newRecord = {
                             userId: telegramUser.id.toString(),
                             username: telegramUser.username || telegramUser.first_name || `User_${telegramUser.id.toString().slice(-4)}`,
                             joinTime: new Date().toISOString(),
                             creditAwarded: referralCreditAmount,
                         };

                         await referrerRef.update({
                             referrals: firebase.firestore.FieldValue.increment(1),
                             referralCredits: firebase.firestore.FieldValue.increment(referralCreditAmount),
                             inviteRecords: firebase.firestore.FieldValue.arrayUnion(newRecord)
                         });
                         debugLog(`Updated referrer ${referrerId} data: +1 referral, +${referralCreditAmount} credits.`);
                     } else {
                         debugLog(`Referral handling warning: Referrer ${referrerId} document not found.`);
                     }

                     if (analytics) analytics.logEvent('referral_success', { userId: telegramUser.id, referrerId });
                     debugLog("Referral handled successfully.");

                 } catch (error) {
                     console.error("Error processing referral:", error);
                     debugLog(`Error processing referral: ${error.message}`);
                 }
             } else {
                 debugLog("No referral parameter found or not in 'ref_' format.");
             }
         }

        // --- Invite Section UI & Logic ---
        async function updateInviteSectionUI() {
            debugLog("Updating Invite section UI...");
             const myInviteEl = document.getElementById('my-invite');
             const totalCreditEl = document.getElementById('total-credit-text');
             const inviteRecordTitleEl = document.getElementById('invite-record-title');
             const recordListContainer = document.getElementById('invite-record-list');
             const invitePlaceholder = document.getElementById('invite-record-placeholder');
             const claimRecordListContainer = document.getElementById('claim-record-list');
             const claimPlaceholder = document.getElementById('claim-record-placeholder');

             if (!myInviteEl || !totalCreditEl || !inviteRecordTitleEl || !recordListContainer || !invitePlaceholder || !claimRecordListContainer || !claimPlaceholder) { /* ... error handling ... */ return; }

             // Set loading state
             myInviteEl.textContent = `My Invite: ...`;
             totalCreditEl.innerHTML = `Total Credit <span class="warning">!</span> : ...`; // Use innerHTML if including spans
             inviteRecordTitleEl.textContent = `Invite Record (...)`;
             recordListContainer.innerHTML = '';
             invitePlaceholder.style.display = 'block';
             invitePlaceholder.querySelector('p').textContent = 'Loading invites...';
             claimRecordListContainer.innerHTML = '';
             claimPlaceholder.style.display = 'block';
             claimPlaceholder.querySelector('p').textContent = 'Loading claim history...';


             if (!telegramUser || !telegramUser.id) { /* ... handle no user ... */ return; }

             try {
                 // Use cached or fetch fresh user data
                 const data = currentUserData || await fetchAndUpdateUserData();
                 if (!data) {
                     debugLog("Invite UI update: User data not found.");
                     // Show appropriate message
                     myInviteEl.textContent = `My Invite: 0`;
                     totalCreditEl.innerHTML = `Total Credit <span class="warning">!</span> : 0`;
                     inviteRecordTitleEl.textContent = `Invite Record (0)`;
                     invitePlaceholder.querySelector('p').textContent = 'No invites yet';
                     claimPlaceholder.querySelector('p').textContent = 'No claim records yet';
                     return;
                 }

                 const referrals = data.referrals || 0;
                 const totalCredit = data.referralCredits || 0;
                 const inviteRecords = data.inviteRecords || [];
                 const claimHistory = data.claimHistory || [];

                 // Update stats
                 myInviteEl.textContent = `My Invite: ${referrals}`;
                 totalCreditEl.innerHTML = `Total Credit <span class="warning">!</span> : ${totalCredit.toLocaleString()}`;
                 inviteRecordTitleEl.textContent = `Invite Record (${referrals})`;

                 // Populate Invite Records
                 if (inviteRecords.length === 0) {
                     recordListContainer.innerHTML = '';
                     invitePlaceholder.style.display = 'block';
                     invitePlaceholder.querySelector('p').textContent = 'No invites yet';
                 } else {
                     invitePlaceholder.style.display = 'none';
                     recordListContainer.innerHTML = inviteRecords.sort((a, b) => new Date(b.joinTime) - new Date(a.joinTime))
                         .map(record => `
                             <div class="record-item">
                                 <img src="https://via.placeholder.com/40/808080/FFFFFF?text=${(record.username || 'U')[0].toUpperCase()}" alt="${record.username || 'User'}">
                                 <div class="user-info">
                                     <span>${record.username || 'Unknown User'}</span>
                                     <small>${new Date(record.joinTime).toLocaleString()}</small>
                                 </div>
                                 <span class="credit">+${record.creditAwarded || 0}</span>
                             </div>
                         `).join('');
                 }

                 // Populate Claim Records
                 if (claimHistory.length === 0) {
                     claimRecordListContainer.innerHTML = '';
                     claimPlaceholder.style.display = 'block';
                     claimPlaceholder.querySelector('p').textContent = 'No claim records yet';
                 } else {
                     claimPlaceholder.style.display = 'none';
                     claimRecordListContainer.innerHTML = claimHistory.sort((a, b) => new Date(b.claimTime) - new Date(a.claimTime))
                         .map(record => `
                             <div class="record-item">
                                 <img src="assets/icons/usdt.png" alt="USDT Claim" style="border-radius: 0;">
                                 <div class="user-info">
                                     <span>Claimed ${record.usdtAmount?.toFixed(4) || '?'} USDT</span>
                                     <small>${new Date(record.claimTime).toLocaleString()}</small>
                                 </div>
                                 <span class="credit" style="background: #00cc00;">-${record.creditsSpent?.toLocaleString() || '?'} C</span>
                             </div>
                         `).join('');
                 }

                 debugLog("Invite section UI updated successfully.");

             } catch (error) {
                 console.error("Error updating invite section UI:", error);
                 debugLog(`Error updating invite section UI: ${error.message}`);
                 // Show error state in UI
                 myInviteEl.textContent = `My Invite: ERR`;
                 totalCreditEl.innerHTML = `Total Credit <span class="warning">!</span> : ERR`;
                 invitePlaceholder.style.display = 'block';
                 invitePlaceholder.querySelector('p').textContent = 'Error loading invites';
                 claimPlaceholder.style.display = 'block';
                 claimPlaceholder.querySelector('p').textContent = 'Error loading claims';
             }
         }

        // Claim Credits Logic
         document.querySelector('.invite-section .claim-button').addEventListener('click', async () => {
             debugLog("[CREDIT CLAIM] Claim button clicked.");
             if (!telegramUser || !telegramUser.id) { /* ... */ return; }
             if (!firebaseInitialized || !db) { /* ... */ return; }

             const claimButton = document.querySelector('.invite-section .claim-button');
             claimButton.disabled = true; claimButton.textContent = 'Checking...';

             const userDocRef = db.collection('userData').doc(telegramUser.id.toString());
             try {
                 // Fetch latest data for claim check
                 const userDoc = await userDocRef.get();
                 if (!userDoc.exists) throw new Error("User data not found for claim.");

                 const data = userDoc.data();
                 const currentCredits = data.referralCredits || 0;
                 const conversionRate = 10000;
                 const minimumClaim = 10000;

                 debugLog(`[CREDIT CLAIM] Current credits: ${currentCredits}`);
                 if (currentCredits < minimumClaim) { /* ... alert insufficient ... */ claimButton.disabled = false; claimButton.textContent = 'Claim'; return; }

                 const usdtToClaim = Math.floor(currentCredits / conversionRate);
                 const creditsToSpend = usdtToClaim * conversionRate;

                 debugLog(`[CREDIT CLAIM] Attempting to claim ${usdtToClaim} USDT for ${creditsToSpend} credits.`);
                 claimButton.textContent = 'Claiming...';

                 const claimRecord = {
                     claimTime: new Date().toISOString(),
                     usdtAmount: usdtToClaim,
                     creditsSpent: creditsToSpend,
                     rate: conversionRate
                 };

                 await userDocRef.update({
                     usdt: firebase.firestore.FieldValue.increment(usdtToClaim),
                     referralCredits: firebase.firestore.FieldValue.increment(-creditsToSpend),
                     claimHistory: firebase.firestore.FieldValue.arrayUnion(claimRecord)
                 });

                 debugLog(`[CREDIT CLAIM] Successfully claimed ${usdtToClaim} USDT. Deducted ${creditsToSpend} credits.`);
                 if (analytics) analytics.logEvent('credit_claim', { userId: telegramUser.id, usdt: usdtToClaim, credits: creditsToSpend });
                 alert(`Successfully claimed ${usdtToClaim} USDT!`);

                 // Update UI immediately
                 await fetchAndUpdateUserData(); // Refresh cache
                 await updateUserStatsUI();
                 await updateInviteSectionUI();

             } catch (error) {
                 console.error("[CREDIT CLAIM ERROR] Error claiming credits:", error);
                 debugLog(`[CREDIT CLAIM ERROR] ${error.message}`);
                 alert("Failed to claim credits. Please try again.");
             } finally {
                 claimButton.disabled = false; claimButton.textContent = 'Claim';
             }
         });

        // Invite Button Actions
         document.querySelector('.invite-friend').addEventListener('click', () => {
             const link = document.querySelector('.invite-friend').getAttribute('data-link');
             if (link && window.Telegram && window.Telegram.WebApp) { /* ... open link ... */ }
             else if (link) { /* ... copy link fallback ... */ }
             else { /* ... alert no link ... */ }
         });

         document.querySelector('.copy-link').addEventListener('click', () => {
             const link = document.querySelector('.copy-link').getAttribute('data-link');
             if (link && navigator.clipboard) { /* ... copy link ... */ }
             else if (link) { /* ... alert clipboard unavailable ... */ }
             else { /* ... alert no link ... */ }
         });


        // --- Top Section (Ranking) ---
        async function updateTopSectionUI() {
             debugLog("Updating Top section UI (Ranking)...");
            const rankingList = document.getElementById('ranking-list');
             if (!rankingList) { /* ... error handling ... */ return; }
             rankingList.innerHTML = `<li class="loading"><p>Loading rankings...</p></li>`;

             if (!firebaseInitialized || !db) { /* ... error handling ... */ return; }

             try {
                 const rankingsSnapshot = await db.collection('users')
                     .orderBy('foxMedals', 'desc')
                     .limit(30)
                     .get();

                 const rankings = [];
                 rankingsSnapshot.forEach(doc => {
                     const data = doc.data();
                     rankings.push({
                         id: doc.id,
                         username: data.username || 'Anonymous',
                         foxMedals: data.foxMedals || 0,
                         photoUrl: data.photoUrl || 'assets/icons/user-avatar.png'
                     });
                 });
                 debugLog(`Workspaceed ${rankings.length} ranking entries.`);

                 if (rankings.length === 0) {
                     rankingList.innerHTML = `<li class="no-rankings"><p>The ranking is empty right now.</p></li>`;
                 } else {
                     rankingList.innerHTML = rankings.map((user, index) => `
                         <li class="ranking-item">
                             <span class="rank-number" style="margin-right: 10px; font-weight: bold; width: 25px; text-align: right;">${index + 1}.</span>
                             <img src="${user.photoUrl}" alt="${user.username}" onerror="this.src='assets/icons/user-avatar.png'">
                             <span class="rank-username" style="flex-grow: 1; margin-left: 5px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${user.username}</span>
                             <div class="medal-count">
                                 <span>${user.foxMedals.toLocaleString()}</span>
                                 <img src="assets/icons/fox-medal.png" alt="Fox Medal">
                             </div>
                         </li>
                     `).join('');
                 }
                 debugLog("Top section UI updated successfully.");
             } catch (error) {
                 console.error("Error updating top section UI:", error);
                 debugLog(`Error updating ranking UI: ${error.message}`);
                 rankingList.innerHTML = `<li class="error"><p>Failed to load rankings. Please try again.</p></li>`;
             }
         }


        // --- Wallet Section UI & TON Connect ---
        async function updateWalletSectionUI() {
             debugLog("Updating Wallet section UI...");
             await updateUserStatsUI(); // Update balances first
             await updateWalletConnectionStatusUI();
             await updateTransactionHistory();
             debugLog("Wallet section UI update complete.");
         }

         async function updateWalletConnectionStatusUI() {
             debugLog("Updating Wallet Connection Status UI...");
             const elements = getWalletElements();
             if (!elements.connectButton || !elements.connectionStatus) { /* ... */ return; }

             const isConnected = tonConnectUI && tonConnectUI.connected;
             debugLog(`Wallet connection status: ${isConnected}`);

             if (isConnected) {
                 elements.connectionStatus.textContent = 'Connected';
                 elements.connectionStatus.className = 'wallet-status connected';
                 elements.connectButton.textContent = 'DISCONNECT';
                 elements.connectButton.classList.add('connected');
                 elements.withdrawButtons.forEach(btn => btn.disabled = false );

                 const walletAddress = tonConnectUI.account?.address;
                 if (walletAddress) {
                     await Storage.setItem('walletAddress', walletAddress);
                     debugLog(`Wallet connected: Address ${walletAddress} stored.`);
                 } else {
                     debugLog("Wallet connected, but address not immediately available.");
                     const storedAddress = await Storage.getItem('walletAddress');
                     debugLog(`Stored wallet address: ${storedAddress}`);
                 }
             } else {
                 elements.connectionStatus.textContent = 'Disconnected';
                 elements.connectionStatus.className = 'wallet-status disconnected';
                 elements.connectButton.textContent = 'CONNECT TON WALLET';
                 elements.connectButton.classList.remove('connected');
                 elements.withdrawButtons.forEach(btn => btn.disabled = true );
                 debugLog("Wallet disconnected state UI updated.");
             }
         }

         function getWalletElements() {
            return {
                 connectButton: document.querySelector('.connect-button'),
                 connectionStatus: document.getElementById('connection-status'),
                 withdrawButtons: document.querySelectorAll('.withdraw-button'),
                 walletSection: document.getElementById('wallet'),
                 transactionList: document.getElementById('transaction-list')
             };
         }

         async function initializeTonConnect() {
             debugLog("Initializing TON Connect...");
             try {
                 if (!window.TonConnectUI) {
                     const cdnUrl = 'https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js';
                     debugLog("Attempting to load TON Connect UI from CDN:", cdnUrl);
                     await loadScript(cdnUrl); // Ensure loadScript uses Promises
                     if (!window.TonConnectUI) throw new Error("Loaded from CDN, but TonConnectUI not defined.");
                     debugLog("TON Connect UI loaded successfully from CDN.");
                 } else {
                      debugLog("TON Connect UI already available in window scope.");
                 }

                 tonConnectUI = new TonConnectUI({
                     manifestUrl: 'https://fourgo.app/tonconnect-manifest.json', // Ensure this is correct and accessible
                     buttonRootId: null
                 });
                 debugLog("TON Connect UI instance created.");
                 return tonConnectUI;

             } catch (error) {
                 console.error(`TON Connect initialization failed: ${error.message}`);
                 debugLog(`TON Connect initialization failed: ${error.message}`);
                 alert("Wallet connection features are unavailable.");
                 // Return a dummy object to prevent errors elsewhere if needed
                 return { connected: false, account: null, connectWallet: async () => { alert("Wallet connection unavailable."); }, disconnect: async () => {}, onStatusChange: () => {} };
             }
         }

         async function handleConnectClick() {
             debugLog("[WALLET ACTION] Connect/Disconnect button clicked.");
             const elements = getWalletElements();
             if (!elements.connectButton || !tonConnectUI) { /* ... */ return; }

             elements.connectButton.disabled = true; elements.connectButton.textContent = 'Processing...';
             try {
                 if (tonConnectUI.connected) {
                     debugLog("Disconnecting wallet...");
                     await tonConnectUI.disconnect(); // Triggers status change
                     debugLog("Wallet disconnect initiated.");
                 } else {
                     debugLog("Connecting wallet...");
                     await tonConnectUI.connectWallet(); // Opens modal, triggers status change
                     debugLog("Wallet connection process initiated.");
                 }
             } catch (error) {
                 console.error(`Wallet connection/disconnection error: ${error.message}`);
                 debugLog(`Wallet connect/disconnect error: ${error.message}`);
                 alert(`Wallet action failed: ${error.message}`);
                 await updateWalletConnectionStatusUI(); // Update UI based on actual state on error
             } finally {
                 // Re-enable button only if status change didn't handle it (safety net)
                 setTimeout(() => {
                     if (elements.connectButton && elements.connectButton.textContent === 'Processing...') {
                         elements.connectButton.disabled = false;
                         updateWalletConnectionStatusUI(); // Ensure correct text/state
                     }
                 }, 1000);
             }
         }

         async function initWalletSystem() {
             debugLog("Initializing wallet system...");
             if (!tonConnectUI) { /* ... check needed */ return; }
             const elements = getWalletElements();
             if (!elements.connectButton) { /* ... check needed */ return; }

             try {
                 // TON Connect status change listener
                 tonConnectUI.onStatusChange(async (walletInfo) => {
                     debugLog(`[WALLET STATUS CHANGE] Wallet status changed. Connected: ${!!walletInfo}`, walletInfo ? { address: walletInfo.account.address, chain: walletInfo.account.chain } : null);
                     await fetchAndUpdateUserData(); // Refresh user data on connect/disconnect
                     await updateWalletConnectionStatusUI(); // Update UI based on new status
                     if (elements.connectButton) elements.connectButton.disabled = false; // Re-enable button
                 }, (error) => {
                      console.error("[WALLET STATUS CHANGE ERROR]", error);
                      debugLog(`[WALLET STATUS CHANGE ERROR] ${error.message}`);
                 });

                 // Add connect/disconnect button listener
                 elements.connectButton.removeEventListener('click', handleConnectClick);
                 elements.connectButton.addEventListener('click', handleConnectClick);

                 // Initial UI update based on current state
                 await updateWalletConnectionStatusUI();

                 // Setup withdraw button listeners
                 elements.withdrawButtons.forEach(button => {
                     const card = button.closest('.balance-card');
                     const newButton = button.cloneNode(true); // Clone to remove old listeners if any
                     button.parentNode.replaceChild(newButton, button); // Replace button in DOM
                     if (card) {
                         newButton.addEventListener('click', () => showWithdrawModal(card));
                     } else {
                         debugLog("[WALLET WARN] Could not find parent card for withdraw button.");
                     }
                 });

                 debugLog("Wallet system initialized successfully.");
             } catch (error) {
                 console.error(`Wallet system init failed: ${error.message}`);
                 debugLog(`Wallet system init failed: ${error.message}`);
             }
         }

         function showWithdrawModal(cardElement) {
             debugLog("Showing withdraw modal...");
             const modal = document.getElementById('withdraw-modal');
             const amountInput = document.getElementById('withdraw-amount');
             const availableBalanceEl = document.getElementById('available-balance');
             const currencySpan = document.getElementById('currency');
             const feeSpan = document.getElementById('withdraw-fee');
             const feeCurrencySpan = document.getElementById('fee-currency');

             if (!modal || !amountInput || !availableBalanceEl || !currencySpan || !feeSpan || !feeCurrencySpan) { /* ... */ return; }

             const isUsdt = cardElement.classList.contains('usdt-card');
             const currency = isUsdt ? 'USDT' : 'TON';
             const balance = parseFloat(cardElement.querySelector('.balance-info span')?.textContent || '0');
             const fee = isUsdt ? 0.01 : 0.005; // TODO: Fetch fees dynamically

             availableBalanceEl.textContent = balance.toFixed(4);
             currencySpan.textContent = currency;
             feeSpan.textContent = fee.toFixed(isUsdt ? 2 : 3);
             feeCurrencySpan.textContent = currency;
             amountInput.value = '';
             amountInput.max = Math.max(0, balance - fee).toFixed(4);
             amountInput.step = isUsdt ? "0.0001" : "0.001";

             const confirmButton = document.getElementById('confirm-withdraw');
             const cancelButton = document.getElementById('cancel-withdraw');
             // Clone buttons to ensure old listeners are removed before adding new ones
             const newConfirmButton = confirmButton.cloneNode(true);
             const newCancelButton = cancelButton.cloneNode(true);
             confirmButton.parentNode.replaceChild(newConfirmButton, confirmButton);
             cancelButton.parentNode.replaceChild(newCancelButton, cancelButton);

             newConfirmButton.onclick = () => confirmWithdraw(currency, balance, fee);
             newCancelButton.onclick = () => { modal.style.display = 'none'; debugLog("Withdraw modal cancelled."); };

             modal.style.display = 'flex';
             debugLog(`Withdraw modal shown for ${currency}. Balance: ${balance}, Fee: ${fee}`);
         }

         async function confirmWithdraw(currency, balance, fee) {
             debugLog(`[WITHDRAW ACTION] Confirming withdrawal for ${currency}...`);
             const modal = document.getElementById('withdraw-modal');
             const amountInput = document.getElementById('withdraw-amount');
             const amount = parseFloat(amountInput.value);

             const confirmButton = document.getElementById('confirm-withdraw');
             confirmButton.disabled = true; confirmButton.textContent = 'Processing...';

             if (isNaN(amount) || amount <= 0) { alert("Invalid amount entered."); confirmButton.disabled = false; confirmButton.textContent = 'Confirm'; return; }
             if (amount + fee > balance) { alert("Insufficient balance (including fee)."); confirmButton.disabled = false; confirmButton.textContent = 'Confirm'; return; }
             if (!tonConnectUI || !tonConnectUI.connected || !tonConnectUI.account?.address) { alert("Wallet not connected."); confirmButton.disabled = false; confirmButton.textContent = 'Confirm'; modal.style.display = 'none'; return; }

             const destinationAddress = tonConnectUI.account.address;
             const userDocRef = db.collection('userData').doc(telegramUser.id.toString());
             const totalDeduction = amount + fee;
             const balanceField = currency.toLowerCase();

             try {
                 debugLog(`[WITHDRAW SIMULATION] Initiating withdrawal: ${amount} ${currency} to ${destinationAddress} (Fee: ${fee} ${currency})`);

                 // Create Transaction Record (Pending)
                 const transaction = {
                     txId: `sim_tx_${Date.now()}`,
                     userId: telegramUser.id.toString(),
                     amount: amount, currency: currency, fee: fee, totalDeducted: totalDeduction,
                     destination: destinationAddress, status: 'pending',
                     timestamp: firebase.firestore.FieldValue.serverTimestamp(), type: 'withdrawal'
                 };
                 // Reference the subcollection correctly
                 const txRef = db.collection('userData').doc(telegramUser.id.toString()).collection('transactions').doc(transaction.txId);
                 await txRef.set(transaction);
                 debugLog(`[WITHDRAW SIMULATION] Pending transaction record created: ${transaction.txId}`);

                 // Deduct Balance from User Data
                 await userDocRef.update({ [balanceField]: firebase.firestore.FieldValue.increment(-totalDeduction) });
                 debugLog(`[WITHDRAW SIMULATION] User balance deducted: -${totalDeduction} ${currency}`);

                 // Simulate Processing Delay & Completion
                 setTimeout(async () => {
                     try {
                         await txRef.update({ status: 'completed' });
                         debugLog(`[WITHDRAW SIMULATION] Transaction ${transaction.txId} marked as completed.`);
                         await updateTransactionHistory(); // Refresh history UI
                     } catch (simError) {
                          console.error("Error updating simulated transaction status:", simError);
                          debugLog(`[WITHDRAW SIMULATION ERROR] Failed updating tx ${transaction.txId} status: ${simError.message}`);
                          // Attempt to mark as failed in Firestore
                          try { await txRef.update({ status: 'failed', failureReason: simError.message }); } catch (failErr) { console.error("Failed to mark tx as failed:", failErr); }
                     }
                 }, 5000); // 5 second delay for simulation

                 if (analytics) analytics.logEvent('withdrawal_initiated', { userId: telegramUser.id, currency, amount, fee });

                 modal.style.display = 'none';
                 await fetchAndUpdateUserData(); // Refresh cache immediately after deduction
                 await updateUserStatsUI(); // Update header/wallet balances
                 await updateTransactionHistory(); // Show pending transaction
                 alert(`Withdrawal of ${amount.toFixed(4)} ${currency} initiated (Fee: ${fee.toFixed(4)} ${currency}). This is a simulation and no real crypto is sent.`); // Updated alert

             } catch (error) {
                 console.error(`Withdrawal error: ${error.message}`);
                 debugLog(`[WITHDRAW ERROR] ${error.message}`);
                 alert(`Withdrawal failed: ${error.message}`);
                 // If the initial Firestore update fails, transaction shouldn't be created
                 // If update fails AFTER tx created, need reconciliation logic (complex)
                 // For simulation, just alert failure.
             } finally {
                  // Ensure button is re-enabled and modal is potentially closed even on error
                  if (modal.style.display !== 'none') {
                      confirmButton.disabled = false; confirmButton.textContent = 'Confirm';
                  }
             }
         }

         async function updateTransactionHistory() {
             debugLog("Updating transaction history...");
             const elements = getWalletElements();
             if (!elements.transactionList) { /* ... */ return; }
             elements.transactionList.innerHTML = '<li>Loading history...</li>';

             if (!firebaseInitialized || !db || !telegramUser || !telegramUser.id) { elements.transactionList.innerHTML = '<li>History unavailable.</li>'; return; }

             try {
                 // Reference the subcollection correctly
                 const txCollectionRef = db.collection('userData').doc(telegramUser.id.toString()).collection('transactions');
                 const snapshot = await txCollectionRef.orderBy('timestamp', 'desc').limit(15).get();

                 if (snapshot.empty) { elements.transactionList.innerHTML = '<li>No transactions yet</li>'; return; }

                 debugLog(`Workspaceed ${snapshot.docs.length} transaction history entries.`);
                 elements.transactionList.innerHTML = snapshot.docs.map(doc => {
                     const tx = doc.data();
                     // Format timestamp safely
                     let txTime = 'Invalid date';
                     if (tx.timestamp && typeof tx.timestamp.toDate === 'function') {
                        try { txTime = tx.timestamp.toDate().toLocaleString(); } catch (dateErr) { console.warn("Error formatting date:", dateErr); }
                     } else if (tx.timestamp) {
                         txTime = new Date(tx.timestamp).toLocaleString(); // Fallback for potential string/number timestamps
                     }

                     let detail = '';
                     const status = tx.status || 'unknown';
                     const statusClass = status.toLowerCase(); // Ensure class is lowercase

                      if (tx.type === 'withdrawal') {
                          detail = `Withdraw ${tx.amount?.toFixed(4) || '?'} ${tx.currency || '?'} (Fee: ${tx.fee?.toFixed(4) || '?'})`;
                      } else if (tx.type === 'credit_claim') { // Assuming this type might exist from claim logic
                          detail = `Claimed ${tx.usdtAmount?.toFixed(4) || '?'} USDT (${tx.creditsSpent?.toLocaleString() || '?'} C)`;
                      } else {
                          detail = `Type: ${tx.type || 'Unknown'}`;
                      }
                     return `<li> ${detail} - <span class="tx-status ${statusClass}">${status}</span> - ${txTime} </li>`;
                 }).join('');
             } catch (error) {
                 console.error(`Error updating transaction history: ${error.message}`);
                 debugLog(`Error updating transaction history: ${error.message}`);
                 elements.transactionList.innerHTML = `<li>Error loading history.</li>`;
             }
         }


        // --- Chest Section Logic ---
        function renderChests() {
            debugLog("[CHEST] Rendering chests...");
            const container = document.getElementById('chestContainer');
            if (!container) { /* ... */ return; }
            container.innerHTML = chests.map((chest, index) => `
                <div class="chest-item" data-index="${index}">
                    <div class="chest-title">
                        <h2>${chest.name}</h2>
                        <span>${chest.next ? `Next: ${chest.next}` : 'Max Level'}</span>
                    </div>
                    <div class="chest-image">
                        <img src="${chest.image}" alt="${chest.name}" onerror="this.src='assets/icons/chest_placeholder.png'">
                    </div>
                     <div class="chest-cost-display" style="margin-top: 10px;"></div>
                     <div class="chest-vip-display" style="display: none; color: #ffcc00; margin-top: 10px;"></div>
                     <div class="chest-not-enough-display" style="display: none; color: #ffcc00; margin-top: 10px;">
                         <img src="assets/icons/gem.png" alt="Gem" style="width: 16px; height: 16px; vertical-align: middle;">
                         <span>NOT ENOUGH</span>
                     </div>
                </div>
            `).join('');
             debugLog(`[CHEST] Rendered ${chests.length} chests.`);
             updateChestUI(); // Initial UI update
         }

        function updateChestUI() {
            const chest = chests[currentChestIndex];
             debugLog(`[CHEST] Updating UI for Chest index: ${currentChestIndex} (${chest?.name || 'N/A'})`); // Safer logging
             if (!chest) {
                 console.error(`[CHEST ERROR] Invalid chest index: ${currentChestIndex}`);
                 debugLog(`[CHEST ERROR] Invalid chest index: ${currentChestIndex}`);
                 // Optionally reset index or display error
                 // currentChestIndex = 0; // Reset to first chest
                 // chest = chests[currentChestIndex];
                 return; // Prevent further errors
             }
            const container = document.getElementById('chestContainer');
            const currentChestItem = document.querySelector(`#chestContainer .chest-item[data-index="${currentChestIndex}"]`);
            if (!container || !currentChestItem) { /* ... error handling ... */ return; }

            const costDisplay = currentChestItem.querySelector(`.chest-cost-display`);
            const vipDisplay = currentChestItem.querySelector(`.chest-vip-display`);
            const notEnoughDisplay = currentChestItem.querySelector(`.chest-not-enough-display`);
            const openButton = document.querySelector('.open-chest-button'); // Main button outside slider

            if (!costDisplay || !vipDisplay || !notEnoughDisplay || !openButton) { /* ... */ return; }

            // Update Slider Position
            container.style.transform = `translateX(-${currentChestIndex * 100}%)`;

            // --- Update Cost/VIP/Button State ---
             costDisplay.style.display = 'none';
             vipDisplay.style.display = 'none';
             notEnoughDisplay.style.display = 'none';
             openButton.disabled = false; // Enable button by default

             // Use cached user data for checks
             const userData = currentUserData; // Assumes fetchAndUpdateUserData has been called
             const userVipLevel = userData?.vipLevel || 0; // Use cached VIP level
             const userGems = userData?.gems || 0; // Use cached Gems

             debugLog(`[CHEST CHECK] User VIP: ${userVipLevel}, User Gems: ${userGems}, Chest: ${chest.name} (Needs VIP ${chest.vip}, Cost ${chest.gemCost})`);

             if (chest.vip > userVipLevel) {
                 vipDisplay.textContent = `NEED VIP ${chest.vip}`;
                 vipDisplay.style.display = 'block';
                 openButton.disabled = true;
                 openButton.textContent = `VIP ${chest.vip} Required`;
                 debugLog(`[CHEST] VIP ${chest.vip} required, user has ${userVipLevel}. Button disabled.`);
             } else {
                  costDisplay.innerHTML = `<img src="assets/icons/gem.png" alt="Gem" style="width: 20px; height: 20px; vertical-align: middle;"> <span>${chest.gemCost.toLocaleString()}</span>`;
                  costDisplay.style.display = 'flex'; costDisplay.style.justifyContent = 'center'; costDisplay.style.alignItems = 'center'; costDisplay.style.gap = '5px';
                  openButton.textContent = 'Open Chest';

                  if (userGems < chest.gemCost) {
                       notEnoughDisplay.style.display = 'flex'; notEnoughDisplay.style.justifyContent = 'center'; notEnoughDisplay.style.alignItems = 'center'; notEnoughDisplay.style.gap = '5px';
                       openButton.disabled = true;
                       debugLog(`[CHEST] Insufficient gems. Need ${chest.gemCost}, user has ${userGems}. Button disabled.`);
                  } else {
                      debugLog(`[CHEST] User meets VIP and Gem requirements. Button enabled.`);
                  }
             }

            // Update Navigation Arrows
            document.querySelector('.nav-arrow.left').style.display = currentChestIndex === 0 ? 'none' : 'block';
            document.querySelector('.nav-arrow.right').style.display = currentChestIndex === chests.length - 1 ? 'none' : 'block';
        }

        window.nextChest = function() {
            if (currentChestIndex < chests.length - 1) {
                currentChestIndex++;
                debugLog(`[CHEST] Next button clicked. New index: ${currentChestIndex}`);
                updateChestUI();
            }
        };

        window.prevChest = function() {
            if (currentChestIndex > 0) {
                currentChestIndex--;
                debugLog(`[CHEST] Previous button clicked. New index: ${currentChestIndex}`);
                updateChestUI();
            }
        };

        window.openChest = async function() {
             const chest = chests[currentChestIndex];
              if (!chest) {
                  console.error("[CHEST ACTION ERROR] Cannot open chest, invalid index:", currentChestIndex);
                  debugLog(`[CHEST ACTION ERROR] Cannot open chest, invalid index: ${currentChestIndex}`);
                  alert("Error: Could not determine which chest to open.");
                  return;
              }
             debugLog(`[CHEST ACTION] Attempting to open chest: ${chest.name}`);
             const openButton = document.querySelector('.open-chest-button');
             openButton.disabled = true; openButton.textContent = 'Opening...';

             if (!telegramUser || !telegramUser.id) { alert("User not identified."); openButton.disabled = false; updateChestUI(); return; }
             if (!firebaseInitialized || !db) { alert("Database not ready."); openButton.disabled = false; updateChestUI(); return; }

             const userDocRef = db.collection('userData').doc(telegramUser.id.toString());
             const rankingDocRef = db.collection('users').doc(telegramUser.id.toString());

             try {
                  // Fetch latest data for check (important!)
                  const userData = await fetchAndUpdateUserData();
                  if (!userData) throw new Error("User data not found to open chest.");

                 const currentGems = userData.gems || 0;
                 const userVipLevel = userData.vipLevel || 0;

                 debugLog(`[CHEST ACTION CHECK] Checking requirements: Need VIP ${chest.vip} (Have ${userVipLevel}), Need Gems ${chest.gemCost} (Have ${currentGems})`);

                 if (chest.vip > userVipLevel) throw new Error(`VIP Level ${chest.vip} required.`);
                 if (currentGems < chest.gemCost) throw new Error(`Insufficient gems. Need ${chest.gemCost}, have ${currentGems}.`);

                 // Simulate Reward Calculation
                 const rewards = {
                     usdt: parseFloat((Math.random() * (chest.gemCost / 4000) + (chest.gemCost / 10000)).toFixed(4)),
                     landPiece: Math.random() < 0.1 ? 1 : 0, // 10% chance for land piece
                     foxMedal: Math.floor(Math.random() * (currentChestIndex + 1)) + 1 // Higher index = potentially more medals
                 };
                 debugLog("[CHEST ACTION] Calculated rewards:", rewards);

                 // Update Firestore
                 const updates = {
                     gems: firebase.firestore.FieldValue.increment(-chest.gemCost),
                     usdt: firebase.firestore.FieldValue.increment(rewards.usdt),
                     landPieces: firebase.firestore.FieldValue.increment(rewards.landPiece),
                     foxMedals: firebase.firestore.FieldValue.increment(rewards.foxMedal)
                 };
                 await userDocRef.update(updates);

                 // Update ranking document if medals were awarded
                 if (rewards.foxMedal > 0) {
                      // Use set with merge to ensure document exists or is updated
                      await rankingDocRef.set({
                          foxMedals: firebase.firestore.FieldValue.increment(rewards.foxMedal)
                      }, { merge: true });
                 }
                 debugLog(`[CHEST ACTION] Firestore updated. Deducted ${chest.gemCost} gems. Added rewards.`);

                 if (analytics) analytics.logEvent('chest_opened', { userId: telegramUser.id, chestName: chest.name, cost: chest.gemCost, rewards });

                 // Show Rewards
                 let rewardString = `Opened ${chest.name}! Rewards:\n`;
                 if (rewards.usdt > 0) rewardString += `- ${rewards.usdt.toFixed(4)} USDT\n`;
                 if (rewards.landPiece > 0) rewardString += `- ${rewards.landPiece} Land Piece\n`;
                 if (rewards.foxMedal > 0) rewardString += `- ${rewards.foxMedal} Fox Medal\n`;
                 if (rewards.usdt <= 0 && rewards.landPiece <= 0 && rewards.foxMedal <= 0) {
                    rewardString += "- Nothing this time!"; // Handle case where all rewards are 0
                 }
                 alert(rewardString);

                 // Update UI
                 await fetchAndUpdateUserData(); // Refresh cache with new balances *AFTER* update
                 await updateUserStatsUI(); // Update header stats
                 updateChestUI(); // Re-check requirements/costs for the current chest & update button state

             } catch (error) {
                 console.error("Error opening chest:", error);
                 debugLog(`[CHEST ERROR] ${error.message}`);
                 alert(`Failed to open chest: ${error.message}`);
                 // Ensure button is re-enabled and UI reflects potential unchanged state
                 openButton.disabled = false;
                 updateChestUI(); // Crucial to reset button state based on actual data

             }
             // No finally block needed as state is handled by updateChestUI called in try/catch
         };


        // --- App Initialization ---
        async function initApp() {
            debugLog("--- App Initialization Sequence Start ---");

             // 1. Initialize Telegram Interface
            initializeTelegram();

             // 2. Initialize Firebase
            const firebaseSuccess = await initializeFirebase();
            if (!firebaseSuccess) {
                debugLog("App Init Failed: Firebase could not be initialized.");
                return;
            }

            // 3. Initialize User Data (includes fetching initial data into currentUserData)
             await ensureFirebaseReady(initializeUserData, 'initializeUserData');

            // 4. Handle Incoming Referrals
             await ensureFirebaseReady(handleReferral, 'handleReferral');

             // 5. Generate User's Referral Link
            generateReferralLink();

             // 6. Initialize TON Connect
            tonConnectUI = await initializeTonConnect();

             // 7. Setup Wallet System Listeners & UI
             await initWalletSystem(); // Depends on tonConnectUI

            // 8. Render Dynamic Components (Chests)
            renderChests();

            // 9. Setup Main Navigation
            setupNavigation(); // Sets default section and triggers initial data load for it

            // 10. Initial Data Load for Default Section (handled by setupNavigation/switchSection) - No extra call needed here

            // ***** START: ADD AUTOMATIC IN-APP AD INITIALIZATION *****
            // This calls the Monetag SDK once and lets it handle automatic display
            // based on the rules defined in inAppSettings.
            try {
                if (typeof window.show_9180370 === 'function') {
                    // Define the settings for automatic display
                    // Adjust these values as needed based on Monetag docs and desired behavior
                               const autoInAppSettings = {
               frequency: 2,      // Max 2 ads per session defined by capping
               capping: 0.016,    // Session duration = 0.016 hours (~1 minute) <<<--- NEW VALUE
               interval: 30,     // Minimum 30 seconds between ads
               timeout: 5,       // 5-second delay before the *first* ad in a session might show
               everyPage: false   // Keep this based on your needs
           };

                                         // Monitor if this works as expected with section changes.
                    };
                    debugLog('[AD INIT] Initializing automatic In-App ads with settings:', JSON.stringify(autoInAppSettings));
                    // Initialize automatic ads
                    window.show_9180370({ type: 'inApp', inAppSettings: autoInAppSettings });
                } else {
                    debugLog('[AD INIT] Monetag SDK function not found, cannot initialize automatic ads.');
                }
            } catch (initAdError) {
                console.error('[AD INIT] Error initializing automatic In-App ads:', initAdError);
                debugLog(`[AD INIT] Error initializing automatic ads: ${initAdError.message}`);
            }
            // ***** END: ADD AUTOMATIC IN-APP AD INITIALIZATION *****


            debugLog("--- App Initialization Sequence Finished ---");
         }

        // --- DOMContentLoaded ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log('[DEBUG] DOMContentLoaded event fired.');
            debugLog("DOMContentLoaded event fired. Starting App Initialization.");
            initApp(); // Start the main application logic
        });

    </script>
</body>
</html>
