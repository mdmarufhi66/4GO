<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4Metas Mini App</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src='//whephiwums.com/sdk.js' data-zone='9180370' data-sdk='show_9180370'></script>
    <style>
        /* Updated body structure */
        body {
            background: linear-gradient(to bottom, #330033, #000000);
            color: white;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Main content area */
        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            padding-bottom: 70px; /* Space for bottom nav */
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            position: sticky;
            top: 0;
            background: linear-gradient(to bottom, #330033, #000000);
            z-index: 1000;
        }
        header h1 {
            font-size: 24px;
            margin: 0;
        }
        .back-arrow, .menu-dots {
            font-size: 24px;
            cursor: pointer;
        }
        .user-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 0 10px;
        }
        .user-stats .logo img {
            width: 50px;
            height: 50px;
        }
        .user-stats .metric {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .user-stats .metric img {
            width: 20px;
            height: 20px;
        }
        .user-stats .profile-pic img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        .section {
            display: none;
        }
        .section.active {
            display: block;
        }
        .banner-placeholder {
            background: #1a1a3d;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            margin-bottom: 20px;
        }
        .banner-placeholder img {
            width: 100%;
            border-radius: 10px;
        }
        .quest-section h2 {
            font-size: 18px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .quest-section .badge {
            background: #ff00ff;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
        }
        .quest-list {
            list-style: none;
            padding: 0;
        }
        .quest-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .quest-item img {
            width: 30px;
            height: 30px;
            border-radius: 50%;
        }
        .quest-reward {
            display: flex;
            align-items: center;
            gap: 5px;
            /* Ensure the container doesn't shrink excessively */
            flex-shrink: 0;
            margin-left: 10px; /* Add some space between title and reward */
        }
        .quest-reward > * { /* Prevent items inside from shrinking */
             flex-shrink: 0;
        }
        .quest-reward img {
            width: 20px;
            height: 20px;
        }
        .go-button, .claim-button, .claimed-button {
            border: none;
            color: white;
            padding: 5px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap; /* Prevent button text wrapping */
        }
        .go-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
        }
        .claim-button {
            background: linear-gradient(to right, #00ff00, #66ff66);
        }
        .claimed-button {
            background: #ccc;
            cursor: default;
        }
        .quest-item .progress {
            font-size: 12px;
            color: #ccc;
            margin-left: 5px; /* Adjust spacing */
             margin-right: 5px;
        }
        .claim-button.active {
            background: linear-gradient(to right, #00ff00, #66ff66);
        }
        .wallet-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .balance-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .balance-card img {
            width: 30px;
            height: 30px;
        }
        .balance-info span {
            display: block;
            font-size: 16px;
        }
        .balance-info small {
            font-size: 12px;
            color: #ccc;
        }
        .withdraw-button {
            background: #00ff00;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            cursor: pointer;
        }
        .warning-button {
            background: #ffcc00;
            border: none;
            color: black;
            padding: 5px 10px;
            border-radius: 50%;
            cursor: pointer;
        }
        .connect-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 15px;
            width: 100%;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.3s ease;
        }
        .connect-button.connected {
            background: linear-gradient(to right, #00ff00, #66ff66);
        }
        .connect-button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .wallet-status {
            text-align: center;
            margin: 10px 0;
            word-break: break-all; /* Allow long addresses to wrap */
        }
        .wallet-status.connected {
            color: #00ff00;
        }
        .wallet-status.disconnected {
            color: #ffcc00;
        }
        .transaction-history {
            margin-top: 20px;
        }
        .transaction-history ul {
            list-style: none;
            padding: 0;
        }
        .transaction-history li {
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
            font-size: 13px; /* Slightly smaller font */
            line-height: 1.4; /* Improve readability */
        }
         .transaction-history li span.tx-status { /* Style status */
             font-weight: bold;
             text-transform: capitalize;
         }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-content {
            background: #1a1a3d;
            padding: 20px;
            border-radius: 10px;
            color: white;
            width: 80%;
            max-width: 400px;
        }
        .modal-content input {
            width: calc(100% - 12px); /* Adjust width for padding */
            padding: 5px;
            margin: 10px 0;
            box-sizing: border-box; /* Include padding in width */
        }
         .modal-content button { /* Style modal buttons */
             padding: 8px 15px;
             margin-top: 10px;
             cursor: pointer;
             border-radius: 5px;
             border: none;
             color: white;
         }
         .modal-content button#confirm-withdraw { background-color: #00cc00; }
         .modal-content button#cancel-withdraw { background-color: #cc0000; margin-left: 10px; }
         .modal-content button:disabled { background-color: #666; cursor: not-allowed;}

        .game-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .game-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); /* Responsive grid */
            gap: 10px;
        }
        .game-item {
            background: #1a1a3d;
            border-radius: 10px;
            text-align: center;
            padding: 5px;
        }
        .game-item img {
            width: 100%;
            max-width: 70px; /* Limit image size */
            height: auto; /* Maintain aspect ratio */
            border-radius: 10px;
            display: block; /* Center image */
            margin: 0 auto 5px auto; /* Spacing */
        }
        .game-item p {
            margin: 5px 0;
            font-size: 12px;
        }
        .invite-section .invite-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .invite-stats .spin-info {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .action-button {
            background: linear-gradient(to right, #00ff00, #66ff66);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 15px;
            flex: 1;
            cursor: pointer;
        }
        .total-credit {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .total-credit small {
            font-size: 12px;
            color: #ccc;
        }
        .total-credit small img {
            width: 15px;
            height: 15px;
            vertical-align: middle; /* Align icon nicely */
        }
         .invite-section .claim-button { /* Specific styling for invite claim */
             border: none;
             color: white;
             padding: 5px 15px;
             border-radius: 15px;
             cursor: pointer;
             font-size: 14px;
             background: linear-gradient(to right, #00ff00, #66ff66); /* Green gradient */
         }
         .invite-section .claim-button:disabled {
             background: #666;
             opacity: 0.5;
             cursor: not-allowed;
         }

        .record-section h3, .invite-record h3 {
            font-size: 16px;
            margin: 10px 0;
        }
        .no-frens {
            text-align: center;
            color: #ccc;
            padding: 20px;
        }
        .no-frens img {
            width: 50px;
            height: 50px;
            opacity: 0.7;
        }
        .record-header {
            display: grid; /* Use grid for better alignment */
            grid-template-columns: auto 1fr auto; /* Adjust columns */
            gap: 10px;
            font-size: 14px;
            color: #ccc;
            margin-bottom: 10px;
            padding: 0 10px;
        }
        .record-item {
            display: grid; /* Use grid for better alignment */
            grid-template-columns: auto 1fr auto; /* Adjust columns */
            gap: 10px;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .record-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        .record-item .user-info {
            /* flex: 1; */ /* No longer needed with grid */
            /* margin-left: 10px; */ /* No longer needed */
             overflow: hidden; /* Prevent long names breaking layout */
             text-overflow: ellipsis;
             white-space: nowrap;
        }
         .record-item .user-info span { display: block; } /* Ensure name is block */
        .record-item .user-info small {
            color: #ccc;
            font-size: 12px;
            display: block; /* Ensure date is block */
        }
        .record-item .credit {
            background: #ff00ff;
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px; /* Smaller credit text */
            white-space: nowrap;
        }
        .chest-section .chest-slider {
            position: relative;
            overflow: hidden;
            margin-bottom: 20px;
        }
        .chest-container {
            display: flex;
            transition: transform 0.3s ease;
        }
        .chest-item {
            flex: 0 0 100%;
            text-align: center;
            padding: 10px; /* Add padding */
            box-sizing: border-box;
        }
        .chest-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 16px;
            margin-bottom: 10px; /* Spacing */
        }
        .chest-title span {
            color: #ccc;
            font-size: 14px;
        }
        .chest-image img {
            width: 150px;
            height: 150px;
            object-fit: contain; /* Ensure image fits */
        }
        .not-enough {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            color: #ffcc00;
            margin-top: 10px;
            font-weight: bold;
        }
        .not-enough img {
            width: 20px;
            height: 20px;
        }
        .nav-arrow {
            position: absolute;
            top: 40%; /* Adjust vertical position */
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.5);
            border: none;
            color: white;
            padding: 10px;
             font-size: 20px; /* Larger arrow */
            cursor: pointer;
            z-index: 100;
             border-radius: 50%; /* Circular arrows */
             width: 40px;
             height: 40px;
             display: flex;
             align-items: center;
             justify-content: center;
        }
        .nav-arrow.left { left: 5px; }
        .nav-arrow.right { right: 5px; }
        .rewards {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
        }
        .reward-item {
            text-align: center;
        }
        .reward-item img {
            width: 40px;
            height: 40px;
            object-fit: contain;
        }
        .reward-item p {
            margin: 5px 0;
            font-size: 12px;
        }
        .cost {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            margin-bottom: 10px;
            font-size: 16px; /* Larger cost font */
        }
        .cost img {
            width: 20px;
            height: 20px;
        }
        .vip-requirement {
            text-align: center;
            color: #ffcc00;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .open-chest-button {
            background: linear-gradient(to right, #ff00ff, #ff6666);
            border: none;
            color: white;
            padding: 12px; /* Larger button */
            border-radius: 15px;
            width: 100%;
            cursor: pointer;
             font-size: 16px; /* Larger font */
             transition: opacity 0.3s ease, background 0.3s ease;
        }
         .open-chest-button:disabled {
             background: #666;
             opacity: 0.5;
             cursor: not-allowed;
         }
        .top-section h2 {
            font-size: 18px;
            margin: 10px 0;
        }
        .ranking-list {
            list-style: none;
            padding: 0;
        }
        .ranking-item {
            display: flex;
            align-items: center;
            background: #1a1a3d;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
             gap: 10px; /* Use gap for spacing */
        }
        .ranking-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            /* margin-right: 10px; */ /* Replaced by gap */
             flex-shrink: 0; /* Prevent image shrinking */
        }
         .ranking-item .rank-number {
             width: 30px;
             text-align: right;
             color: #ccc;
              flex-shrink: 0;
         }
        .ranking-item .username { /* Added class for username */
            flex-grow: 1; /* Allow username to take space */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .ranking-item .medal-count {
            display: flex;
            align-items: center;
            gap: 5px;
             flex-shrink: 0; /* Prevent shrinking */
             white-space: nowrap;
        }
        .ranking-item .medal-count img {
            width: 20px;
            height: 20px;
        }

        nav.bottom-nav {
            display: flex !important;
            justify-content: space-around !important;
            background: #1a1a3d !important;
            padding: 5px 0 !important; /* Reduced padding */
            position: fixed !important;
            bottom: 0 !important; /* Stick to absolute bottom */
             /* Use safe-area-inset-bottom for iOS notches */
             padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 5px) !important;
            left: 0 !important;
            right: 0 !important;
            z-index: 100000 !important;
            height: auto !important; /* Adjust height based on content */
            min-height: 55px !important; /* Minimum height */
            visibility: visible !important;
            opacity: 1 !important;
            border-top: 1px solid #555 !important; /* Subtle top border */
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.5) !important;
        }

        nav.bottom-nav .nav-button {
            background: none !important;
            border: none !important;
            color: #ccc !important;
            display: flex !important;
            flex-direction: column !important;
            align-items: center !important;
            justify-content: center !important;
            cursor: pointer !important;
            font-size: 10px !important; /* Smaller font */
            flex: 1 !important; /* Allow buttons to take equal space */
            height: 100% !important;
            min-height: 50px !important; /* Ensure clickable area */
            padding: 2px 0 !important;
            visibility: visible !important;
            opacity: 1 !important;
            text-align: center; /* Center text */
        }

        nav.bottom-nav .nav-button.active {
            color: white !important;
        }

        nav.bottom-nav .nav-button img {
            width: 22px !important; /* Slightly smaller icon */
            height: 22px !important;
            margin-bottom: 3px !important; /* Adjust spacing */
            display: block !important;
        }

        nav.bottom-nav .nav-button span {
            display: block !important;
             line-height: 1.2; /* Adjust line height */
        }

        /* Additional styles for wallet integration */
        .error-message {
            color: #ffcc00;
            text-align: center;
            margin: 10px 0;
            display: none; /* Hide by default */
             background-color: rgba(255, 0, 0, 0.1); /* Subtle error background */
             padding: 5px;
             border-radius: 4px;
        }

        .tx-status { /* General status styling */
             font-weight: bold;
             text-transform: capitalize;
         }
        .tx-status.pending_backend, .tx-status.pending { color: #ffcc00; } /* Yellow for pending */
        .tx-status.completed_simulated, .tx-status.completed { color: #00ff00; } /* Green for completed */
        .tx-status.failed { color: #ff0000; } /* Red for failed */
    </style>
</head>
<body>
    <header>
        <h1>4Metas</h1>
        </header>

    <div class="main-content">
        <section class="user-stats">
            <div class="logo">
                <img src="assets/icons/logo.png" alt="4Metas Logo">
            </div>
            <div class="metric">
                <img src="assets/icons/gem.png" alt="Gem">
                <span id="gems">0</span>
            </div>
            <div class="metric">
                <img src="assets/icons/usdt.png" alt="USDT">
                <span id="usdt">0.0000</span>
            </div>
            <div class="metric">
                <img src="assets/icons/ton.png" alt="TON">
                <span id="ton">0.0000</span>
            </div>
            <div class="profile-pic">
                <img src="assets/icons/user-avatar.png" alt="User Profile">
            </div>
        </section>

        <section id="earn" class="section earn-section active">
            <div class="banner-placeholder">
                <img src="assets/icons/banner.png" alt="Banner">
            </div>
            <div class="quest-section">
                <h2>DAILY QUEST <span class="badge" id="daily-quest-count">0</span></h2>
                <ul class="quest-list" id="daily-quest-list">
                    <li class="no-quests"><p>Loading Daily Quests...</p></li>
                </ul>
            </div>
            <div class="quest-section">
                <h2>BASIC QUEST <span class="badge" id="basic-quest-count">0</span></h2>
                <ul class="quest-list" id="basic-quest-list">
                    <li class="no-quests"><p>Loading Basic Quests...</p></li>
                </ul>
            </div>
        </section>

        <section id="wallet" class="section wallet-section">
            <h2>Wallet</h2>
            <div class="wallet-status disconnected">
                <span id="connection-status">Disconnected</span>
            </div>
            <div class="balance-card usdt-card">
                <img src="assets/icons/usdt.png" alt="USDT Icon">
                <div class="balance-info">
                    <span id="wallet-usdt">0.0000</span>
                    <small>USDT</small>
                </div>
                <button class="withdraw-button" disabled>WITHDRAW</button>
                <button class="warning-button">!</button> </div>
            <div class="balance-card ton-card">
                <img src="assets/icons/ton.png" alt="TON Icon">
                <div class="balance-info">
                    <span id="wallet-ton">0.0000</span>
                    <small>TON</small>
                </div>
                <button class="withdraw-button" disabled>WITHDRAW</button>
                <button class="warning-button">!</button> </div>
            <p class="instruction">Connect wallet to withdraw your balance.</p>
            <button class="connect-button">CONNECT TON WALLET</button>
            <div class="transaction-history">
                <h3>Transaction History</h3>
                <ul id="transaction-list">
                    <li>Loading history...</li>
                </ul>
            </div>
            <div id="withdraw-modal" class="modal" style="display: none;">
                <div class="modal-content">
                    <h3>Withdraw <span id="currency-modal-title"></span></h3> <label>Amount: <input type="number" id="withdraw-amount" min="0" step="0.0001"></label>
                    <p>Available: <span id="available-balance">0</span> <span id="currency"></span></p>
                    <p>Fee: <span id="withdraw-fee">0</span> <span id="fee-currency"></span></p>
                    <p style="font-size: 12px; color: #ccc;">Minimum Withdrawal: <span id="min-withdraw-amount"></span> <span id="min-withdraw-currency"></span></p> <button id="confirm-withdraw">Confirm</button>
                    <button id="cancel-withdraw">Cancel</button>
                </div>
            </div>
        </section>

        <section id="game" class="section game-section">
             <div class="banner-placeholder">
                 <img src="assets/icons/game-banner.png" alt="Game Banner">
             </div>
             <h2>Game List</h2>
             <div class="game-list">
                 <div class="game-item"><img src="https://via.placeholder.com/80/FF0000/FFFFFF?text=G1" alt="Game 1"><p>Game One</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/00FF00/FFFFFF?text=G2" alt="Game 2"><p>Game Two</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/0000FF/FFFFFF?text=G3" alt="Game 3"><p>Game Three</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FFFF00/000000?text=G4" alt="Game 4"><p>Game Four</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FF00FF/FFFFFF?text=G5" alt="Game 5"><p>Game Five</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/00FFFF/000000?text=G6" alt="Game 6"><p>Game Six</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/FFA500/FFFFFF?text=G7" alt="Game 7"><p>Game Seven</p></div>
                 <div class="game-item"><img src="https://via.placeholder.com/80/800080/FFFFFF?text=G8" alt="Game 8"><p>Game Eight</p></div>
                 </div>
        </section>

        <section id="invite" class="section invite-section">
            <div class="invite-stats">
                <span id="my-invite">My Invite: 0</span>
                </div>
            <div class="action-buttons">
                <button class="action-button invite-friend">Invite Friend</button>
                <button class="action-button copy-link">Copy Link</button>
            </div>
            <div class="total-credit">
                <div class="credit-info">
                    <span>Total Credit <span class="warning">!</span> : <span id="total-credit-value">0</span></span> <small>10,000 Credits = 1 <img src="assets/icons/usdt.png" alt="USDT"></small>
                </div>
                <button class="claim-button" disabled>Claim</button> </div>
            <div class="invite-record">
                <h3 id="invite-record-title">Invite Record (0)</h3>
                 <div class="record-list">
                    <div class="no-frens">
                        <img src="assets/icons/nofrens.png" alt="No Frens">
                        <p>Loading invites...</p> </div>
                </div>
            </div>
        </section>

        <section id="chest" class="section chest-section">
             <div class="chest-slider">
                 <button class="nav-arrow left" onclick="prevChest()">‹</button> <div class="chest-container" id="chestContainer">
                     <div class="chest-item"><p>Loading Chests...</p></div>
                 </div>
                 <button class="nav-arrow right" onclick="nextChest()">›</button> </div>
             <div class="rewards">
                 <div class="reward-item usdt">
                     <img src="assets/icons/usdt.png" alt="USDT">
                     <p>USDT</p>
                 </div>
                 <div class="reward-item land-piece">
                     <img src="assets/icons/land-piece.png" alt="Land Piece">
                     <p>Land Piece</p>
                 </div>
                 <div class="reward-item fox-medal">
                     <img src="assets/icons/fox-medal.png" alt="Fox Medal">
                     <p>Fox Medal</p>
                 </div>
             </div>
             <div class="cost" id="chestCost" style="display: none;"> <span>0</span>
                 <img src="assets/icons/gem.png" alt="Gem">
             </div>
             <div class="vip-requirement" id="chestVipRequirement" style="display: none;">
                 NEED VIP X
             </div>
             <button class="open-chest-button" onclick="openChest()" disabled>Open Chest</button> </section>

        <section id="top" class="section top-section">
             <h2>Medal Ranking <span class="warning">!</span></h2> <ul class="ranking-list" id="ranking-list">
                 <li class="no-rankings"><p>Loading rankings...</p></li>
             </ul>
        </section>
    </div>

    <nav class="bottom-nav">
        <button class="nav-button active" data-section="earn"> <img src="assets/icons/earn.png" alt="Earn">
            <span>Earn</span>
        </button>
        <button class="nav-button" data-section="wallet">
            <img src="assets/icons/wallet.png" alt="Wallet">
            <span>Wallet</span>
        </button>
        <button class="nav-button" data-section="game">
            <img src="assets/icons/game.png" alt="Game">
            <span>Game</span>
        </button>
        <button class="nav-button" data-section="invite">
            <img src="assets/icons/invite.png" alt="Invite">
            <span>Invite</span>
        </button>
        <button class="nav-button" data-section="chest">
            <img src="assets/icons/chest.png" alt="Chest">
            <span>Chest</span>
        </button>
        <button class="nav-button" data-section="top">
            <img src="assets/icons/top.png" alt="Top">
            <span>Top</span>
        </button>
    </nav>
<div id="debugConsole" style="
    position: fixed;
    bottom: 65px; /* Adjusted for nav */
    left: 0;
    right: 0;
    background: rgba(0,0,0,0.9);
    color: #0f0; /* Green text */
    padding: 10px;
    font-family: monospace;
    font-size: 10px; /* Smaller font */
    max-height: 150px; /* Smaller height */
    overflow-y: auto;
    z-index: 99999; /* Below nav */
    display: none;
    border-top: 1px solid #333;
"></div>
<button onclick="document.getElementById('debugConsole').style.display =
    document.getElementById('debugConsole').style.display === 'none' ? 'block' : 'none'"
    style="
        position: fixed;
        bottom: 70px; /* Position above nav */
        right: 10px;
        z-index: 100001; /* Above nav and console */
        padding: 4px 8px;
        background: #505;
        color: white;
        border: 1px solid #808;
        border-radius: 5px;
        font-size: 10px;
        opacity: 0.8;
    ">
    DBG
</button>
    <script>
        console.log('Script started');
        // --- Debug Logging Helper ---
        function debugLog(message) {
             console.log(message); // Log to browser console
             const debugConsole = document.getElementById('debugConsole');
             if (debugConsole) {
                 const time = new Date().toLocaleTimeString();
                 const div = document.createElement('div');
                 div.textContent = `${time}: ${message}`;
                 debugConsole.appendChild(div);
                 // Auto-scroll to bottom
                 debugConsole.scrollTop = debugConsole.scrollHeight;
             }
         }
         // Overwrite console.error to also log to debug console
         const originalConsoleError = console.error;
         console.error = function(...args) {
             originalConsoleError.apply(console, args);
             debugLog(`ERROR: ${args.join(' ')}`);
         };
        debugLog('Nav buttons present at start: ' + document.querySelectorAll('.nav-button').length);


        // Function to dynamically load a script and return a Promise
        function loadScript(src, retries = 3, delay = 1000) {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const tryLoad = () => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.async = true;
                    script.onload = () => {
                        debugLog(`Script loaded: ${src}`);
                        resolve();
                    };
                    script.onerror = (err) => { // Get error event
                        attempts++;
                         const errorMsg = `Failed to load script: ${src} (Attempt ${attempts}/${retries}). Error: ${err ? err.type : 'Unknown'}`;
                        if (attempts < retries) {
                            console.warn(errorMsg + " Retrying...");
                             debugLog(errorMsg + " Retrying...");
                            setTimeout(tryLoad, delay);
                        } else {
                            console.error(errorMsg + " Max retries reached.");
                             debugLog(errorMsg + " Max retries reached.");
                            reject(new Error(`Failed to load script after ${retries} attempts: ${src}`));
                        }
                    };
                    document.head.appendChild(script);
                };
                tryLoad();
            });
        }

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCUkEmFmJK2vr8k7M6JqYaxlcgBDf7WdJI", // Consider using environment variables
            authDomain: "fourgo-cd98f.firebaseapp.com",
            projectId: "fourgo-cd98f",
            storageBucket: "fourgo-cd98f.firebasestorage.app",
            messagingSenderId: "511215742272",
            appId: "1:511215742272:web:04bd85a284919ae123dea5",
            measurementId: "G-DC7E6ECF2L"
        };

        // Validate Firebase Configuration
        function validateFirebaseConfig(config) {
             debugLog("Validating Firebase config...");
            const requiredFields = ['apiKey','authDomain','projectId','storageBucket','messagingSenderId','appId'];
            for (const field of requiredFields) {
                if (!config[field]) {
                     const errorMsg = `Firebase config is missing required field: ${field}`;
                     console.error(errorMsg);
                     throw new Error(errorMsg);
                }
            }
            debugLog("Firebase config validated.");
        }

        // Initialize Firebase with dynamic loading using compat scripts
        let app, db, auth, storage, analytics;
        let firebaseInitialized = false;
        async function initializeFirebase(maxRetries = 3) {
            if (firebaseInitialized) {
                debugLog("Firebase already initialized.");
                return true;
            }
            debugLog("Attempting Firebase initialization...");

             // Check if Firebase is already in the global scope and has an app instance
             if (window.firebase && window.firebase.apps && window.firebase.apps.length > 0) {
                 debugLog("Firebase detected in global scope, reusing existing instance.");
                 app = window.firebase.apps[0]; // Use the first initialized app
                 try {
                     db = firebase.firestore(app); // Get Firestore instance for the app
                     auth = firebase.auth(app); // Get Auth instance
                     storage = firebase.storage(app); // Get Storage instance
                     if (firebase.analytics) { // Check if analytics was initialized
                         analytics = firebase.analytics(app);
                     } else {
                         debugLog("Analytics not found on existing instance, trying to load...");
                         await loadScript('https://www.gstatic.com/firebasejs/10.13.0/firebase-analytics-compat.js');
                         if (firebase.analytics) analytics = firebase.analytics(app);
                     }
                     firebaseInitialized = true;
                     debugLog("Firebase components attached from existing instance.");
                     return true;
                 } catch (e) {
                     console.error("Error attaching Firebase components from existing instance:", e);
                     debugLog("Error reusing Firebase instance, will try full re-init.");
                     // Proceed with full initialization if attaching failed
                 }
             }


            let attempts = 0;
            const scriptUrls = [
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-app-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-auth-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-firestore-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-storage-compat.js',
                'https://www.gstatic.com/firebasejs/10.13.0/firebase-analytics-compat.js'
            ];

            while (attempts < maxRetries && !firebaseInitialized) {
                attempts++;
                debugLog(`Firebase Init Attempt ${attempts}/${maxRetries}...`);
                try {
                    validateFirebaseConfig(firebaseConfig); // Validate config each time

                    // Ensure all scripts are loaded
                    await Promise.all(scriptUrls.map(url => loadScript(url, 1))); // Only 1 retry per script load here

                    if (typeof firebase === 'undefined') {
                        throw new Error("Firebase SDK global object not found after loading scripts.");
                    }

                    // Initialize Firebase App (only if not already initialized)
                    if (!firebase.apps.length) {
                         debugLog("Initializing new Firebase app...");
                        app = firebase.initializeApp(firebaseConfig);
                    } else {
                         debugLog("Using existing Firebase app instance.");
                        app = firebase.app(); // Get default app
                    }

                    // Get Firebase services
                    db = firebase.firestore(app);
                    auth = firebase.auth(app);
                    storage = firebase.storage(app);
                    analytics = firebase.analytics(app); // Initialize Analytics

                    // Test Firestore connection with a read operation
                    debugLog("Testing Firestore connection...");
                    await db.collection('test').doc('init_read').get(); // Attempt a read
                    debugLog("Firestore connection successful.");

                    firebaseInitialized = true;
                    debugLog("Firebase fully initialized and connected.");
                    return true;

                } catch (error) {
                    console.error(`Firebase init attempt ${attempts} failed:`, error);
                    if (attempts >= maxRetries) {
                        debugLog("Max retries reached. Firebase initialization failed.");
                        return false;
                    }
                    await new Promise(resolve => setTimeout(resolve, 2000 * attempts)); // Exponential backoff
                }
            }
            return false; // Failed after retries
        } // End initializeFirebase

        // Telegram Web App Setup
        let telegramUser = null; // Initialize as null
        function initializeTelegramWebApp() {
             debugLog("Initializing Telegram Web App...");
             try {
                 if (!window.Telegram || !window.Telegram.WebApp) {
                     throw new Error("Telegram WebApp script not loaded or available.");
                 }

                 window.Telegram.WebApp.ready(); // Signal readiness

                 // Expand viewport if possible
                 if (window.Telegram.WebApp.isExpanded) {
                     debugLog("WebApp already expanded.");
                 } else {
                      window.Telegram.WebApp.expand();
                     debugLog("Requested WebApp expansion.");
                 }
                 // Set background color (optional)
                  window.Telegram.WebApp.setHeaderColor('#330033'); // Match header gradient start
                  window.Telegram.WebApp.setBackgroundColor('#000000'); // Match body gradient end


                 if (window.Telegram.WebApp.initDataUnsafe && window.Telegram.WebApp.initDataUnsafe.user) {
                     telegramUser = window.Telegram.WebApp.initDataUnsafe.user;
                     debugLog(`Telegram User Initialized: ID=${telegramUser.id}, Name=${telegramUser.first_name}`);
                     const profilePic = document.querySelector('.profile-pic img');
                     if (profilePic) profilePic.src = telegramUser.photo_url || 'assets/icons/user-avatar.png';
                     // Set header title dynamically if needed
                     // const headerTitle = document.querySelector('header h1');
                     // if (headerTitle) headerTitle.innerText = `Welcome, ${telegramUser.first_name}`;
                 } else {
                      debugLog("No Telegram user data found in initDataUnsafe. Using fallback.");
                     // Fallback for testing outside Telegram
                     telegramUser = { id: "test_user_12345", username: "TestUserLocal", first_name: "Test", photo_url: "https://via.placeholder.com/40/eee/000?text=L" };
                     const profilePic = document.querySelector('.profile-pic img');
                      if (profilePic) profilePic.src = telegramUser.photo_url;
                 }
             } catch (error) {
                 console.error("Telegram Web App initialization failed:", error);
                 debugLog(`Telegram Web App init failed: ${error.message}`);
                 // Use fallback user if initialization fails
                 telegramUser = { id: "test_user_failed_init", username: "TestUserFail", first_name: "Fail", photo_url: "https://via.placeholder.com/40/f00/fff?text=E" };
                 const profilePic = document.querySelector('.profile-pic img');
                 if (profilePic) profilePic.src = telegramUser.photo_url;
             }
         } // End initializeTelegramWebApp

        // Storage abstraction using Firebase Firestore
        const Storage = {
            getItem: async (key) => {
                if (!firebaseInitialized || !db) { console.error("FS getItem: Not initialized."); return null; }
                if (!telegramUser || !telegramUser.id) { console.error("FS getItem: No user ID."); return null; }
                try {
                    const doc = await db.collection('userData').doc(telegramUser.id.toString()).get();
                    return doc.exists ? doc.data()[key] : null;
                } catch (error) { console.error(`FS getItem Error (${key}):`, error); return null; }
            },
            setItem: async (key, value) => {
                if (!firebaseInitialized || !db) { console.error("FS setItem: Not initialized."); return false; }
                if (!telegramUser || !telegramUser.id) { console.error("FS setItem: No user ID."); return false; }
                try {
                    await db.collection('userData').doc(telegramUser.id.toString()).set({ [key]: value }, { merge: true });
                    return true;
                } catch (error) { console.error(`FS setItem Error (${key}):`, error); return false; }
            }
        };

        // --- Navigation Logic ---
        document.addEventListener('DOMContentLoaded', () => {
            debugLog("DOM Loaded. Setting up navigation...");
            try {
                const sections = document.querySelectorAll('.section');
                const navButtons = document.querySelectorAll('nav.bottom-nav .nav-button');
                const bottomNav = document.querySelector('nav.bottom-nav');

                if (!bottomNav || sections.length === 0 || navButtons.length === 0) {
                     console.error("Navigation elements missing!");
                     debugLog("ERROR: Navigation elements missing!");
                     return;
                }
                debugLog(`Found ${sections.length} sections, ${navButtons.length} nav buttons.`);

                 // Ensure default section is active initially ('earn')
                 document.getElementById('earn')?.classList.add('active');
                 document.querySelector('.nav-button[data-section="earn"]')?.classList.add('active');


                async function switchSection(sectionId) {
                    debugLog(`Switching to section: ${sectionId}`);
                    // Hide all sections
                    sections.forEach(section => section.classList.remove('active'));
                    // Deactivate all buttons
                    navButtons.forEach(btn => btn.classList.remove('active'));

                    const targetSection = document.getElementById(sectionId);
                    const targetButton = document.querySelector(`.nav-button[data-section="${sectionId}"]`);

                    if (targetSection) {
                        targetSection.classList.add('active');
                    } else {
                         console.error(`Section with id "${sectionId}" not found`);
                         debugLog(`ERROR: Section #${sectionId} not found!`);
                         // Fallback to default section?
                         document.getElementById('earn')?.classList.add('active');
                         document.querySelector('.nav-button[data-section="earn"]')?.classList.add('active');
                         return; // Prevent further errors
                    }

                    if (targetButton) {
                        targetButton.classList.add('active');
                    } else {
                         console.error(`Button with data-section "${sectionId}" not found`);
                         debugLog(`ERROR: Nav button for ${sectionId} not found!`);
                    }

                    // --- Update section content when switched ---
                    // Use ensureFirebaseReady for sections needing DB access
                     try {
                         switch (sectionId) {
                             case 'earn':
                                 await ensureFirebaseReady(updateEarnSectionUI);
                                 break;
                             case 'invite':
                                 await ensureFirebaseReady(updateInviteSectionUI);
                                 break;
                             case 'top':
                                 await ensureFirebaseReady(updateTopSectionUI);
                                 break;
                             case 'wallet':
                                 await ensureFirebaseReady(updateWalletSectionUI);
                                 break;
                             case 'chest':
                                 await ensureFirebaseReady(updateChestSectionUI);
                                 break;
                             // Add cases for other sections if they need dynamic updates
                         }
                     } catch (error) {
                          console.error(`Error updating section ${sectionId}:`, error);
                          debugLog(`ERROR updating section ${sectionId}: ${error.message}`);
                     }
                }

                // Add click listeners to nav buttons
                navButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const sectionId = button.getAttribute('data-section');
                        if (sectionId) {
                             switchSection(sectionId);
                        } else {
                              console.error("Nav button missing data-section attribute:", button);
                              debugLog("ERROR: Nav button missing data-section");
                        }
                    });
                });

                 // Force nav visibility (redundant if CSS is correct, but safe)
                 bottomNav.style.visibility = 'visible';
                 bottomNav.style.opacity = '1';
                 debugLog("Navigation setup complete.");

            } catch (error) {
                console.error('Navigation setup failed:', error);
                debugLog(`FATAL ERROR: Navigation setup failed: ${error.message}`);
            }
        }); // End DOMContentLoaded for navigation

        // Helper to ensure Firebase is ready before running a callback
        async function ensureFirebaseReady(callback, needsAnalytics = false) {
            if (!firebaseInitialized || !db || !auth) {
                debugLog("Firebase not ready for callback, attempting init...");
                const success = await initializeFirebase();
                if (!success) {
                    console.error("Firebase init failed in ensureFirebaseReady.");
                    debugLog("ERROR: Firebase init failed in ensureFirebaseReady.");
                    alert("Database connection failed. Please try again later.");
                    throw new Error("Firebase initialization failed."); // Throw error to stop callback
                }
            }
            if (needsAnalytics && !analytics) {
                 debugLog("Analytics needed but not ready, attempting init/load...");
                 // Simplified: Assume initializeFirebase handles analytics loading
                 if (!analytics) { // Check again after init attempt
                       console.warn("Analytics still not available after init.");
                       debugLog("WARN: Analytics still not available.");
                       // Proceed without analytics? Or throw error? For now, proceed.
                 }
            }
            debugLog(`Executing callback: ${callback.name || 'anonymous'}`);
            try {
                await callback();
            } catch (error) {
                 console.error(`Error during Firebase-dependent callback (${callback.name || 'anonymous'}):`, error);
                 debugLog(`ERROR in callback ${callback.name || 'anonymous'}: ${error.message}`);
                 // Decide if the error should be thrown up to stop further execution
                 // throw error; // Uncomment to propagate the error
            }
        } // End ensureFirebaseReady


        // --- User Data Management ---
         async function initializeUserData() {
             // Added check for telegramUser readiness
             if (!telegramUser || !telegramUser.id) {
                 debugLog("WARN: initializeUserData called before telegramUser is ready.");
                 return; // Wait for telegramUser
             }
             if (!firebaseInitialized || !db) {
                 console.error("Firestore not initialized for User Data init.");
                 debugLog("ERROR: Firestore not ready for User Data init.");
                 return;
             }
             const userIdStr = telegramUser.id.toString();
             const userDocRef = db.collection('userData').doc(userIdStr);
             const rankingDocRef = db.collection('users').doc(userIdStr);

             debugLog(`Initializing user data for ID: ${userIdStr}`);
             try {
                 const doc = await userDocRef.get();
                 if (!doc.exists) {
                      debugLog("New user detected. Creating data document...");
                     const initialData = {
                         gems: 0, usdt: 0, ton: 0,
                         referrals: 0, inviteRecords: [], totalCreditsEarnedFromInvites: 0,
                         landPieces: 0, foxMedals: 0, vipLevel: 0, // Added vipLevel
                         isReferred: false,
                         createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                         claimedQuests: [], adProgress: {},
                         walletAddress: null
                     };
                     await userDocRef.set(initialData);
                     debugLog("userData document created.");

                     // Initialize ranking data
                     const rankingData = {
                         username: telegramUser.username || telegramUser.first_name || `User_${userIdStr.substring(0,4)}`,
                         foxMedals: 0,
                         photoUrl: telegramUser.photo_url || 'https://via.placeholder.com/40/808080/000000?text=U'
                     };
                     await rankingDocRef.set(rankingData, { merge: true });
                      debugLog("Ranking data initialized/merged.");

                     if (analytics) analytics.logEvent('sign_up', { method: 'telegram', userId: userIdStr });
                 } else {
                      debugLog("Existing user data found.");
                     // Schema migration/check for existing users
                     const currentData = doc.data();
                     const updates = {};
                     if (currentData.claimedQuests === undefined) updates.claimedQuests = [];
                     if (currentData.adProgress === undefined) updates.adProgress = {};
                     if (currentData.inviteRecords === undefined) updates.inviteRecords = [];
                     if (currentData.totalCreditsEarnedFromInvites === undefined) updates.totalCreditsEarnedFromInvites = 0;
                     if (currentData.vipLevel === undefined) updates.vipLevel = 0; // Add missing vipLevel

                     if (Object.keys(updates).length > 0) {
                          debugLog("Applying schema updates to existing user data...");
                         await userDocRef.update(updates);
                          debugLog("Schema updates applied.");
                     }
                 }
                 await updateUserStatsUI(); // Update UI after ensuring data exists/is updated
             } catch (error) {
                 console.error("Error initializing/checking user data:", error);
                 debugLog(`ERROR initializing user data: ${error.message}`);
             }
         } // End initializeUserData

         async function updateUserStatsUI() {
             if (!telegramUser || !telegramUser.id) { debugLog("WARN: updateUserStatsUI - No user."); return; }
             if (!firebaseInitialized || !db) { debugLog("ERROR: updateUserStatsUI - Firestore not ready."); return; }
             const userIdStr = telegramUser.id.toString();
             // debugLog("Updating user stats UI..."); // Can be noisy
             try {
                 const userDoc = await db.collection('userData').doc(userIdStr).get();
                 if (!userDoc.exists) { debugLog("WARN: User data not found for UI update."); return; }
                 const data = userDoc.data();
                 document.getElementById('gems').textContent = data.gems || 0;
                 document.getElementById('usdt').textContent = (data.usdt || 0).toFixed(4);
                 document.getElementById('ton').textContent = (data.ton || 0).toFixed(4);
                 // Update wallet section balances too
                 document.getElementById('wallet-usdt').textContent = (data.usdt || 0).toFixed(4);
                 document.getElementById('wallet-ton').textContent = (data.ton || 0).toFixed(4);
                 // debugLog("User stats UI updated."); // Can be noisy
             } catch (error) { console.error("Error updating user stats UI:", error); debugLog(`ERROR updating stats UI: ${error.message}`); }
         } // End updateUserStatsUI


        // --- Earn Section Logic ---
        async function updateEarnSectionUI() {
             // Ensure user is ready before proceeding
             if (!telegramUser || !telegramUser.id) { debugLog("WARN: updateEarnSectionUI - User not ready."); return; }
             if (!firebaseInitialized || !db) { debugLog("ERROR: updateEarnSectionUI - Firestore not ready."); return; }

             debugLog("Updating Earn Section UI...");
            const dailyQuestList = document.getElementById('daily-quest-list');
            const basicQuestList = document.getElementById('basic-quest-list');
             const dailyQuestCountEl = document.getElementById('daily-quest-count');
             const basicQuestCountEl = document.getElementById('basic-quest-count');
             if (!dailyQuestList || !basicQuestList || !dailyQuestCountEl || !basicQuestCountEl) {
                 console.error("Earn section DOM elements missing!");
                 debugLog("ERROR: Earn section DOM elements missing!");
                 return;
             }
             // Show loading state
             dailyQuestList.innerHTML = '<li><p>Loading Daily Quests...</p></li>';
             basicQuestList.innerHTML = '<li><p>Loading Basic Quests...</p></li>';

            try {
                // Fetch User Data (needed for quest status)
                 const userDoc = await db.collection('userData').doc(telegramUser.id.toString()).get();
                 if (!userDoc.exists) { throw new Error("User data not found for Earn section."); }
                 const userData = userDoc.data();
                 userData.adProgress = userData.adProgress || {};
                 userData.claimedQuests = userData.claimedQuests || [];
                 const currentTime = new Date(); // For cooldown checks

                 // --- Fetch & Render Daily Quests ---
                 const dailyQuestsSnapshot = await db.collection('quests').doc('daily').get({ source: 'server' });
                 const dailyQuestsRaw = dailyQuestsSnapshot.exists ? dailyQuestsSnapshot.data() : {};
                 const dailyQuests = (dailyQuestsRaw.tasks || []).map(q => ({ /* validation */
                     id: q.id || `daily_${Math.random().toString(16).slice(2)}`, title: q.title || "?", icon: q.icon || '',
                     reward: Number(q.reward) || 0, action: q.action || 'GO', link: q.link || '', type: q.type || 'default'
                 }));
                 dailyQuestCountEl.textContent = dailyQuests.length;
                 if (dailyQuests.length === 0) {
                     dailyQuestList.innerHTML = `<li><p>No daily quests today.</p></li>`;
                 } else {
                     dailyQuestList.innerHTML = dailyQuests.map(quest => {
                         const isClaimed = userData.claimedQuests?.includes(quest.id);
                         const buttonText = isClaimed ? 'Claimed' : quest.action;
                         const buttonClass = isClaimed ? 'claimed-button' : 'go-button';
                         const buttonStyle = isClaimed ? 'background: #ccc; cursor: default;' : 'background: linear-gradient(to right, #ff00ff, #ff6666);';
                         const rewardDisplay = quest.reward > 0 ? `<img src="assets/icons/gem.png" alt="Gem"><span>+${quest.reward}</span>` : '';
                         return `
                             <li class="quest-item" data-quest-id="${quest.id}" data-quest-type="${quest.type}" data-quest-reward="${quest.reward}">
                                 <img src="${quest.icon}" alt="" onerror="this.style.display='none'">
                                 <span style="flex-grow: 1; margin: 0 10px;">${quest.title}</span>
                                 <div class="quest-reward">
                                     ${rewardDisplay}
                                     <button class="${buttonClass}" data-quest-link="${quest.link}" data-quest-title="${quest.title}" style="${buttonStyle}" ${isClaimed ? 'disabled' : ''}>${buttonText}</button>
                                 </div>
                             </li>`;
                     }).join('');
                 }


                 // --- Fetch & Render Basic Quests ---
                 const basicQuestsSnapshot = await db.collection('quests').doc('basic').get({ source: 'server' });
                 const basicQuestsRaw = basicQuestsSnapshot.exists ? basicQuestsSnapshot.data() : {};
                 const basicQuests = (basicQuestsRaw.tasks || []).map(q => ({ /* validation */
                      id: q.id || `basic_${Math.random().toString(16).slice(2)}`, title: q.title || "?", icon: q.icon || '',
                      reward: Number(q.reward) || 0, action: q.action || 'GO', link: q.link || '', type: q.type || 'default',
                      adLimit: Number(q.adLimit) || 0, adType: q.adType || 'rewarded_interstitial' // Default adType
                 }));
                 basicQuestCountEl.textContent = basicQuests.length;
                 if (basicQuests.length === 0) {
                     basicQuestList.innerHTML = `<li><p>No basic quests available.</p></li>`;
                 } else {
                     basicQuestList.innerHTML = basicQuests.map(quest => {
                         // *** Corrected Basic Quest Rendering Logic ***
                         const isCompletedGeneral = userData.claimedQuests?.includes(quest.id);
                         let buttonText, buttonClass, buttonStyle, isDisabled = false;
                         let rewardDisplay = ''; // Holds HTML for reward/progress part

                         if (quest.type === 'ads' && quest.reward === 0) {
                             // --- Zero-Reward Ad Quests ---
                             if (isCompletedGeneral) {
                                 buttonText = 'Completed'; buttonClass = 'claimed-button'; buttonStyle = 'background: #ccc; cursor: default;'; isDisabled = true;
                             } else {
                                 buttonText = quest.action || 'Watch Ad'; buttonClass = 'go-button'; buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);'; isDisabled = false;
                             }
                             rewardDisplay = ''; // Explicitly empty for zero-reward ads
                         } else if (quest.type === 'ads') {
                             // --- Reward Ad Quests ---
                             const adProgress = userData.adProgress[quest.id] || { watched: 0, claimed: false, lastClaimed: null };
                             const isTaskCompleted = adProgress.watched >= quest.adLimit;
                             let isTaskClaimed = adProgress.claimed; // Mutable for reset logic
                             const lastClaimedTime = adProgress.lastClaimed ? new Date(adProgress.lastClaimed) : null;
                             const timeSinceLastClaim = lastClaimedTime ? currentTime.getTime() - lastClaimedTime.getTime() : Infinity;
                             const cooldownPeriod = 3600000; // 1 hour
                             const isCooldownOver = timeSinceLastClaim >= cooldownPeriod;

                             if (isTaskClaimed && isCooldownOver) { // Reset condition
                                 debugLog(`Resetting reward ad quest ${quest.id} (cooldown over)`);
                                 isTaskClaimed = false; // Treat as not claimed for this render cycle
                                 // Firestore update happens in background via click handler or separate process
                             }

                             if (isTaskClaimed && !isCooldownOver) { // Claimed, within cooldown
                                 const timeLeft = Math.ceil((cooldownPeriod - timeSinceLastClaim) / 60000);
                                 buttonText = `Wait ${timeLeft}m`; buttonClass = 'claimed-button'; buttonStyle = 'background: #ccc; cursor: default;'; isDisabled = true;
                             } else if (isTaskCompleted && !isTaskClaimed) { // Ready to claim (or reset and ready)
                                 buttonText = 'Claim'; buttonClass = 'claim-button active'; buttonStyle = 'background: linear-gradient(to right, #00ff00, #66ff66);'; isDisabled = false;
                             } else { // Needs watching (not complete OR reset)
                                 buttonText = quest.action || 'Watch Ad'; buttonClass = 'go-button'; buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);';
                                 isDisabled = isTaskClaimed && !isCooldownOver; // Should be caught above, but safe check
                             }
                             // Display reward AND progress for reward ads
                             rewardDisplay = `<img src="assets/icons/gem.png" alt="Gem"><span>+${quest.reward}</span><span class="progress">${adProgress.watched}/${quest.adLimit}</span>`;
                         } else {
                             // --- Non-Ad Quests (Link etc.) ---
                             if (isCompletedGeneral) {
                                 buttonText = 'Claimed'; buttonClass = 'claimed-button'; buttonStyle = 'background: #ccc; cursor: default;'; isDisabled = true;
                             } else {
                                 buttonText = quest.action || 'GO'; buttonClass = 'go-button'; buttonStyle = 'background: linear-gradient(to right, #ff00ff, #ff6666);'; isDisabled = false;
                             }
                             // Display reward only if > 0
                             rewardDisplay = quest.reward > 0 ? `<img src="assets/icons/gem.png" alt="Gem"><span>+${quest.reward}</span>` : '';
                         }

                         // Construct the final list item HTML
                         return `
                             <li class="quest-item" data-quest-id="${quest.id}" data-quest-type="${quest.type}" data-ad-limit="${quest.adLimit}" data-ad-type="${quest.adType}" data-quest-reward="${quest.reward}">
                                 <img src="${quest.icon}" alt="" onerror="this.style.display='none'">
                                 <span style="flex-grow: 1; margin: 0 10px; overflow: hidden; text-overflow: ellipsis;">${quest.title}</span>
                                 <div class="quest-reward">
                                     ${rewardDisplay} {/* Correctly contains HTML or is empty */}
                                     <button class="${buttonClass}" data-quest-link="${quest.link}" data-quest-title="${quest.title}" style="${buttonStyle}" ${isDisabled ? 'disabled' : ''}>${buttonText}</button>
                                 </div>
                             </li>
                         `;
                         // *** End Corrected Rendering Logic ***
                     }).join('');
                 }
                 debugLog("Earn section UI update complete.");

            } catch (error) {
                console.error("Failed to update Earn section UI:", error);
                debugLog(`ERROR updating Earn UI: ${error.message}`);
                dailyQuestList.innerHTML = `<li><p>Error loading quests.</p></li>`;
                basicQuestList.innerHTML = `<li><p>Error loading quests.</p></li>`;
            }
        } // End updateEarnSectionUI


        // --- Invite Section Logic ---
        function generateReferralLink() {
            if (!telegramUser || !telegramUser.id) { debugLog("WARN: generateReferralLink - No user."); return; }
            const botUsername = 'fourgobot'; // Ensure this is correct
            const referralLink = `https://t.me/${botUsername}?start=ref_${telegramUser.id}`;
            document.querySelector('.invite-friend')?.setAttribute('data-link', referralLink);
            document.querySelector('.copy-link')?.setAttribute('data-link', referralLink);
            debugLog("Referral link generated.");
        }

        async function handleReferral() {
             if (!telegramUser || !telegramUser.id) { debugLog("WARN: handleReferral - No user."); return; }
             if (!firebaseInitialized || !db) { debugLog("ERROR: handleReferral - Firestore not ready."); return; }

             let startParam = null;
             try {
                 startParam = window.Telegram?.WebApp?.initDataUnsafe?.start_param;
             } catch (e) { debugLog("Error accessing start_param."); }

             if (startParam && startParam.startsWith('ref_')) {
                 const referrerId = startParam.split('_')[1];
                 const currentUserId = telegramUser.id.toString();
                 debugLog(`Handling referral: Referrer=${referrerId}, New User=${currentUserId}`);
                 if (referrerId === currentUserId) { debugLog("Self-referral attempt blocked."); return; }

                 const userDocRef = db.collection('userData').doc(currentUserId);
                 const referrerDocRef = db.collection('userData').doc(referrerId);

                 try {
                     const userDoc = await userDocRef.get();
                     if (userDoc.exists && userDoc.data().isReferred === true) {
                          debugLog("User already referred.");
                          return;
                     }

                     // Use transaction for atomic update
                     await db.runTransaction(async (transaction) => {
                         const referrerDoc = await transaction.get(referrerDocRef);
                         if (!referrerDoc.exists) {
                              debugLog(`Referrer ${referrerId} not found.`);
                              // Decide: Still mark user as referred, or fail? Mark as referred.
                              transaction.set(userDocRef, { isReferred: true }, { merge: true }); // Use set w/ merge if user doc might not exist yet
                              return; // Stop if referrer doesn't exist
                         }

                         const creditsPerReferral = 10; // Configurable
                         const gemsPerReferral = 50;   // Configurable

                         const newRecord = {
                             userId: currentUserId,
                             username: telegramUser.username || telegramUser.first_name || `User...${currentUserId.slice(-4)}`,
                             joinTime: new Date().toISOString().split('.')[0].replace('T', ' '),
                             credit: creditsPerReferral
                         };

                         // Update referrer
                         transaction.update(referrerDocRef, {
                             referrals: firebase.firestore.FieldValue.increment(1),
                             gems: firebase.firestore.FieldValue.increment(gemsPerReferral),
                             totalCreditsEarnedFromInvites: firebase.firestore.FieldValue.increment(creditsPerReferral),
                             inviteRecords: firebase.firestore.FieldValue.arrayUnion(newRecord)
                         });

                         // Mark current user as referred
                         transaction.set(userDocRef, { isReferred: true }, { merge: true }); // Use set w/ merge
                     });

                      debugLog(`Referral success: User ${currentUserId} referred by ${referrerId}`);
                     if (analytics) analytics.logEvent('referral_success', { referrer_id: referrerId, user_id: currentUserId });

                 } catch (error) {
                      console.error("Error handling referral transaction:", error);
                      debugLog(`ERROR handling referral: ${error.message}`);
                 }
             }
         } // End handleReferral


        async function updateInviteSectionUI() {
             if (!telegramUser || !telegramUser.id) { debugLog("WARN: updateInviteUI - No user."); return; }
             if (!firebaseInitialized || !db) { debugLog("ERROR: updateInviteUI - Firestore not ready."); return; }
             debugLog("Updating Invite Section UI...");

             const inviteCountEl = document.getElementById('my-invite');
             const totalCreditEl = document.getElementById('total-credit-value'); // Use specific span
             const recordTitleEl = document.getElementById('invite-record-title');
             const recordListContainer = document.querySelector('.invite-record .record-list');
             const claimButton = document.querySelector('.invite-section .claim-button');

             if (!inviteCountEl || !totalCreditEl || !recordTitleEl || !recordListContainer || !claimButton) {
                 console.error("Invite section elements missing!");
                 debugLog("ERROR: Invite section elements missing!");
                 return;
             }

             try {
                 const userDoc = await db.collection('userData').doc(telegramUser.id.toString()).get();
                 if (!userDoc.exists) { throw new Error("User data not found for Invite section."); }
                 const data = userDoc.data();
                 const referrals = data.referrals || 0;
                 const totalCredit = data.totalCreditsEarnedFromInvites || 0;
                 const inviteRecords = data.inviteRecords || [];

                 inviteCountEl.textContent = `My Invite: ${referrals}`;
                 totalCreditEl.textContent = totalCredit; // Update the value span
                 recordTitleEl.textContent = `Invite Record (${inviteRecords.length})`;

                 // Display Invite Records
                 if (inviteRecords.length === 0) {
                     recordListContainer.innerHTML = `<div class="no-frens"><img src="assets/icons/nofrens.png" alt="No Frens"><p>No invites yet</p></div>`;
                 } else {
                     recordListContainer.innerHTML = `
                         <div class="record-header">
                             <span>User</span><span>Join Time</span><span>Credit</span>
                         </div>
                         ${inviteRecords.map(record => `
                             <div class="record-item">
                                 <img src="https://via.placeholder.com/40/eee/000?text=${(record.username || 'U')[0]}" alt="">
                                 <div class="user-info">
                                     <span class="username">${record.username || 'Invited User'}</span>
                                     <small>${record.joinTime || 'N/A'}</small>
                                 </div>
                                 <span class="credit">+${record.credit || 0}</span>
                             </div>`).join('')}`;
                 }

                 // Update Claim button state
                 const creditToUsdtRate = 10000;
                 if (totalCredit >= creditToUsdtRate) {
                     claimButton.disabled = false;
                     claimButton.style.opacity = '1';
                     claimButton.textContent = 'Claim';
                 } else {
                     claimButton.disabled = true;
                     claimButton.style.opacity = '0.5';
                     claimButton.textContent = `Need ${creditToUsdtRate}`;
                 }
                 debugLog("Invite section UI updated.");

             } catch (error) {
                  console.error("Error updating invite section UI:", error);
                  debugLog(`ERROR updating Invite UI: ${error.message}`);
                  inviteCountEl.textContent = `My Invite: Error`;
                  totalCreditEl.textContent = `Error`;
             }
         } // End updateInviteSectionUI


        // Invite Claim Button Logic (inside DOMContentLoaded or attached later)
        document.addEventListener('DOMContentLoaded', () => {
             const claimButton = document.querySelector('.invite-section .claim-button');
             if (claimButton) {
                 claimButton.addEventListener('click', async () => {
                     if (!telegramUser || !telegramUser.id) { alert("User not authenticated."); return; }
                     if (!firebaseInitialized || !db) { alert("Database not ready."); return; }
                     if (claimButton.disabled) return; // Prevent clicking disabled button

                     const userIdStr = telegramUser.id.toString();
                     const userDocRef = db.collection('userData').doc(userIdStr);

                     claimButton.disabled = true; claimButton.textContent = 'Claiming...';
                     debugLog("Attempting to claim invite credits...");

                     try {
                         const usdtClaimed = await db.runTransaction(async (transaction) => {
                             const userDoc = await transaction.get(userDocRef);
                             if (!userDoc.exists) throw new Error("User data missing.");
                             const data = userDoc.data();
                             const currentCredits = data.totalCreditsEarnedFromInvites || 0;
                             const creditToUsdtRate = 10000;
                             if (currentCredits < creditToUsdtRate) throw new Error(`Need ${creditToUsdtRate} credits.`);

                             const usdtToClaim = Math.floor(currentCredits / creditToUsdtRate);
                             const creditsToDeduct = usdtToClaim * creditToUsdtRate;

                             transaction.update(userDocRef, {
                                 usdt: firebase.firestore.FieldValue.increment(usdtToClaim),
                                 totalCreditsEarnedFromInvites: firebase.firestore.FieldValue.increment(-creditsToDeduct)
                             });
                             return usdtToClaim; // Return value from transaction
                         });

                         debugLog(`Claim successful: ${usdtClaimed} USDT`);
                         alert(`Successfully claimed ${usdtClaimed} USDT!`);
                         if (analytics) analytics.logEvent('credit_claim_success', { userId: userIdStr, usdt: usdtClaimed });
                         await updateUserStatsUI(); // Update balances
                         await updateInviteSectionUI(); // Refresh invite section UI

                     } catch (error) {
                          console.error("Error claiming credits:", error);
                          debugLog(`ERROR claiming credits: ${error.message}`);
                          alert("Failed to claim credits: " + error.message);
                          if (analytics) analytics.logEvent('credit_claim_failed', { userId: userIdStr, error: error.message });
                          // Re-enable button via UI update
                          await updateInviteSectionUI();
                     }
                     // No finally needed, updateInviteSectionUI resets button state
                 });
             }
         });


        // --- Chest Section Logic ---
         const chests = [ // Define chest data statically or fetch from Firestore
              { id: "wood", name: "Wood Chest", next: "Bronze", image: "assets/graphics/wood-chest.png", gemCost: 200, vip: 0, rewards: { usdtRange: [0.01, 0.05], landPieceChance: 0.1, foxMedalChance: 0.05 } },
              { id: "bronze", name: "Bronze Chest", next: "Silver", image: "assets/graphics/bronze-chest.png", gemCost: 500, vip: 1, rewards: { usdtRange: [0.03, 0.10], landPieceChance: 0.2, foxMedalChance: 0.1 } },
              { id: "silver", name: "Silver Chest", next: "Gold", image: "assets/graphics/silver-chest.png", gemCost: 1000, vip: 2, rewards: { usdtRange: [0.08, 0.25], landPieceChance: 0.35, foxMedalChance: 0.2 } },
              { id: "gold", name: "Gold Chest", next: "Master", image: "assets/graphics/gold-chest.png", gemCost: 2000, vip: 3, rewards: { usdtRange: [0.20, 0.60], landPieceChance: 0.5, foxMedalChance: 0.35 } },
              { id: "master", name: "Master Chest", next: "Legendary", image: "assets/graphics/master-chest.png", gemCost: 5000, vip: 4, rewards: { usdtRange: [0.50, 1.50], landPieceChance: 0.7, foxMedalChance: 0.5 } },
              { id: "legendary", name: "Legendary Chest", next: "Mythic", image: "assets/graphics/legendary-chest.png", gemCost: 10000, vip: 5, rewards: { usdtRange: [1.20, 3.00], landPieceChance: 0.9, foxMedalChance: 0.7 } },
              { id: "mythic", name: "Mythic Chest", next: "", image: "assets/graphics/mythic-chest.png", gemCost: 20000, vip: 6, rewards: { usdtRange: [2.50, 6.00], landPieceChance: 1.0, foxMedalChance: 0.9 } }
         ];
         let currentChestIndex = 0;

         function buildChestSlider() {
              debugLog("Building chest slider...");
              const container = document.getElementById('chestContainer');
              if (!container) return;
              container.innerHTML = chests.map(chest => `
                  <div class="chest-item">
                      <div class="chest-title"><h2>${chest.name}</h2>${chest.next ? `<span>Next: ${chest.next}</span>` : ''}</div>
                      <div class="chest-image"><img src="${chest.image}" alt="${chest.name}" onerror="this.src='https://via.placeholder.com/150/1a1a3d/FFFFFF?text=Chest'"></div>
                      <div class="not-enough" id="not-enough-${chest.id}" style="display: none;"><span>NOT ENOUGH</span><img src="assets/icons/gem.png" alt="Gem"></div>
                  </div>
              `).join('');
              ensureFirebaseReady(updateChestUI); // Update UI after building
         }

         async function updateChestUI() {
              // debugLog("Updating Chest UI..."); // Can be noisy
              const container = document.getElementById('chestContainer');
              const costEl = document.getElementById('chestCost');
              const vipEl = document.getElementById('chestVipRequirement');
              const buttonEl = document.querySelector('.open-chest-button');
              if (!container || !costEl || !vipEl || !buttonEl || chests.length === 0) return;

              const chest = chests[currentChestIndex];
              container.style.transform = `translateX(-${currentChestIndex * 100}%)`;

              costEl.querySelector('span').textContent = chest.gemCost;
              vipEl.textContent = `NEED VIP ${chest.vip}`;
              costEl.style.display = (chest.vip > 0) ? 'none' : 'flex';
              vipEl.style.display = (chest.vip > 0) ? 'block' : 'none';

              // Fetch user data for state check
              let userGems = 0, userVipLevel = 0;
              if (telegramUser && telegramUser.id && firebaseInitialized && db) {
                  try {
                      const userDoc = await db.collection('userData').doc(telegramUser.id.toString()).get();
                      if (userDoc.exists) {
                          userGems = userDoc.data().gems || 0;
                          userVipLevel = userDoc.data().vipLevel || 0;
                      }
                  } catch (e) { debugLog(`ERROR fetching user data for chest: ${e.message}`); }
              }

              let canOpen = true; let reason = "";
              const notEnoughEl = document.getElementById(`not-enough-${chest.id}`);
              if (notEnoughEl) notEnoughEl.style.display = 'none'; // Hide by default

              if (chest.vip > userVipLevel) { canOpen = false; reason = `Requires VIP ${chest.vip}`; vipEl.style.color = '#ffcc00'; }
              else { vipEl.style.color = '#ccc'; }

              if (canOpen && userGems < chest.gemCost) { canOpen = false; reason = `Need ${chest.gemCost} Gems`; if (notEnoughEl) notEnoughEl.style.display = 'flex'; }

              buttonEl.disabled = !canOpen;
              buttonEl.textContent = reason || `Open Chest (${chest.gemCost} Gems)`;
              buttonEl.style.opacity = canOpen ? '1' : '0.5';
              buttonEl.style.cursor = canOpen ? 'pointer' : 'not-allowed';
              buttonEl.style.background = canOpen ? 'linear-gradient(to right, #ff00ff, #ff6666)' : '#666';

              document.querySelector('.nav-arrow.left').style.display = (currentChestIndex === 0) ? 'none' : 'block';
              document.querySelector('.nav-arrow.right').style.display = (currentChestIndex === chests.length - 1) ? 'none' : 'block';
         }

         async function updateChestSectionUI() { await ensureFirebaseReady(updateChestUI); } // Wrapper

         window.nextChest = function() { if (currentChestIndex < chests.length - 1) { currentChestIndex++; updateChestSectionUI(); } };
         window.prevChest = function() { if (currentChestIndex > 0) { currentChestIndex--; updateChestSectionUI(); } };

         window.openChest = async function() {
              const buttonEl = document.querySelector('.open-chest-button');
              if (!telegramUser || !telegramUser.id) { alert("User not authenticated."); return; }
              if (!firebaseInitialized || !db) { alert("Database not ready."); return; }
              if (buttonEl.disabled) return;

              const userIdStr = telegramUser.id.toString();
              const userDocRef = db.collection('userData').doc(userIdStr);
              const rankingDocRef = db.collection('users').doc(userIdStr);
              const chest = chests[currentChestIndex];

              buttonEl.disabled = true; buttonEl.textContent = 'Opening...';
              debugLog(`Attempting to open chest: ${chest.name}`);

              try {
                  const results = await db.runTransaction(async (transaction) => {
                      const userDoc = await transaction.get(userDocRef);
                      if (!userDoc.exists) throw new Error("User data missing.");
                      const userData = userDoc.data();
                      const currentGems = userData.gems || 0;
                      const currentVipLevel = userData.vipLevel || 0;

                      if (chest.vip > currentVipLevel) throw new Error(`Requires VIP ${chest.vip}`);
                      if (currentGems < chest.gemCost) throw new Error(`Need ${chest.gemCost} Gems.`);

                      // --- Calculate Rewards ---
                      const cfg = chest.rewards; let r = {usdt:0, land:0, medal:0};
                      if (cfg.usdtRange) r.usdt = parseFloat((Math.random()*(cfg.usdtRange[1]-cfg.usdtRange[0])+cfg.usdtRange[0]).toFixed(4));
                      if (cfg.landPieceChance && Math.random() < cfg.landPieceChance) r.land = 1;
                      if (cfg.foxMedalChance && Math.random() < cfg.foxMedalChance) r.medal = 1;
                      // ------------------------

                      transaction.update(userDocRef, {
                          gems: firebase.firestore.FieldValue.increment(-chest.gemCost),
                          usdt: firebase.firestore.FieldValue.increment(r.usdt),
                          landPieces: firebase.firestore.FieldValue.increment(r.land),
                          foxMedals: firebase.firestore.FieldValue.increment(r.medal)
                      });
                      if (r.medal > 0) transaction.set(rankingDocRef, { foxMedals: firebase.firestore.FieldValue.increment(r.medal) }, { merge: true });
                      return r; // Return results
                  });

                  let msg = `Opened ${chest.name}! Rewards:`;
                  if(results.usdt>0) msg+=`\n- ${results.usdt} USDT`;
                  if(results.land>0) msg+=`\n- ${results.land} Land Piece`;
                  if(results.medal>0) msg+=`\n- ${results.medal} Fox Medal`;
                  if(results.usdt===0 && results.land===0 && results.medal===0) msg+=`\n- (No special items)`;
                  alert(msg);
                  debugLog(`Chest opened: ${JSON.stringify(results)}`);
                  if (analytics) analytics.logEvent('chest_opened', { chestId: chest.id, userId: userIdStr, ...results });

                  await updateUserStatsUI();
                  await updateChestUI(); // Update button state etc.
                  if (results.medal > 0) await updateTopSectionUI(); // Refresh leaderboard

              } catch (error) {
                  console.error("Error opening chest:", error);
                  debugLog(`ERROR opening chest: ${error.message}`);
                  alert("Failed to open chest: " + error.message);
                  await updateChestUI(); // Refresh UI to show correct state/button
              }
              // Button re-enabled by updateChestUI
          };
         document.addEventListener('DOMContentLoaded', buildChestSlider); // Build slider on DOM ready


        // --- Top Section (Ranking) ---
         async function updateTopSectionUI() {
             if (!firebaseInitialized || !db) { debugLog("ERROR: updateTopUI - Firestore not ready."); return; }
             debugLog("Updating Top Section UI (Rankings)...");
             const rankingList = document.getElementById('ranking-list');
             if (!rankingList) { debugLog("ERROR: Ranking list element not found."); return; }
             rankingList.innerHTML = `<li class="no-rankings"><p>Loading rankings...</p></li>`;

             try {
                 const rankingsSnapshot = await db.collection('users') // Assumes 'users' collection for ranking
                     .orderBy('foxMedals', 'desc')
                     .limit(30) // Show top 30
                     .get();

                 if (rankingsSnapshot.empty) {
                     rankingList.innerHTML = `<li class="no-rankings"><p>No rankings available yet.</p></li>`;
                 } else {
                     rankingList.innerHTML = rankingsSnapshot.docs.map((doc, index) => {
                         const user = doc.data();
                         return `
                             <li class="ranking-item">
                                 <span class="rank-number">${index + 1}.</span>
                                 <img src="${user.photoUrl || 'https://via.placeholder.com/40/eee/000?text=?'}" alt="" onerror="this.src='https://via.placeholder.com/40/eee/000?text=?'">
                                 <span class="username">${user.username || 'Anonymous'}</span>
                                 <div class="medal-count">
                                     <span>${user.foxMedals || 0}</span>
                                     <img src="assets/icons/fox-medal.png" alt="Medal">
                                 </div>
                             </li>`;
                     }).join('');
                 }
                 debugLog("Top section UI updated.");
             } catch (error) {
                  console.error("Error updating top section UI:", error);
                  debugLog(`ERROR updating Top UI: ${error.message}`);
                  rankingList.innerHTML = `<li class="no-rankings"><p>Error loading rankings.</p></li>`;
             }
         } // End updateTopSectionUI


        // --- Quest Click Event Listener ---
        document.addEventListener('click', async (event) => {
             const button = event.target.closest('.quest-item button'); // Target button within quest item
             if (!button || button.disabled) return; // Ignore if not a button or disabled

             const taskItem = button.closest('.quest-item');
             if (!taskItem) return;

             const questId = taskItem.dataset.questId;
             const reward = parseInt(taskItem.dataset.questReward);
             const questType = taskItem.dataset.questType;
             const adLimit = parseInt(taskItem.dataset.adLimit) || 0;
             const adType = taskItem.dataset.adType || 'rewarded_interstitial'; // Default
             const link = button.dataset.questLink;

             if (!firebaseInitialized || !db) { alert("Database connection error."); return; }
             if (!telegramUser || !telegramUser.id) { alert("User identification error."); return; }

             const userIdStr = telegramUser.id.toString();
             const userDocRef = db.collection('userData').doc(userIdStr);

             button.disabled = true;
             const originalButtonText = button.textContent;
             button.textContent = 'Wait...';
             debugLog(`Processing Quest: ${questId}, Type: ${questType}, Reward: ${reward}`);

             try {
                 const userDoc = await userDocRef.get(); // Get fresh data
                 if (!userDoc.exists) throw new Error("User data lost.");
                 const userData = userDoc.data();
                 userData.adProgress = userData.adProgress || {};
                 userData.claimedQuests = userData.claimedQuests || [];

                 const isZeroRewardAd = questType === 'ads' && reward === 0;
                 const isRewardAd = questType === 'ads' && reward > 0;
                 const isLinkQuest = questType !== 'ads';
                 const adProgress = userData.adProgress[questId] || { watched: 0, claimed: false, lastClaimed: null };

                 // --- Re-check completion status with fresh data ---
                 if ((isZeroRewardAd || isLinkQuest) && userData.claimedQuests.includes(questId)) {
                     throw new Error("Quest already completed.");
                 }
                 if (isRewardAd && adProgress.claimed) {
                     // Add cooldown check here if necessary, though button should be disabled by UI update
                     throw new Error("Quest reward already claimed.");
                 }
                 // ----------------------------------------------

                 // --- Action Logic ---
                 if (button.classList.contains('claim-button') && isRewardAd) { // CLAIM button (Reward Ads)
                     if (adProgress.watched < adLimit) throw new Error(`Watch ${adLimit - adProgress.watched} more ads.`);
                     const currentTime = new Date().toISOString();
                     await userDocRef.update({
                         gems: firebase.firestore.FieldValue.increment(reward),
                         [`adProgress.${questId}`]: { watched: adProgress.watched, claimed: true, lastClaimed: currentTime }
                     });
                     alert(`Claimed ${reward} Gems!`);
                     if (analytics) analytics.logEvent('ads_quest_reward_claimed', { questId, userId: userIdStr, reward });

                 } else if (button.classList.contains('go-button') && (isZeroRewardAd || isRewardAd)) { // GO button (Ads)
                     const needsWatching = isZeroRewardAd || (isRewardAd && adProgress.watched < adLimit && !adProgress.claimed);
                     if (!needsWatching) throw new Error("Ad watching condition not met.");

                     debugLog(`Showing ad for quest ${questId}, type ${adType}`);
                     await showAd(adType); // Show the ad (can throw error)

                     // --- Update Firestore AFTER ad success ---
                     if (isZeroRewardAd) {
                         await userDocRef.update({ claimedQuests: firebase.firestore.FieldValue.arrayUnion(questId) });
                         alert(`Ad watched. Quest completed!`);
                         if (analytics) analytics.logEvent('ad_quest_watched', { questId, userId: userIdStr, reward: 0 });
                     } else { // isRewardAd
                         const newWatched = adProgress.watched + 1;
                         await userDocRef.update({ [`adProgress.${questId}.watched`]: newWatched });
                         alert(`Ad watched! Progress: ${newWatched}/${adLimit}${newWatched >= adLimit ? '. Ready to Claim!' : ''}`);
                         if (analytics) analytics.logEvent('ad_quest_watched', { questId, userId: userIdStr, reward });
                     }

                 } else if (button.classList.contains('go-button') && isLinkQuest) { // GO button (Links)
                     if (link) { Telegram.WebApp.openTelegramLink(link); }
                     else { console.warn(`No link for quest ${questId}`); }

                     const updates = { claimedQuests: firebase.firestore.FieldValue.arrayUnion(questId) };
                     if (reward > 0) updates.gems = firebase.firestore.FieldValue.increment(reward);
                     await userDocRef.update(updates);

                     alert(`Quest completed!${reward > 0 ? ` (+${reward} Gems)` : ''}`);
                     if (analytics) analytics.logEvent('link_quest_completed', { questId, userId: userIdStr, reward });

                 } else {
                      throw new Error("Unknown quest button action."); // Should not happen
                 }

                 // --- Success: Refresh UI ---
                 await updateUserStatsUI();
                 await updateEarnSectionUI();

             } catch (error) {
                  console.error(`Quest Action Error (${questId}):`, error);
                  debugLog(`ERROR Quest (${questId}): ${error.message}`);
                  alert(`Action failed: ${error.message}`);
                  // Restore button state on error ONLY IF it wasn't a completion error
                  if (error.message !== "Quest already completed." && error.message !== "Quest reward already claimed.") {
                       button.disabled = false;
                       button.textContent = originalButtonText;
                  } else {
                       // If error was completion, refresh UI to show correct state
                       await updateEarnSectionUI();
                  }
             }
         }); // End Quest Click Listener


        // --- TON Connect & Wallet Logic ---
        let tonConnectUI = null;

        // Initialize TON Connect with strategies
        async function initializeTonConnect() {
            debugLog("Initializing TON Connect...");
            const manifestUrl = 'https://fourgo.app/tonconnect-manifest.json';
            try {
                if (window.TonConnectUI) {
                    debugLog("TON Connect UI exists globally.");
                    return new TonConnectUI({ manifestUrl });
                }
                debugLog("Attempting load from CDN...");
                const cdnUrl = 'https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js'; // Use latest
                await loadScript(cdnUrl, 2, 500);
                if (window.TonConnectUI) {
                    debugLog("TON Connect UI loaded from CDN.");
                    return new TonConnectUI({ manifestUrl });
                }
                debugLog("CDN failed. Using manual fallback (limited functionality).");
                return createManualTonConnectUI(); // Fallback
            } catch (error) {
                debugLog(`CRITICAL TON Connect init error: ${error.message}. Using manual fallback.`);
                return createManualTonConnectUI();
            }
        }

        // Update Wallet UI (Connect button, status)
        async function updateWalletUI() {
             const elements = getWalletElements();
             if (!elements.connectButton || !elements.connectionStatus) { debugLog("WARN: Wallet UI elements missing for update."); return; }
             const isConnected = tonConnectUI && tonConnectUI.connected;

             if (isConnected) {
                 const address = tonConnectUI.account?.address || 'Unknown Address';
                 const shortAddr = address.length > 10 ? `${address.slice(0, 6)}...${address.slice(-4)}` : address;
                 elements.connectionStatus.textContent = `Connected: ${shortAddr}`;
                 elements.connectionStatus.className = 'wallet-status connected';
                 elements.connectButton.textContent = 'DISCONNECT';
                 elements.connectButton.classList.add('connected');
                 elements.withdrawButtons.forEach(btn => { btn.disabled = false; btn.style.background = '#00ff00'; btn.style.cursor = 'pointer'; });
                 if (address !== 'Unknown Address') await Storage.setItem('walletAddress', address);
             } else {
                 elements.connectionStatus.textContent = 'Disconnected';
                 elements.connectionStatus.className = 'wallet-status disconnected';
                 elements.connectButton.textContent = 'CONNECT TON WALLET';
                 elements.connectButton.classList.remove('connected');
                 elements.withdrawButtons.forEach(btn => { btn.disabled = true; btn.style.background = '#666'; btn.style.cursor = 'not-allowed'; });
             }
             elements.connectButton.disabled = false; // Ensure button is enabled after update
        }

        // Handle Connect/Disconnect Click
        async function handleConnectClick() {
             const btn = getWalletElements().connectButton;
             if (!btn || !tonConnectUI) return;
             btn.disabled = true; btn.textContent = 'Processing...';
             try {
                 if (tonConnectUI.connected) await tonConnectUI.disconnect();
                 else await tonConnectUI.connectWallet(); // Modal opens, status change triggers UI update
             } catch (e) { debugLog(`ERROR Connect/Disconnect: ${e.message}`); alert(`Wallet error: ${e.message}`); await updateWalletUI(); /* Restore state on error */}
         }

        // Initialize Wallet System (Listeners)
        async function initWalletSystem() {
             debugLog("Initializing wallet system...");
             if (!tonConnectUI) { debugLog("ERROR: TON Connect UI not ready for wallet system."); return; }
             const elements = getWalletElements();
             if (!elements.connectButton) { debugLog("ERROR: Connect button missing in wallet init."); return; }

             try {
                 tonConnectUI.onStatusChange(walletInfo => {
                     debugLog(`Wallet status change detected: ${walletInfo ? 'Connected' : 'Disconnected'}`);
                     updateWalletUI(); // Update UI on status change
                 }, error => { // Error callback for status change
                     debugLog(`ERROR onStatusChange: ${error.message}`);
                     alert(`Wallet connection update error: ${error.message}`);
                 });

                 // Setup button listeners
                 elements.connectButton.removeEventListener('click', handleConnectClick); // Prevent duplicates
                 elements.connectButton.addEventListener('click', handleConnectClick);
                 elements.withdrawButtons.forEach(button => {
                     button.removeEventListener('click', withdrawButtonClickHandler); // Prevent duplicates
                     button.addEventListener('click', withdrawButtonClickHandler);
                 });

                 await updateWalletUI(); // Initial UI state
                 debugLog("Wallet system listeners attached.");
             } catch (e) { debugLog(`ERROR initializing wallet system: ${e.message}`); }
         }
         function withdrawButtonClickHandler(event) { showWithdrawModal(event.target.closest('.balance-card')); } // Handler definition

        // Show Withdraw Modal
        function showWithdrawModal(card) {
             if (!card) return;
             const modal = document.getElementById('withdraw-modal');
             const isUsdt = card.classList.contains('usdt-card');
             const currency = isUsdt ? 'USDT' : 'TON';
             const balance = parseFloat(card.querySelector('.balance-info span').textContent);
             const fee = isUsdt ? 0.01 : 0.005; // Example fees
             const minWithdrawal = isUsdt ? 1.0 : 0.1; // Example minimums

             // Populate modal elements
             modal.querySelector('#currency-modal-title').textContent = currency; // Set title
             modal.querySelector('#available-balance').textContent = balance.toFixed(4);
             modal.querySelector('#currency').textContent = currency;
             modal.querySelector('#withdraw-fee').textContent = fee.toFixed(4);
             modal.querySelector('#fee-currency').textContent = currency;
             modal.querySelector('#min-withdraw-amount').textContent = minWithdrawal.toFixed(4);
             modal.querySelector('#min-withdraw-currency').textContent = currency;

             const amountInput = modal.querySelector('#withdraw-amount');
             amountInput.value = '';
             amountInput.min = minWithdrawal.toFixed(4);
             amountInput.max = Math.max(0, balance - fee).toFixed(4); // Prevent negative max
             amountInput.placeholder = `Min ${minWithdrawal.toFixed(4)}`;

             // Attach listeners using cloneNode to ensure clean listeners
             const confirmBtn = modal.querySelector('#confirm-withdraw');
             const cancelBtn = modal.querySelector('#cancel-withdraw');
             const newConfirm = confirmBtn.cloneNode(true);
             const newCancel = cancelBtn.cloneNode(true);
             confirmBtn.parentNode.replaceChild(newConfirm, confirmBtn);
             cancelBtn.parentNode.replaceChild(newCancel, cancelBtn);
             newConfirm.onclick = () => confirmWithdraw(currency, balance, fee, minWithdrawal);
             newCancel.onclick = () => modal.style.display = 'none';

             modal.style.display = 'flex';
         } // End showWithdrawModal

        // Confirm Withdrawal (Simulated)
        async function confirmWithdraw(currency, balance, fee, minWithdrawal) {
             const modal = document.getElementById('withdraw-modal');
             const amountInput = modal.querySelector('#withdraw-amount');
             const confirmBtn = modal.querySelector('#confirm-withdraw');
             const amount = parseFloat(amountInput.value);

             // Validation
             if (isNaN(amount) || amount <= 0 || amount < minWithdrawal || (amount + fee) > balance) {
                 alert("Invalid amount or insufficient balance."); return;
             }
             if (!tonConnectUI?.connected || !tonConnectUI.account?.address) {
                 alert("Wallet not connected."); return;
             }

             confirmBtn.disabled = true; confirmBtn.textContent = 'Processing...';
             const recipient = tonConnectUI.account.address;
             const field = currency.toLowerCase();
             const totalDeduction = amount + fee;
             debugLog(`Attempting withdrawal: ${amount} ${currency} to ${recipient.slice(0,6)}...`);

             try {
                 // ** TODO: Replace with actual backend API call **
                 const txId = `sim_tx_${Date.now()}`;
                 const transactionData = { /* ... tx data ... */
                     txId, userId: telegramUser.id.toString(), amount, currency, fee, totalDeducted,
                     recipient, status: 'pending_backend', timestamp: firebase.firestore.FieldValue.serverTimestamp()
                 };
                 await db.collection('transactions').doc(txId).set(transactionData);
                 await db.collection('userData').doc(telegramUser.id.toString()).update({
                     [field]: firebase.firestore.FieldValue.increment(-totalDeduction)
                 });
                 debugLog(`Withdrawal request logged (Simulated): ${txId}`);
                 // Simulate backend completion (REMOVE IN PROD)
                 setTimeout(() => db.collection('transactions').doc(txId).update({ status: 'completed_simulated' }).catch(e=>debugLog(`Sim complete err: ${e}`)), 8000);

                 modal.style.display = 'none';
                 await updateUserStatsUI();
                 await updateTransactionHistory();
                 alert(`Withdrawal request for ${amount} ${currency} submitted.`);
                 if (analytics) analytics.logEvent('withdrawal_request', { userId: telegramUser.id.toString(), currency, amount });

             } catch (error) {
                  console.error("Withdrawal error:", error);
                  debugLog(`ERROR Withdrawal: ${error.message}`);
                  alert(`Withdrawal failed: ${error.message}`);
                  // Re-enable button on failure
                   const finalConfirmBtn = modal.querySelector('#confirm-withdraw');
                   if (finalConfirmBtn) { finalConfirmBtn.disabled = false; finalConfirmBtn.textContent = 'Confirm'; }
             }
         } // End confirmWithdraw


        // Update Transaction History
        async function updateTransactionHistory() {
             if (!firebaseInitialized || !db || !telegramUser?.id) { debugLog("WARN: updateTxHistory prerequisites not met."); return; }
             const listEl = document.getElementById('transaction-list');
             if (!listEl) return;
             listEl.innerHTML = '<li>Loading history...</li>';
             try {
                 const snapshot = await db.collection('transactions')
                     .where('userId', '==', telegramUser.id.toString())
                     .orderBy('timestamp', 'desc')
                     .limit(20).get();
                 if (snapshot.empty) { listEl.innerHTML = '<li>No transactions yet.</li>'; return; }
                 listEl.innerHTML = snapshot.docs.map(doc => {
                     const tx = doc.data();
                     const date = tx.timestamp?.toDate ? tx.timestamp.toDate().toLocaleString() : 'N/A';
                     const recipient = tx.recipient ? `${tx.recipient.slice(0, 6)}...${tx.recipient.slice(-4)}` : 'N/A';
                     return `<li>Amount: ${tx.amount.toFixed(4)} ${tx.currency} (Fee: ${tx.fee.toFixed(4)})<br>To: ${recipient}<br>Status: <span class="tx-status ${tx.status}">${tx.status.replace(/_/g, ' ')}</span><br>Date: ${date}</li>`;
                 }).join('');
             } catch (e) { debugLog(`ERROR loading tx history: ${e.message}`); listEl.innerHTML = `<li>Error loading history.</li>`; }
         } // End updateTransactionHistory


        // --- Monetag Ad Logic ---
        // ** MODIFIED showAd Function **
        function showAd(adType) {
            // Default to rewarded interstitial if type is unknown/missing
            const effectiveAdType = adType || 'rewarded_interstitial';
             debugLog(`Requesting Ad: Type='${effectiveAdType}'`);

            return new Promise((resolve, reject) => {
                const maxWaitTime = 15000; // 15s timeout
                const startTime = Date.now();

                function checkSDK() {
                    if (window.show_9180370) {
                         debugLog(`Monetag SDK (show_9180370) found. Triggering ad type: ${effectiveAdType}...`);
                        try {
                             // *** ASSUMPTION: Adjust call based on adType ***
                             // This structure assumes how the SDK *might* differentiate types.
                             // Check Monetag docs for the correct method!
                             let sdkCallResult;
                             switch (effectiveAdType.toLowerCase()) {
                                 case 'rewarded_popup':
                                 case 'popup':
                                     // Attempt 1: Pass type as string (Example)
                                     // sdkCallResult = window.show_9180370('popup');
                                     // Attempt 2: Pass type in options object (Example)
                                     sdkCallResult = window.show_9180370({ type: 'popup' });
                                     debugLog("Called show_9180370 with type: 'popup' (Verify SDK docs!)");
                                     break;

                                 case 'inapp': // For the specific in-app interstitial config
                                     sdkCallResult = window.show_9180370({
                                         type: 'inApp',
                                         inAppSettings: { frequency: 1, capping: 0, interval: 0, timeout: 1, everyPage: false } // Minimal config example
                                     });
                                      debugLog("Called show_9180370 with type: 'inApp'");
                                     break;

                                 case 'rewarded_interstitial':
                                 case 'interstitial':
                                 default:
                                     // Default call, likely for standard interstitial
                                     sdkCallResult = window.show_9180370();
                                     debugLog("Called show_9180370 with default parameters.");
                                     break;
                             }

                             // Monetag SDK might not return a reliable promise.
                             // We resolve after a delay, assuming the ad showed.
                             // Log any immediate error from the call itself.
                             setTimeout(() => {
                                  debugLog(`Assuming ad '${effectiveAdType}' completed.`);
                                 resolve();
                             }, 1500); // Short delay assumption

                         } catch (error) {
                             console.error(`Failed to trigger Monetag ad (${effectiveAdType}):`, error);
                             debugLog(`ERROR triggering ad '${effectiveAdType}': ${error.message}`);
                             reject(error);
                         }
                    } else if (Date.now() - startTime < maxWaitTime) {
                        setTimeout(checkSDK, 500); // SDK not ready, retry
                    } else {
                         debugLog(`ERROR: Monetag SDK failed to load within ${maxWaitTime/1000}s.`);
                         reject(new Error("Ad SDK failed to load."));
                    }
                }
                checkSDK();
            });
        } // End showAd


        // --- App Initialization Sequence ---
        async function initApp() {
            debugLog("===== Starting App Initialization =====");
            try {
                 // 1. Initialize Telegram Web App Interface
                 initializeTelegramWebApp();
                 if (!telegramUser) throw new Error("Telegram user could not be initialized.");

                 // 2. Initialize Firebase
                 const firebaseOk = await initializeFirebase();
                 if (!firebaseOk) throw new Error("Firebase initialization failed.");

                 // 3. Initialize User Data (Create or check existing)
                 await initializeUserData(); // Depends on Firebase & Telegram User

                 // 4. Handle Incoming Referral Link
                 await handleReferral(); // Depends on Firebase & Telegram User

                 // 5. Generate User's Referral Link
                 generateReferralLink(); // Depends on Telegram User

                 // 6. Initialize TON Connect
                 tonConnectUI = await initializeTonConnect(); // Needs to finish before wallet system

                 // 7. Initialize Wallet System (UI listeners etc.)
                 await initWalletSystem(); // Depends on TON Connect UI

                 // 8. Build dynamic UI elements (like chests)
                 buildChestSlider(); // Can run once DOM is ready

                 // 9. Initial data load for the default section (Earn)
                 // Ensure this runs *after* user data might be initialized
                 await ensureFirebaseReady(updateEarnSectionUI);


                 debugLog("===== App Initialization Complete =====");

            } catch (error) {
                console.error("App initialization failed:", error);
                debugLog(`FATAL INIT ERROR: ${error.message}`);
                alert("Failed to initialize the app. Please refresh. Error: " + error.message);
                // Show error in UI
                 const mainContent = document.querySelector('.main-content');
                 if (mainContent) mainContent.innerHTML = `<div style='padding:20px; text-align:center; color:red;'><h2>Initialization Error</h2><p>${error.message}</p></div>`;
            }
        } // End initApp

        // Start Initialization when DOM is ready
        document.addEventListener('DOMContentLoaded', initApp);

    </script>
</body>
</html>
